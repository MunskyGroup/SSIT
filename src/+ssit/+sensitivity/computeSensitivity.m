function [sens,constraintBounds, stateSpace] = computeSensitivity(...
    parameters,...
    propensitiesGeneral,...
    tout,...
    fspTol,...
    initialStates,...
    initialProbabilities,...
    stoichMatrix,...
    constraintFunctions, constraintBounds,...
    isTimeInvariant, verbose, useMex, method, app, stateSpace,...
    usePiecewiseFSP,initApproxSS,varNames,useParallel,fspSoln,...
    useReducedModel,modRedTransformMatrices, ...
    useHybrid,hybridOptions,...
    fEscape,bEscape)
arguments
    parameters
    propensitiesGeneral
    tout
    fspTol
    initialStates
    initialProbabilities
    stoichMatrix
    constraintFunctions
    constraintBounds
    isTimeInvariant
    verbose
    useMex
    method
    app
    stateSpace =[];
    usePiecewiseFSP = false;
    initApproxSS = false;
    varNames =[];
    useParallel = false;
    fspSoln = [];
    useReducedModel = false
    modRedTransformMatrices =[]
    useHybrid = false
    hybridOptions = []
    fEscape = []
    bEscape = []
end

app.SensParDropDown.Items = parameters(:,1);

if (strcmp(method, 'forward'))
    try
        % if ~isempty(parameters)
        %     parsDict = containers.Map(parameters(:,1),...
        %         parameters(:,2));
        % else
        %     parsDict=[];
        % end
        % propensities = model.createPropensities(parsDict,app.ReactionsTabOutputs.varNames);
        % [propensityDerivatives,computableSensitivities] = model.findPropensityDerivativesSymbolic(parsDict,app.ReactionsTabOutputs.varNames);
        if isempty(propensitiesGeneral{1}.sensTimeFactorVec)
            obj = formPropensitiesGeneral(obj,'Sensitivities',true);
        end

        n_pars = size(parameters,1);
        computableSensitivities = ones(1,n_pars,'logical');
        relTol=1.0e-10 ;
        absTol=1.0e-6 ;
        % initialSensitivities = zeros(size(initialStates,2)*sum(computableSensitivities), 1);
        initialSensitivities = zeros(size(initialStates,2)*n_pars);
        [Outputs,constraintBounds,stateSpace] = ssit.sensitivity.adaptiveFspForwardSens(tout, initialStates,...
            initialProbabilities, initialSensitivities,...
            stoichMatrix,...
            propensitiesGeneral, parameters, [], computableSensitivities,...
            fspTol,...
            varNames, modRedTransformMatrices, ...
            constraintFunctions, constraintBounds,...
            verbose, useMex, relTol, absTol, stateSpace);

        sens = struct(...
            'format', 'forward',...
            'data', {Outputs}...
            );
        return
    catch
        disp('Error with Analytical Sensitivity Calculations - Switching to Finite Difference Method')
        app.FiniteDifferenceButton.Value = 1;
        app.SensitivityFunctionButton.Value = 0;
    end
end

% If the forward sensitivity did not work, try finite difference.
app.SensParDropDown.Items = parameters(:,1);
perturbationFactor = 1.0e-4;

[outputs,constraintBounds] = ssit.sensitivity.adaptiveFspFiniteDiff(...
    stoichMatrix,...
    propensitiesGeneral,...
    parameters,...
    perturbationFactor,...
    tout,...
    initialStates,...
    initialProbabilities,...
    fspTol,...
    constraintFunctions, constraintBounds,...
    verbose,usePiecewiseFSP,initApproxSS,stateSpace,varNames,useParallel,...
    fspSoln,...
    useReducedModel,modRedTransformMatrices, ...
    useHybrid,hybridOptions,...
    fEscape,bEscape);

sens = struct(...
    'format', 'finitediff',...
    'data', {outputs}...
    );
end