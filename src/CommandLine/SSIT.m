classdef SSIT 
    %% Create an instance of the SSIT class, example:  Model = SSIT;
    % 
    % The SSIT allows users to specify and efficiently solve the chemical  
    % master equation for discrete stochastic models.  SSIT is especially 
    % useful for the analysis of single-cell gene regulaton. Functionality 
    % includes:
    %   * Build, save, and load models defined by their species, parameters, 
    %     propensity functions, stoichiometries, and initial conditions
    %       ** Models can be non-linear and have time-varying propensity 
    %          functions (e.g., inputs), including logical statements
    %   * Load from / export to SimBiology
    %   * Load from / export to SBML
    %   * Solve models using: 
    %       ** ODE analyses and basic moment closure analyses
    %       ** Stochastic trajectories generated by Gillepsie's 
    %          Stochastic Simulation Algorithm (SSA)
    %       ** Finite State Projection (FSP)
    %       ** Hybrid solutions (deterministically + stochastically treated
    %          species population changes through time)
    %       ** Reduced order models (Model Reduction) by:
    %           *** Reduce models using Quasi-Steady State Approximations 
    %               (QSSA) on fast species
    %           *** Reduce models using eigenvalue decomposition
    %           *** Reduce models using coarse meshes
    %           *** Reduce models using principle orthogonal decomposition
    %       ** SSITMultiModel to create multiple models associated with 
    %          different data sets with shared parameter sets
    %   * Generate synthetic data from models using SSA 
    %   * Compute sensitivity of solutions to parameter variations
    %   * Compute the Fisher Information Matrix to determine the amount of
    %     parameter information available from the chosen experiment
    %   * Compute first passage or escape time distributions for complex 
    %     trajectories
    %   * Load and fit experimental data (e.g., spot counts or total 
    %     intensity measurements from smFISH images or flow cytometry)
    %   * Compute the likelihood of the data given model
    %   * Maximize the likelihood using gradient and non-gradient based 
    %     searches
    %   * Sample parameter uncertainty using the Metropolis-Hastings 
    %     algorithm (with custom proposal distributions or 
    %     proposal distributions based on Fisher Information)
    %   * Include custom priors on parameter distributions for Bayesian 
    %     analysis
    %   * Model and account for experimental, measurement, and data 
    %     processing noise
    %       ** Explore effects of extrinsic noise in parameters
    %       ** Calibrate empirical probability distortion operators (PDO) 
    %          to quantify effects of data distortion
    %       ** Include data distortion corrections in parameter estimation
    %   * Inform and improve upon iterative experiment designs by searching 
    %     an experiment design space for optimally informative experiments
    %       ** Utilize the FSP-FIM approach to compare the amount of
    %          information gainable by each potential next experiment
    %       ** Analyze possible next experiments using Bayesian sequential
    %          experiment design
    %       ** Automatically adjust designs to account for data distortion 
    %          effects (allowing for informative cheaper, faster
    %          experiments)
    %   * Identify parameters that change with 
    %     genetic / environmental / experimental conditions

    properties
        % List of parameters and their values, default: {'k',10; 'g',0.2};
        parameters = {'k',10; 'g',0.2};     
        % List of species to be used in model, default: {'x1'};
        species = {'x1'};                   
        % Matrix of stoichiometric updates applied to each species given  
        % each reaction, with species as rows and reactions as columns 
        %   default: [1,-1];
        %   example: Model.stoichiometry = [-1,1,0,0;...
        %                                    1,-1,0,0;...
        %                                    0,0,1,-1]; 
        stoichiometry = [1,-1];  
        % List of propensity functions, default: {'k'; 'g*x1'}
        propensityFunctions = {'k'; 'g*x1'} 
        % List of time-varying input signals
        %   default: {}; 
        %   example:  Model.inputExpressions = ...
        %             {'Drug','(a0+a1*exp(-r1*t)*(1-exp(-r2*t))*(t>0))'};  
        inputExpressions = {}; 
        % Struct containing user-supplied constraint functions for FSP
        %   default: {};
        %   example: Model.customConstraintFuns = {'offGene+onGene'};
        customConstraintFuns = {};
        % Options for FSP solver
        %    defaults:
        %       'fspTol',0.001
        %       'fspIntegratorRelTol',1e-2
        %       'fspIntegratorAbsTol',1e-4
        %       'odeSolver','auto'
        %       'verbose',false
        %       'bounds',[]
        %       'usePiecewiseFSP',false
        %       'initApproxSS',false
        %       'escapeSinks',[]
        %       'constantJacobian',false
        %       'constantJacobianTime',1.1 
        fspOptions = struct('fspTol',0.001,'fspIntegratorRelTol',1e-2,...
            'fspIntegratorAbsTol',1e-4, 'odeSolver','auto',...
            'verbose',false,'bounds',[],'usePiecewiseFSP',false,...
            'initApproxSS',false,'escapeSinks',[],...
            'constantJacobian',false,'constantJacobianTime',1.1,'stateSpace',[]); 
        % Options for FSP-Sensitivity solver
        %   defaults:
        %       'solutionMethod','forward'
        %       'useParallel',true
        %   example: Model.sensOptions.solutionMethod = 'finiteDifference';
        sensOptions = struct('solutionMethod','forward',...
                             'useParallel',true);
        % Options for SSA solver
        %   defaults:
        %       'Nexp',1
        %       'nSimsPerExpt',100
        %       'useTimeVar',false
        %       'signalUpdateRate',[]
        %       'llel',false
        %       'verbose',false
        ssaOptions = struct('Nexp',1,'nSimsPerExpt',100,...
            'useTimeVar',false,'signalUpdateRate',[],...
            'useParallel',false,'verbose',false); 
        % Options for PDO
        %   defaults:
        %       'unobservedSpecies',[]
        %       'PDO',[]
        pdoOptions = struct('unobservedSpecies',[],'PDO',[]);
        % Options for FIM analyses
        %   defaults:
        %       'modelVarsToFit','all'
        %       'pdoVarsToFit',[]
        %       'timesToFit','all'
        %       'logPrior',[]
        %       'logPriorCovariance',[]
        %       'priorCovariance',[]
        fittingOptions = struct('modelVarsToFit','all',...
            'pdoVarsToFit',[],'timesToFit','all','logPrior',[],...
            'logPriorCovariance',[],'priorCovariance',[])
        % Initial population size of each species, default: [0];
        initialCondition = [0]; 
        % Probability mass of states given in initialCondition, default: 1
        initialProbs = 1; 
        % Initial time, default: 0;
        initialTime = 0;
        % Times at which to find solutions, default: linspace(0,10,21);
        tSpan = linspace(0,10,21); 
        % Chosen solution scheme ('FSP','SSA','ode'), default: 'FSP'
        solutionScheme = 'FSP' 
        % Chosen sets of solution schemes to get and store (choose members
        % from ('FSP','SSA','ode').  Default is empty.
        solutionSchemes = {};
        % Settings for model reduction tools
        %   defaults:
        %       'useModReduction',false
        %       'reductionType','None'
        modelReductionOptions = struct('useModReduction',false,...
                                        'reductionType','None') 
        % Set data, default: [];
        dataSet = [];
        % Option to use hybrid model (deterministic + stochastic species) 
        %   default: false
        useHybrid = false
        % Struct to define which species of the hybrid model will be
        % modelled using ODEs
        %   default: struct('upstreamODEs',[]);
        %   example: Model.hybridOptions.upstreamODEs = {'offGene','onGene'};
        hybridOptions = struct('upstreamODEs',[]);
        % Processed propensity functions for use in SSIt/FSP solvers, 
        % default: [];
        propensitiesGeneral = [];
        % Processed propensity functions for use in ODE solver, 
        % default: [];
        propensitiesGeneralODE = [];
    end

    properties (Dependent)
        fspConstraints % FSP Constraint Functions
        pars_container % Container for parameters
    end

    methods
        function [obj,MultiModelObj] = SSIT(modelFile,modelName,dataSettings,pipeline,pipelineArgs,saveName)
            %% SSIT - Create an instance of the SSIT class.
            %
            % The SSIT purpose is to allow users to specify and efficiently 
            % solve the chemical master equation for discrete stochastic 
            % models.
            %
            % SSIT models can be generated through several options
            % depending on content of input 'modelFile'.
            %
            %% Inputs:                      
            %%   modelFile (string, optional) -- Create from saved file or
            %      from specified template. 
            %      {'[NAME].mat',   % Load SSIT Model from file [NAME].mat 
            %       'BirthDeath',    % 1 species pre-formatted example (default)
            %       'CentralDogma',  % 2 species pre-formatted example
            %       'ToggleSwitch',  % 2 species pre-formatted example
            %       'Repressilator', % 3 species pre-formatted example
            %       'BurstingSpatialCentralDogma'}  % 4 species pre-formatted example
            %
            %%   modelName (string, optional) -- Name of model within
            %       modelFile. This is needed in cases where the modelFile 
            %       .mat contains multiple variables.
            %
            %%   dataSettings (Cell array, optional) -- Settings for loading data
            %       This is a cell array. For SSIT models, this will should
            %       be a {1x3} cell with the structure:
            %       dataSettings = {dataFileName,linkedSpecies,conditions}.
            %       See method 'SSIT.loadData' for interpretation of these
            %       inputs.
            %       For MultiModels, there should be one row of these
            %       variables for each of the sub-models.
            %
            %%   pipeline (string, optional) -- Name of an executable matlab
            %       function that will be run to analyse the created model.
            %       The arguments of the function are (Model, ARGS), where
            %       ARGS is a cell structure containing all remaining
            %       arguments expected by the function.
            %
            %%   pipelineArgs (Struct, optional) -- 
            %       Structure containing any optional arguments needed for
            %       the pipeline to run.
            %
            %%   saveName - (String, optional) -- name of file to save results 
            %       of pipeline.
            %
            %% Example Usage:
            %% Example 1 - Pre-formatted model for central dogma:
            %   Mod = SSIT('CentralDogma'); % Load preset model for
            %                               % transcription and translation
            %
            %% Example 2 - Load existing model 'ExampleSSITModel.mat':
            %   Mod = SSIT('preGeneratedModels/savedRepressilatorModel');
            %      % Load saved model.
            %
            %% Example 3 - Load Model and Add Data
            %   Mod = SSIT('BirthDeath',[],{'data/STL1.csv',{'mRNA','rna'}})
            %      % Load preset model 'CentralDogma' and associate the 
            %
            %% Example 4 - Load Model, Add Data and Run Pipeline Routine
            %   DataSettings = {'data/STL1.csv',{'mRNA','rna'}};
            %   Pipeline = 'fittingPipelineExample';
            %   pipelineArgs.maxIter = 20;
            %   pipelineArgs.display = 'iter';
            %   saveFile = 'exampleResults.mat';
            % 
            %   % Create model from preset, associate with data, run
            %   % 'fittingPipeline', and save result.
            %   SSIT('BirthDeath','Model',DataSettings,Pipeline,pipelineArgs,saveFile);
            %   
            %   % Load model from file, run 'fittingPipeline', and save result.
            %   SSIT(saveFile,'Model',[],Pipeline,pipelineArgs,saveFile);

            arguments
                modelFile = []   % Name of file where SSIT Model/MultiModel has been saved. Must be a '.mat'.
                modelName = []   % Name of the SSIT Model/MultiModel within the above file.
                dataSettings = {}% Data Settings to load into Model/MultiModel.
                pipeline = []    % Pipeline (matlab script) to run on model.
                pipelineArgs = []% Pipeline arguments (matlab structure).
                saveName = []    % File name to save model after it has been generated.
            end
            
            % SSIT Construct an instance of the SSIT class
            addpath(genpath('../src'));
            if ~isempty(modelFile)
                if length(modelFile)>4 && (strcmp(modelFile(end-3:end),'.mat')||exist([modelFile,'.mat'],"file"))
                    % Load existing model from .mat file.
                    try
                        if ~isempty(modelName)
                            TMP = load(modelFile,modelName);
                            if isa(TMP.(modelName),'SSIT')
                                obj = TMP.(modelName);
                                disp(['Successfully loaded SSIT Model ',modelName])
                            elseif isa(TMP.(modelName),'SSITMultiModel')
                                MultiModelObj = TMP.(modelName);
                                obj = MultiModelObj.SSITModels{1};
                                disp(['Successfully loaded a CombinedModel ',modelName, ' and extracted first model.'])
                            end
                        else
                            TMP = load(modelFile);
                            fnames = fieldnames(TMP);
                            for i=1:length(fnames)
                                if isa(TMP.(fnames{i}),'SSIT')
                                    obj = TMP.(fnames{i});
                                    disp(['Successfully loaded SSIT Model named "',fnames{i},'" from "',modelFile,'"'])
                                    modelName = fnames{i};
                                    break
                                elseif isa(TMP.(fnames(i)),'SSITMultiModel')
                                    MultiModelObj = TMP.(fnames{i});
                                    obj = MultiModelObj.SSITModels{1};
                                    disp(['Successfully loaded a CombinedModel  named "',fnames{i},'" and extracted first model.'])
                                    modelName = fnames{i};
                                    break
                                end
                            end
                        end
                    catch
                        disp(['Could not load model from ',modelFile])
                        disp('Check that file exists and that it contains only the SSIT model of interest')
                        disp('Use the optional argument "modelName" to specify which model to load.')
                    end

                    % Test to see if propensity functions are available. If
                    % not, create them.
                    if ~isempty(obj.propensitiesGeneral)
                        try
                            fieldsPropens2Test = {'timeDependentFactor','stateDependentFactor','jointDependentFactor','hybridFactor'};
                            for field = fieldsPropens2Test
                                if ~isempty(obj.propensitiesGeneral{1}.(field{1}))
                                    if ~isa(obj.propensitiesGeneral{1}.(field{1}),'function_handle')
                                        error('Missing Function')
                                    end
                                end
                                % 
                                %     if nargin(obj.propensitiesGeneral{1}.(field{1}))==1
                                %         obj.propensitiesGeneral{1}.(field{1})(0);
                                %     elseif nargin(obj.propensitiesGeneral{1}.(field{1}))==2
                                %         obj.propensitiesGeneral{1}.(field{1})(0,0);
                                %     end
                                % end
                            end
                        catch
                            disp(['Propensity functions are missing -- regenerating now with name: ',modelName])
                            obj = obj.formPropensitiesGeneral(modelName);
                        end
                    end
                else
                    % Create model from template
                    obj = pregenModel(obj,modelFile);
                    if ~strcmp(modelFile,'Empty')
                        obj = obj.formPropensitiesGeneral;
                    end
                end
            end

            % Load Data if provided
            if ~isempty(dataSettings)
                if size(dataSettings,2)<3
                    dataSettings{1,3} = {};
                end
                if exist('MultiModelObj','var')
                    nModels = length(MultiModelObj.SSITModels);
                    for iModel = 1:nModels
                        MultiModelObj.SSITModels{iModel} =  MultiModelObj.SSITModels{iModel}.loadData( ...
                            dataSettings{iModel,1},dataSettings{iModel,2},dataSettings{iModel,3});
                    end
                else
                    obj = obj.loadData(dataSettings{1,1},dataSettings{1,2},dataSettings{1,3});
                end

            end

            if ~isempty(pipeline)
                if strcmp(pipeline(end-1:end),'.m')
                    pipeline=pipeline(1:end-2);
                end
                fun = str2func(pipeline);
                if exist('MultiModelObj','var')
                    [outputs,MultiModelObj] = fun(MultiModelObj,pipelineArgs);
                    obj = MultiModelObj.SSITModels{1};
                else
                    [outputs,obj] = fun(obj,pipelineArgs);
                end
                disp(['Pipeline "',pipeline,'" run successfully.'])
            end

            if ~isempty(saveName)
                if exist('MultiModelObj','var')
                    if ~isempty(modelName)
                        eval([modelName,'=MultiModelObj;']);
                        save(saveName,"outputs",modelName)
                    else
                        save(saveName,"outputs",'MultiModelObj')
                    end
                    obj = MultiModelObj.SSITModels{1};
                else
                
                    if ~isempty(modelName)
                        eval([modelName,'=obj;']);
                        save(saveName,"outputs",modelName)
                    else
                        ModelObj = obj;
                        save(saveName,'outputs','ModelObj')
                    end
                end                

                % if exist("combinedModel","var")
                %     outputs = executeRoutine(ModelObj);                    
                %     ModelObj=outputs.model;
                % eval([modelName,'=outputs.model.SSITModels{1};']);
                % /save(saveName,"outputs",modelName,'ModelObj')
                % else
                %     outputs = executeRoutine(obj);
                % eval([modelName,'=ModelObj;']);
                % save(saveName,"outputs",modelName)
                % end
            end

        end

        function Pars_container = get.pars_container(obj)
            if ~isempty(obj.parameters)
                Pars_container = containers.Map(obj.parameters(:,1), obj.parameters(:,2));
            else
                Pars_container =[];
            end
        end

        function obj = formPropensitiesGeneral(obj,prefixName,computeSens)
            %% SSIT.formPropensitiesGeneral - Create callable functions 
            %% for all propensity functions.
            %
            % This function compiles and stores the given reaction   
            % propensities into symbolic expression functions that use  
            % sparse matrices to operate on the system based on the current 
            % state. The functions are stored with the given prefix, e.g., 
            % 'Model_1'
            %
            % Inputs:
            %    * obj - SELF
            %    * prefixName - (string) the prefix name used to name the
            %                   saved propensity functions
            %                   default: 'default'
            %    * computeSens - (logical) indicates whether derivatives 
            %                    are calculated for use in sensitivity
            %                    analysis
            %                    default: true
            %
            % Outputs: Model, callable symbolic expression functions
            %
            % Example: Model = Model.formPropensitiesGeneral('Model_1')
            arguments
                obj
                prefixName = 'default';
                computeSens = true;
            end
            % This function starts the process to write m-file for each
            % propensity function.
        
            n_reactions = length(obj.propensityFunctions);
            % Propensity for hybrid models will include
            % solutions from the upstream ODEs.
            sm = cell(1,n_reactions);
            logicTerms = cell(1,n_reactions);
            logCounter = 0;
            for i = 1:n_reactions
                st = obj.propensityFunctions{i};
                for jI = 1:size(obj.inputExpressions,1)
                    st = strrep(st,obj.inputExpressions{jI,1},['(',obj.inputExpressions{jI,2},')']);
                end
                [st,logicTerms{i},logCounter] = ssit.Propensity.stripLogicals(st,obj.species,logCounter);
                sm{i} = str2sym(st);
            end

            if ~strcmp(obj.solutionScheme,'ode')&&~ismember('ode',obj.solutionSchemes)
                if obj.useHybrid
                    PropensitiesGeneral = ...
                        ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                        obj.parameters, obj.species, obj.hybridOptions.upstreamODEs,...
                        logicTerms, prefixName, computeSens);
                else
                    PropensitiesGeneral = ...
                        ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                        obj.parameters, obj.species, [], logicTerms, prefixName, computeSens);
                end
            else
                PropensitiesGeneral = [];
            end
            
            objODE = obj;
            objODE.solutionScheme='ode';
            objODE.solutionSchemes = {};
            objODE.useHybrid = true;
            objODE.hybridOptions.upstreamODEs = obj.species;
            obj.propensitiesGeneralODE = ...
                ssit.Propensity.createAsHybridVec(sm, objODE.stoichiometry,...
                objODE.parameters, objODE.species, objODE.hybridOptions.upstreamODEs,...
                logicTerms, [prefixName,'_ODE'], computeSens);

            obj.propensitiesGeneral = PropensitiesGeneral;
        end
%%
        function constraints = get.fspConstraints(obj)
            % Makes a list of FSP constraints that can be used by the FSP
            % solver.
            if obj.useHybrid
                stochasticSpecies = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                stochasticSpecies = obj.species;
            end

            nSpecies = length(stochasticSpecies);
            Data = cell(nSpecies*2,3);
            for i = 1:nSpecies
                Data(i,:) = {['-x',num2str(i)],'<',0};
                Data(nSpecies+i,:) = {['x',num2str(i)],'<',1};
            end
            
            if ~isempty(obj.customConstraintFuns)
                [~,J] = sort(cellfun('length',stochasticSpecies),'descend');                
                for i = 1:length(obj.customConstraintFuns)
                    constraintStr = SSIT.replaceSpeciesNames(obj.customConstraintFuns{i},stochasticSpecies);
                    Data(2*nSpecies+i,:) = {constraintStr,'<',1};
                end
            end
            constraints.f = readConstraintsForAdaptiveFsp([], stochasticSpecies, Data);
            if isempty(obj.fspOptions.bounds)||size(Data,1)~=length(obj.fspOptions.bounds)
                constraints.b = [Data{:,3}]';
                obj.fspOptions.bounds = constraints.b;
            else
                constraints.b = obj.fspOptions.bounds;
            end

            if ~isempty(obj.fspOptions.escapeSinks)
                nEscape = length(obj.fspOptions.escapeSinks.f);
                escapeData = cell(nEscape,3);
                for i = 1:nEscape
                    constraintStr = SSIT.replaceSpeciesNames(obj.fspOptions.escapeSinks.f{i},obj.species);
                    escapeData(i,:) = {constraintStr,'<',1};
                end
                constraints.fEscape = readConstraintsForAdaptiveFsp([], stochasticSpecies, escapeData);
                constraints.bEscape = obj.fspOptions.escapeSinks.b;
            else
                constraints.fEscape = [];
                constraints.bEscape = [];
            end
        end

        %% Model Building Functions
        function [obj] = pregenModel(obj,modelFile)
            % pregenModel - creates a pregenerated model from a template:
            % Possible Templates include:
            %   Empty -- nothing
            %   BirthDeath -- one species 'x1' with birth rate 'k' and
            %       death rate 'g'
            %   CentralDogma -- Time varying 2-species model with:
            %       mRNA species 'x1' with birth rate 'kr*I(t)' and
            %       degradation rate 'gr'. Protein species 'x2' with
            %       translation rate 'kr' and degradation rate 'gp'.
            %   ToggleSwitch -- two proteins that prepress one another with
            %       non-linear functions.
            switch modelFile
                case 'Empty'
                    obj.parameters = {};
                    obj.species = {};
                    obj.stoichiometry = [];
                    obj.propensityFunctions = {};
                    obj.initialCondition = [];
                case 'BirthDeath'
                    obj.parameters = {'k',10;'g',0.2};
                    obj.species = {'mRNA'};
                    obj.stoichiometry = [1,-1];
                    obj.propensityFunctions = {'k';'g*mRNA'};
                    obj.initialCondition = [0];
                case 'CentralDogma'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1};
                    obj.species = {'rna';'protein'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*rna';'kp*rna';'gp*protein'};
                    obj.initialCondition = [0;0];
                case 'BurstingGene'
                    obj.parameters = {'kon',1;'koff',1;'kr',1;'gr',0.1};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kon*(1-geneState)';'koff*geneState';'kr*geneState';'gr*rna'};
                    obj.initialCondition = [0;0];
                case 'CentralDogmaTV'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1;'omega',2*pi/5};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*I1*geneState';'kp*geneState';'gp*rna'};
                    obj.initialCondition = [0;0];
                    obj.inputExpressions = {'I1','1+cos(omega*t)'};
                case 'ToggleSwitch'
                    obj.parameters = {'kb',10;'ka',80;'M',20;'g',1};
                    obj.species = {'LacI';'LamCI'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kb+ka*M^3/(M^3+LamCI^3)';...
                        'g*LacI';...
                        'kb+ka*M^3/(M^3+LacI^3)';...
                        'g*LamCI'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(LacI-3).^2.*(LamCI-3).^2'};
                case 'ToggleSwitch2'
                    obj.parameters = {'ka1',4;'kb1',80;'kd1',1;'k1',20;...
                        'ka2',4;'kb2',80;'kd2',1;'k2',20;...
                        'ket',0.1;'ks',1;'kg',1};
                    obj.species = {'x1';'x2'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'ket*(ka1+((kb1*(k1^3))/((k1^3)+(x2)^3)))';...
                        '(kd1+((ks*kg)/(1+ks)))*(x1)';...
                        'ket*(ka2+((kb2*(k2^3))/((k2^3)+(x1)^3)))';...
                        'kd2*(x2)'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2'};
                case 'Repressilator'
                    obj.parameters = {'kn0',0;'kn1',25;'a',5;'n',6;'g',1};
                    obj.species = {'x1';'x2';'x3'};
                    obj.stoichiometry = [1,0,0,-1,0,0;...
                        0,1,0,0,-1,0;...
                        0,0,1,0,0,-1];
                    obj.propensityFunctions = {'kn0+kn1*(1/(1+a*(x2^n)))';...
                        'kn0+kn1*(1/(1+a*(x3^n)))';...
                        'kn0+kn1*(1/(1+a*(x1^n)))';...
                        'g*x1';...
                        'g*x2';...
                        'g*x3'};
                    obj.initialCondition = [30;0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2*(x3-3).^2'};

                case 'RepressilatorGenes'
                    obj.parameters = {'kn0',0;'kn1',25;'kb',2000;'ku',10;'g',1};
                    obj.species = {'x1';'x2';'x3';'x4';'x5';'x6';'x7';'x8';'x9'};
                    obj.stoichiometry = zeros(9,12);
                    obj.stoichiometry(1,1:2) = [-1 1];
                    obj.stoichiometry(2,1:2) = [1 -1];
                    obj.stoichiometry(6,1:2) = [-3 3];
                    obj.stoichiometry(3,3) =  1;
                    obj.stoichiometry(3,4) = -1;
                    obj.propensityFunctions(1:4) = {'kb*x1*x6*(x6-1)/2*(x6-2)/6';'ku*x2';'kn0*x2+kn1*x1';'g*x3'};
                    obj.stoichiometry(4,5:6) = [-1 1];
                    obj.stoichiometry(5,5:6) = [1 -1];
                    obj.stoichiometry(9,5:6) = [-3 3];
                    obj.stoichiometry(6,7) =  1;
                    obj.stoichiometry(6,8) = -1;
                    obj.propensityFunctions(5:8) = {'kb*x4*x9*(x9-1)/2*(x9-2)/6';'ku*x5';'kn0*x5+kn1*x4';'g*x6'};
                    obj.stoichiometry(7,9:10) = [-1 1];
                    obj.stoichiometry(8,9:10) = [1 -1];
                    obj.stoichiometry(3,9:10) = [-3 3];
                    obj.stoichiometry(9,11) =  1;
                    obj.stoichiometry(9,12) = -1;
                    obj.propensityFunctions(9:12) = {'kb*x7*x3*(x3-1)/2*(x3-2)/6';'ku*x8';'kn0*x8+kn1*x7';'g*x9'};
                    obj.initialCondition = [1;0;30;0;1;0;0;1;0];
                    obj.customConstraintFuns = {'(x3-3).^3.*(x6-3).^3.*(x9-3).^3'};

                case 'BurstingSpatialCentralDogma'
                    obj.parameters = {'kon',1;'koff',2;...
                        'kr',5;'grn',0.1;'kt',0.5;...
                        'grc',0.1;...
                        'kp',1;'gp',0.1};
                    obj.species = {'x1';'x2';'x3';'x4'};
                    obj.stoichiometry = [1,-1,0,0,0,0,0,0;...
                        0,0,1,-1,-1,0,0,0;...
                        0,0,0,0,1,-1,0,0;...
                        0,0,0,0,0,0,1,-1];
                    obj.propensityFunctions = {'kon*(1-x1)';'koff*x1';...
                        'kr*x1';'grn*x2';'kt*x2';...
                        'grc*x3';...
                        'kp*x3';'gp*x4'};
                    obj.initialCondition = [0;0;0;0];
                    obj.customConstraintFuns = {};

            end
            obj.propensitiesGeneral = [];
        end

        function [obj] = createModelFromSBML(obj,sbmlFile,scaleVolume)
             arguments
                obj
                sbmlFile
                scaleVolume = false
            end
           % This function allows one to create a model directly from an
            % SBML file.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSBML('../SBML_test_cases/00010/00010-sbml-l1v2.xml');
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            sbmlobj = sbmlimport(sbmlFile);
            [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume);
            obj.propensitiesGeneral = [];

        end

        function [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume)
           % This function allows one to create a model directly from an
            % simBiology object.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSimBiol(sbmlobj);
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            arguments
                obj
                sbmlobj
                scaleVolume = false
            end
            nR = length(sbmlobj.Reactions);
            nS = length(sbmlobj.Species);

            % Extract species names and stoichiometry
            [obj.stoichiometry, obj.species] = getstoichmatrix(sbmlobj);

            % Extract parameter names
            nP = length(sbmlobj.Parameter);
            obj.parameters = {};
            for i = 1:nP
                obj.parameters{i,1} = sbmlobj.Parameter(i).Name;
                obj.parameters{i,2} = sbmlobj.Parameter(i).Value;
            end

            if length(sbmlobj.Compartments)>1
                error('SSIT Tools not yet set up to support multi-compartment models.')
            end

            obj.propensityFunctions={};
            for i = 1:nR
                reactRate = sbmlobj.Reactions(i).ReactionRate;
                reactRate = strrep(reactRate,'compartment*','');
                if contains(reactRate,'time')
                    obj.propensityFunctions{i,1} = strrep(reactRate,'time','Ig');
                    obj.inputExpressions = {'Ig','t'};
                else
                    obj.propensityFunctions{i,1} = reactRate;
                end

            end

            if scaleVolume
                % Replace species numbers (Xi) with concentrations (Xi/Volume).
                for i = 1:nR
                    for j = 1:nS
                        obj.propensityFunctions{i,1} = strrep(obj.propensityFunctions{i,1},...
                            obj.species{j},['(',obj.species{j},'/Volume)']);
                    end
                    obj.propensityFunctions{i,1} = [obj.propensityFunctions{i,1},'*Volume'];
                end

                % Scale Initial Condition and Volume to remove fractional
                % concentrations.
                frac = false;
                scl = 0;
                for i = 1:nS
                    if rem(sbmlobj.Species(i).Value,1)~=0
                        frac = true;
                    end
                    scl = max(scl,sbmlobj.Species(i).Value);
                end
                if frac
                    scl = round(100/scl);
                    disp(['Fractional species values detected.  Scaling by Vol=',num2str(scl),' and rounding.'])
                    disp(' ')
                    IC(1:nS,1) = round(scl*[sbmlobj.Species.Value]);
                end
                obj.parameters(end+1,:) = {'Volume',scl};
            else
                IC(1:nS,1) = [sbmlobj.Species.Value];
            end
            obj.initialCondition = IC;
            obj.summarizeModel;
            obj.propensitiesGeneral = [];

        end

        function exportToSBML(obj,modelName)
            % This function exports the model to an SBML file called
            % <modelName>.
            arguments
                obj
                modelName
            end
            sbModel = exportSimBiol(obj);
            sbmlexport(sbModel, modelName)
        end

        function sbModel = exportSimBiol(obj,verifyAndPlot)
            % This function converts the model to a simple simbiology model
            % and returns that simbiology object. 
            % Arguments:
            %   verifyAndPlot (true/false0) -- option to verify the model
            %       and run simBiology to make a plot of its results.
            %
            % Outputs:
            %   smModel -- the resulting simBiology model.
            arguments
                obj
                verifyAndPlot = false;
            end

            sbModel = sbiomodel('simpleModel');

            s = cell(1,length(obj.species));        
            for is = 1:size(obj.stoichiometry,1)
                s{is} = addspecies(sbModel,obj.species{is},obj.initialCondition(is));
            end

            for is = 1:size(obj.parameters,1)
                p{is} = addparameter(sbModel,obj.parameters{is,1},obj.parameters{is,2});
            end

            % Parse time varying components in the reaction rate equations. 
            props = obj.propensityFunctions;
            for is = 1:size(obj.inputExpressions,1)
                tvComp = strrep(obj.inputExpressions{is,2},'t','time');
                for ir = 1:length(props)
                    props{ir} = strrep(props{ir},obj.inputExpressions{is,1},['(',tvComp,')']);
                end
            end
           
            for ir=1:size(obj.stoichiometry,2)
                strReactants = [];
                strProducts =  [];
                for is = 1:size(obj.stoichiometry,1)
                    if obj.stoichiometry(is,ir)<0
                        strReactants =[strReactants,'+ ',[num2str(-obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    elseif obj.stoichiometry(is,ir)>0
                        strProducts =[strProducts,'+ ',[num2str(obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    end
                end
                if isempty(strProducts); strProducts = '  null '; end
                if isempty(strReactants); strReactants = '  null '; end
                rxn = [strReactants(3:end),' -> ',strProducts(3:end)];
                RXN{is} = addreaction(sbModel,rxn,'ReactionRate',props{ir});
            end

            if verifyAndPlot
                verify(sbModel)
                csObj = getconfigset(sbModel,'active');
                set(csObj,'Stoptime',max(obj.tSpan));
                [t,x,names] = sbiosimulate(sbModel);
                plot(t,x);
                xlabel('Time');
                ylabel('Amount');
                legend(names);
            end
        end

        function [obj] = addSpecies(obj,newSpecies,initialCond)
            % addSpecies - add new species to reaction model.
            % example:
            %     F = SSIT;
            %     F = F.addSpecies('x2');
            arguments
                obj
                newSpecies
                initialCond = [];
            end
            obj.species =  [obj.species;newSpecies];
            obj.stoichiometry(end+1,:) = 0;
            if isempty(initialCond)
                initialCond = zeros(size(newSpecies,1),1);
            end
            obj.initialCondition = [obj.initialCondition;initialCond];
            obj.propensitiesGeneral = [];

        end

        function [obj] = addParameter(obj,newParameters)
            % addParameter - add new parameter to reaction model
            % example:
            %     F = SSIT;
            %     F = F.addParameter({'kr',0.1})
            obj.parameters =  [obj.parameters;newParameters];
        end

        function [obj] = addReaction(obj,newRxn,confirm)
            arguments
                obj
                newRxn
                confirm = false
            end

            % addParameter - add new reaction to reaction model
            % example:
            % F = SSIT('Empty')
            % newRxn(1).propensity = 'kr + kr1*x1';
            % newRxn(1).stoichiometry = {'x1',1};
            % newRxn(1).parameters = {'kr',2;'kr1',0.01};
            % newRxn(2).propensity = 'g*x1';
            % newRxn(2).stoichiometry = {'x1',-1};
            % newRxn(2).parameters = {'g',0.1};
            % F = F.addReaction(newRxn);
            for iRxn = 1:length(newRxn)
                obj.propensityFunctions =  [obj.propensityFunctions;newRxn(iRxn).propensity];
                rxnNum = size(obj.stoichiometry,2)+1;
                for iSpe = 1:size(newRxn(iRxn).stoichiometry,1)
                    specName = newRxn(iRxn).stoichiometry{iSpe,1};
                    specChange = newRxn(iRxn).stoichiometry{iSpe,2};
                    specNum = find(strcmp(obj.species,specName));
                    if isempty(specNum)
                        disp(['Adding species ',specName,' with initial condition 0.'])
                        obj = obj.addSpecies(specName,0);
                        specNum = length(obj.species);
                    end
                    obj.stoichiometry(specNum,rxnNum) = specChange;
                end
                for iPar = 1:size(newRxn(iRxn).parameters,1)
                    parName = newRxn(iRxn).parameters{iPar,1};
                    parValue = newRxn(iRxn).parameters{iPar,2};
                    if ~isempty(obj.parameters)
                        parNum = find(strcmp(obj.parameters(:,1),parName));
                    else
                        parNum=[];
                    end
                    if isempty(parNum)
                        disp(['Adding parameter ',parName,' with value ',num2str(parValue)]);
                        obj = obj.addParameter({parName,parValue});
                    else
                        disp(['Updating parameter ',parName,' to new value ',num2str(parValue)]);
                        obj.parameters{parNum,2} = parValue;
                    end
                end
            end
            obj.propensitiesGeneral = [];
        end

        function [obj] = calibratePDO(obj,dataFileName,measuredSpecies,...
                     trueColumns,measuredColumns,pdoType,showPlot,parGuess)
            %% SSIT.calibratePDO - This function calibrates a probabilistic 
            %% distortion operator (PDO) to match 'true' and 'observed' 
            %% (distorted) spot numbers.  Note: it also calls generatePDO()
            %
            % Calibrate the PDO from empirical data, for example, the 
            % number of spots that have been measured using different 
            % assays in data columns 'nTotal' for the 'true' data set and 
            % in the columns 'nSpots0' for a different label, or in columns
            % 'intens1' for the integrated fluorescent intensity.  
            % 
            % Inputs:
            %   * obj
            %   * dataFileName - (string), name of the data file
            %   * measuredSpecies - (string), name of the model species
            %   * trueColumns - (string), name of the 'true' data for the
            %                    model species
            %   * measuredColumns - (string), name of the 'observed', or
            %                        distorted, data for the model species
            %   * pdoType - (string), the type of distribution that  
            %                represents the type 
            %       default: 'AffinePoiss'
            %   * showPlot - (logical), default: false
            %   * parGuess - (double), guesses for the hyperparameter 
            %                 values, i.e., the parameters that define the  
            %                 PDO distribution (not to be confused with the 
            %                 model parameters)
            %       default: [];
            %
            % Outputs: 
            %
            % Example: 
            % Model_PDO = Model.calibratePDO('/data/pdoData.csv',...
            % {'rna'},{'nTotal'},{'nSpots0'},'AffinePoiss',true);
            %
            % The 'AffinePoiss' PDO models the obervation probability with 
            % a Poisson distribution, where the mean value is affine 
            % linearly related to the true value: P(y|x) = Poiss(a0 + a1*x);
            arguments
                obj
                dataFileName
                measuredSpecies
                trueColumns
                measuredColumns
                pdoType = 'AffinePoiss'
                showPlot = false
                parGuess=[];
            end

            obj.pdoOptions.type = pdoType;
            % app.DistortionTypeDropDown.Value = obj.pdoOptions.type;
            % app.FIMTabOutputs.PDOProperties.props = obj.pdoOptions.props;

            Tab = readtable(dataFileName);
            
            % Convert float values in trueColumns and measuredColumns
            Tab.(trueColumns{1}) = double(int64(Tab.(trueColumns{1})));
            Tab.(measuredColumns{1}) = double(int64(Tab.(measuredColumns{1})));

            dataNames = Tab.Properties.VariableNames;

            % Check that the data column being asked for actually exists in the file and throw an error if not.
            % TODO - make this type of check accessible to all of SSIT, not just calibratePDO
            present = any(cellfun(@(y) strcmp(y, measuredColumns{1}),dataNames));
            if ~present
                error(measuredColumns + " does not exist in the data file.");
            end

            DATA = table2cell(Tab);

            if isempty(parGuess)
                lambdaTemplate = obj.findPdoError(pdoType);
            else
                lambdaTemplate=parGuess;
            end

            lambda = [];

            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end
            
            maxSize = zeros(1,length(speciesStochastic));
            options = optimset('display','none');
            for i=1:length(speciesStochastic)
                if sum(strcmp(measuredSpecies,speciesStochastic{i}))==1
                    k = find(strcmp(measuredSpecies,speciesStochastic{i}));
                    jTrue = find(strcmp(dataNames,trueColumns{k}));
                    jObsv = find(strcmp(dataNames,measuredColumns{k}));
                    xTrue = [DATA{:,jTrue}]';
                    xObsv = [DATA{:,jObsv}]';
                    maxSize(i)=max(xTrue);
                    objPDO = @(x)-obj.findPdoError(pdoType,x,xTrue,xObsv);
                    lambdaNew = fminsearch(objPDO,lambdaTemplate,options);
                    if showPlot
                        [~,PDO] = obj.findPdoError(pdoType,lambdaNew,xTrue,xObsv);
                        Z = max(-25,log10(PDO));
                        fg = figure; set(0,'CurrentFigure',fg);
                        contourf([0:size(PDO,2)-1],[0:size(PDO,1)-1],Z);
                        colorbar
                        hold on
                        scatter(xTrue,xObsv,100,'sk','filled')
                        set(gca,'fontsize',15)
                        legend('PDO','Data')
                    end
                else
                    maxSize(i)=0;
                    lambdaNew = 0*lambdaTemplate;
                end
                lambda = [lambda,lambdaNew];
            end
            obj.pdoOptions.props.PDOpars = lambda;
            obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,lambda,[],[],maxSize);
        end

        function obj = setICfromFspVector(obj,stateSpace,fspVector)
            % This function converts an FSP vector to initial states 
            % and initial probabilities.
            nSpecies = length(obj.species);
            nStates = size(fspVector.p.data.subs,1);
            if obj.useHybrid
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
                nUpstream = length(obj.hybridOptions.upstreamODEs);
                upStreamInit = [fspVector.upstreamODEs,zeros(nUpstream,nStates-1)];
            elseif ~isempty(fspVector.upstreamODEs)
                upStreamInit = repmat(fspVector.upstreamODEs,1,nStates);                
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
            else
                upStreamInit = [];
                jStochastic = [1:nSpecies];
                jUpstreamODE = [];
            end
            
            obj.initialCondition = zeros(nSpecies,nStates);
            obj.initialCondition(jStochastic,:) = fspVector.p.data.subs'-1;
            obj.initialCondition(jUpstreamODE,:) = upStreamInit;
            obj.initialProbs = zeros(nStates,1);         
            obj.initialProbs = max(0,real(fspVector.p.data.vals));
            
        end
        
        function [pdo] = generatePDO(obj,pdoOptions,paramsPDO,fspSoln,variablePDO,maxSize)
            %% SSIT.generatePDO - This function generates the Probabilistic 
            %% Distortion Operator (PDO) according to user choice.
            % 
            % Inputs:
            %   * app
            %   * paramsPDO - ()
            %   * FSPoutputs - ()
            %   * indsObserved - ()
            %   * variablePDO - (logical), default: false
            %   * maxSize - ()
            %
            % Output: 
            %
            % Example: 
            arguments
                obj
                pdoOptions
                paramsPDO = []
                fspSoln = []
                variablePDO =[]
                maxSize=[];
            end
            app.DistortionTypeDropDown.Value = pdoOptions.type;
            app.FIMTabOutputs.PDOProperties.props = pdoOptions.props;
            
            % Separate into observed and unobserved species.
            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end
            Nd = length(speciesStochastic);
                  
            indsUnobserved=[];
            indsObserved=[];
            for i=1:Nd
                if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                    indsUnobserved=[indsUnobserved,i];
                else
                    indsObserved=[indsObserved,i];
                end
            end
            [~,pdo] = ssit.pdo.generatePDO(app,paramsPDO,fspSoln,indsObserved,variablePDO,maxSize);
        end

        function [logL,P] = findPdoError(obj,pdoType,lambda,True,Distorted)
            % This function calculates the likelihood of observed data
            % given true data and an assumed PDO model.
            arguments
                obj
                pdoType = 'AffinePoiss';
                lambda = [];
                True = [];
                Distorted =[];
            end

            if nargin<=2
                switch pdoType
                    case 'LinPoiss'
                        logL = [0.1, 1];
                    case 'AffinePoiss'
                        logL = [1 5 0.5];
                    case 'QuadPoiss'
                        logL = [1 5 0.5];
                end
                return
            end

            % Computes likelihood of observed data given the model of affine poisson
            % extra spot counting and probability of measurmeent failure.
            NmaxTrue = max(True);
            NmaxObs = max(Distorted);

            switch pdoType
                case 'LinPoiss'
                    Np = ceil(max(NmaxObs,lambda(1)+lambda(2)*NmaxTrue));
                case 'AffinePoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue));
                case 'QuadPoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue+lambda(4)*NmaxTrue^2));
            end
            P = zeros(Np+1,NmaxTrue+1);

            for xi = 0:NmaxTrue
                switch pdoType
                    case 'LinPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)*xi));
                    case 'AffinePoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi));
                    case 'QuadPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi+lambda(4)*xi^2));
                end
            end

            % compute likelihood of observed given true
            logP = max(log(P),-100);
            logL = 0;
            for i = 1:length(True)
                logL = logL + logP(Distorted(i)+1,True(i)+1);
            end

            % apply constraints
            switch pdoType
                case 'LinPoiss'
                    logL = logL-1e4*(lambda(1)<0);
                case 'AffinePoiss'
                    logL = logL-1e4*(lambda(1)<0);
            end
        end

        function summarizeModel(obj)
            %% SSIT.summarizeModel - Prints a summary of an SSIT model: 
            %% Species, Reactions (with Stoichiometric updates), 
            %% Model Parameters
            %
            % Input:  SSIT model
            %
            % Output:  Summary text to screen
            %
            % Example:  Model.summarizeModel
            arguments
                obj;
            end
            % Show the model species
            nS = size(obj.stoichiometry,1);
            disp('Species:')
            for i = 1:nS
                if ~isempty(obj.hybridOptions.upstreamODEs)&&max(contains(obj.hybridOptions.upstreamODEs,obj.species{i}))
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  upstream ODE']);
                else
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  discrete stochastic']);
                end
            end
            disp(' ')

            % Show the model stoichiometries and propensity functions
            disp('Reactions:')
            nR = size(obj.stoichiometry,2);
            for iR = 1:nR
                s = obj.stoichiometry(:,iR);
                disp(['  Reaction ',num2str(iR),':'])
                jReactant = find(s<0);
                jProd = find(s>0);
                if isempty(jReactant)
                    reactTxt = 'NULL';
                else
                    reactTxt = [num2str(-s(jReactant(1))),'*',obj.species{jReactant(1)}];
                    for i = 2:length(jReactant)
                        reactTxt = [reactTxt,' + ',num2str(-s(jReactant(i))),'*',obj.species{jReactant(i)}];
                    end
                end
                if isempty(jProd)
                    prodTxt = 'NULL';
                else
                    prodTxt = [num2str(s(jProd(1))),'*',obj.species{jProd(1)}];
                    for i = 2:length(jProd)
                        prodTxt = [prodTxt,' + ',num2str(s(jProd(i))),'*',obj.species{jProd(i)}];
                    end
                end
                disp(['     s',num2str(iR),': ',reactTxt, ' --> ', prodTxt])

                disp(['     w',num2str(iR),': ',obj.propensityFunctions{iR}])

            end

            if ~isempty(obj.inputExpressions)
                disp(' ')
                disp('Input Signals:')
                nI = size(obj.inputExpressions,1);
                for i = 1:nI
                    disp(['     ',obj.inputExpressions{i,1},'(t) = ',obj.inputExpressions{i,2}])
                end
            end

            disp(' ')
            disp('Model Parameters:')
            disp(obj.parameters)

        end

        %% Model Analysis Functions
        function obj = fspSolve(obj)
            obj.solutionScheme='FSP';
            [~,~,obj] = obj.solve;
        end
        function [Solution, bConstraints, obj] = solve(obj,stateSpace,saveFile,fspSoln)
            arguments
                obj
                stateSpace = [];
                saveFile=[];
                fspSoln=[];
            end
            % Solve the model using the specified method in
            %    obj.solutionScheme (default: 'FSP')
            % Inputs:
            %   obj
            %   stateSpace = [];
            %   saveFile = [];
            %   fspSoln = [];
            % Example:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [soln,bounds] = F.solve;  % Returns the solution and the
            %                             % bounds for the FSP projection
            %   F.solutionScheme = 'fspSens'
            %   [soln,bounds] = F.solve;  % Returns the sensitivity and the
            %                             % bounds for the FSP projection
            % See also: SSIT.makePlot for information on how to visualize
            % the solution data.
            if obj.initialTime>obj.tSpan(1)
                error('First time in tspan cannot be earlier than the initial time.')
            elseif obj.initialTime~=obj.tSpan(1)
                %                 warning('First time in tspan is not the same as initial time.')
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);
            end

            if isempty(stateSpace)&&~isempty(obj.fspOptions.stateSpace)
                stateSpace = obj.fspOptions.stateSpace;
            end 

            if strcmp(obj.solutionScheme,'ode')
                propensityGeneral = obj.propensitiesGeneralODE;
            else
                propensityGeneral = obj.propensitiesGeneral;
            end
            if ~isempty(obj.hybridOptions)&&~strcmp(obj.solutionScheme,'ode')&&length(obj.hybridOptions.upstreamODEs)~=length(propensityGeneral{1}.ODEstoichVector)
                disp('(Re)Forming Propensity Functions Due to Detected Change in Hybrid Model Dimension.')
                obj = formPropensitiesGeneral(obj,'hybrid',true);
            elseif isempty(propensityGeneral)
                disp('Forming Propensity Functions.')
                obj = formPropensitiesGeneral(obj);
            end

            if obj.modelReductionOptions.useModReduction
                if ~isfield(obj.modelReductionOptions,'phi')
                    error('Model Reduction Matrices have not yet been Defined.')
                end
                useReducedModel = true;
                modRedTransformMatrices.phi = obj.modelReductionOptions.phi;
                modRedTransformMatrices.phi_inv = obj.modelReductionOptions.phi_inv;
                modRedTransformMatrices.phiScale = obj.modelReductionOptions.phiScale;
                modRedTransformMatrices.phiPlot = obj.modelReductionOptions.phiPlot;
            else
                useReducedModel = false;
                modRedTransformMatrices = [];
            end

            switch obj.solutionScheme
                case 'FSP'
                    if ~isempty(stateSpace)&&size(stateSpace.states,2)~=stateSpace.state2indMap.Count
                        error('Mismatch in statespace definition.')
                    end

                    % specificPropensities = SSIT.parameterizePropensities(obj.propensitiesGeneral,[obj.parameters{:,2}]');

                    [Solution.fsp, bConstraints,Solution.stateSpace] = ssit.fsp.adaptiveFspSolve(obj.tSpan,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.propensitiesGeneral, ...
                        [obj.parameters{:,2}]', ...
                        obj.fspOptions.fspTol, ...
                        obj.fspConstraints.f, ...
                        obj.fspConstraints.b,...
                        obj.fspOptions.verbose, ...
                        obj.fspOptions.fspIntegratorRelTol, ...
                        obj.fspOptions.fspIntegratorAbsTol, ...
                        obj.fspOptions.odeSolver, ...
                        stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape, ...
                        obj.fspOptions.constantJacobian,...
                        obj.fspOptions.constantJacobianTime);
                    obj.fspOptions.stateSpace = Solution.stateSpace;
                    obj.fspOptions.bounds = bConstraints;

                case 'SSA'
                    Solution.T_array = obj.tSpan;
                    Nt = length(Solution.T_array);
                    nSims = obj.ssaOptions.Nexp*obj.ssaOptions.nSimsPerExpt*Nt;
                    W = obj.propensitiesGeneral;
                    if obj.ssaOptions.useParallel
                        trajs = zeros(length(obj.species),...
                            length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                        parfor isim = 1:nSims
                            trajs(:,:,isim) = ssit.ssa.runSingleSsa(obj.initialCondition,...
                                obj.stoichiometry,...
                                W,...
                                obj.tSpan,...
                                obj.ssaOptions.useTimeVar,...
                                obj.ssaOptions.signalUpdateRate,...
                                [obj.parameters{:,2}]');
                            if obj.ssaOptions.verbose
                                disp(['completed sim number: ',num2str(isim)])
                            end
                        end
                        Solution.trajs = trajs;
                    else
                        Solution.trajs = zeros(length(obj.species),...
                            length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                        for isim = 1:nSims
                            Solution.trajs(:,:,isim) = ssit.ssa.runSingleSsa(obj.initialCondition,...
                                obj.stoichiometry,...
                                W,...
                                obj.tSpan,...
                                obj.ssaOptions.useTimeVar,...
                                obj.ssaOptions.signalUpdateRate,...
                                [obj.parameters{:,2}]');
                            if obj.ssaOptions.verbose
                                disp(['completed sim number: ',num2str(isim)])
                            end
                        end
                    end
                    disp([num2str(nSims),' SSA Runs Completed'])
                    try
                        if ~isempty(obj.pdoOptions.PDO)
                            Solution.trajsDistorted = zeros(length(obj.species),...
                                length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                            for iS = 1:length(obj.species)
                                PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                                nDpossible = size(PDO,1);
                                Q = Solution.trajs(iS,:,:);
                                for iD = 1:length(Q(:))
                                    Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                                end
                                Solution.trajsDistorted(iS,:,:) = Q;
                            end
                            disp('PDO applied to SSA results')
                        end
                        if ~isempty(saveFile)
                            A = table;
                            for j=1:Nt
                                A.time((j-1)*obj.ssaOptions.nSimsPerExpt+1:j*obj.ssaOptions.nSimsPerExpt) = obj.tSpan(j);
                                for i = 1:obj.ssaOptions.Nexp
                                    for k=1:obj.ssaOptions.nSimsPerExpt
                                        for s = 1:size(Solution.trajs,1)
                                            warning('off')
                                            A.(['exp',num2str(i),'_s',num2str(s)])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                                Solution.trajs(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                            if ~isempty(obj.pdoOptions.PDO)
                                                A.(['exp',num2str(i),'_s',num2str(s),'_Distorted'])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                                    Solution.trajsDistorted(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                            end
                                        end
                                    end
                                end
                            end
                            writetable(A,saveFile)
                            disp(['SSA Results saved to ',saveFile])
                        end
                    catch
                        pause;
                    end
                case 'fspSens'
                    if strcmp(obj.sensOptions.solutionMethod,'forward')&&isempty(obj.propensitiesGeneral{1}.sensTimeFactorVec)
                        obj = formPropensitiesGeneral(obj,'Sensitivities',true);
                    end
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = obj.species;

                    [Solution.sens, bConstraints] = ...
                        ssit.sensitivity.computeSensitivity(...
                        obj.parameters,...
                        obj.propensitiesGeneral,...
                        obj.tSpan,...
                        obj.fspOptions.fspTol,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.fspConstraints.f,...
                        obj.fspConstraints.b,...
                        [], obj.fspOptions.verbose, 0,...
                        obj.sensOptions.solutionMethod,...
                        app,stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...                        
                        obj.sensOptions.useParallel,...
                        fspSoln,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape,...
                        obj.fspOptions.constantJacobian,obj.fspOptions.constantJacobianTime);
                    %                     app.SensFspTabOutputs.solutions = Solution.sens;
                    %                     app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    %                     Solution.plotable = exportSensResults(app);

                case 'ode'
                    [~,Solution.ode] = ssit.moments.solveOde2(obj.initialCondition, obj.tSpan, ...
                        obj.stoichiometry, obj.propensitiesGeneralODE,  [obj.parameters{:,2}]', obj.fspOptions.initApproxSS);
            end
        end

        function A = sampleDataFromFSP(obj,fspSoln,saveFile)
            % Function to create simulated single-cell snapshot data by
            % sampling from the FSP solution.  
            % Arguments:
            %       fspSoln -- solution of current model using FSP.
            %       saveFile -- filename (.csv) to save data.
            Solution.T_array = obj.tSpan;
            Nt = length(Solution.T_array);
            nSims = obj.ssaOptions.nSimsPerExpt*obj.ssaOptions.Nexp;
            Solution.trajs = zeros(length(obj.species),...
                length(obj.tSpan),nSims);% Creates an empty Trajectories matrix
            % from the size of the time array and number of simulations
            for it = 1:length(obj.tSpan)
                clear PP
                PP = double(fspSoln.fsp{it}.p.data);
                clear w
                w(:) = PP(:); w(w<0)=0;
                % TODO - there has to be another way of doing this.
                [I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11] =  ind2sub(size(PP),randsample(length(w), nSims, true, w ));
                for iSp = 1:length(obj.species)
                    eval(['Solution.trajs(iSp,it,:) = I',num2str(iSp),'-1;']);
                end
            end
            if ~isempty(obj.pdoOptions.PDO)
                Solution.trajsDistorted = zeros(length(obj.species),...
                    length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                for iS = 1:length(obj.species)
                    PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                    nDpossible = size(PDO,1);
                    Q = Solution.trajs(iS,:,:);
                    for iD = 1:length(Q(:))
                        Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                    end
                    Solution.trajsDistorted(iS,:,:) = Q;
                end
                disp('PDO applied to FSP Samples')
            end
            if ~isempty(saveFile)
                A = table;
                for it=1:Nt
                    A.time((it-1)*obj.ssaOptions.nSimsPerExpt+1:it*obj.ssaOptions.nSimsPerExpt) = obj.tSpan(it);
                    for ie = 1:obj.ssaOptions.Nexp
                        for s = 1:size(Solution.trajs,1)
                            warning('off')
                            A.(['exp',num2str(ie),'_s',num2str(s)])((it-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt)) = ...
                                Solution.trajs(s,it,(ie-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt));
                            if ~isempty(obj.pdoOptions.PDO)
                                A.(['exp',num2str(ie),'_s',num2str(s),'_Distorted'])((it-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt)) = ...
                                    Solution.trajsDistorted(s,it,(ie-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt));
                            end
                        end
                    end
                end
                writetable(A,saveFile)
                disp(['FSP Samples saved to ',saveFile])
            end
        end

        function [fimResults,sensSoln] = computeFIM(obj,sensSoln,scale,MHSamples)
            %% computeFIM - Computes the Fisher Information Matrix (FIM) 
            %%              at all time points.
            % Inputs:
            %   * sensSoln (optional) - previously computed FSP 
            %                           sensitivity, automatically 
            %                           computed by computeFIM if not 
            %                           provided
            %   * scale - choice of FIM based on linear parameters or 
            %             their natural logarithm ('lin' or 'log'),
            %             default: 'lin'
            %   * MHSamples (optional) - set of parameter sets at which 
            %                            to calculate the FIM
            %           
            % Outputs:
            %   * fimResults - FIM at each time point in obj.tSpan
            %   * sensSoln - FSP sensitivity solutions
            arguments
                obj
                sensSoln = [];
                scale = 'lin';
                MHSamples = [];
            end

            if ~isempty(MHSamples)
                % For FIM calculation 
                nSamples = size(MHSamples,1);
                Nt = length(obj.tSpan);
                fimResults = cell(Nt,nSamples);
                if isempty(sensSoln)||length(sensSoln)~=nSamples
                    sensSoln = cell(1,nSamples);
                end
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    obj.fittingOptions.modelVarsToFit = 1:size(obj.parameters,1);
                end
                if nargout == 2
                    saveSens = true;
                else
                    saveSens = false;
                end

                for i=1:nSamples
                    objTMP = obj;
                    objTMP.parameters(objTMP.fittingOptions.modelVarsToFit,2) = ...
                        num2cell(MHSamples(i,:));
                    if saveSens
                        [fimResults(:,i),sensSoln{i}] = computeFIM(obj,sensSoln{i},scale);
                    else
                        fimResults(:,i) = objTMP.computeFIM(sensSoln{i},scale);
                    end
                end
            else

                if isempty(sensSoln)
                    % disp({'Running Sensitivity Calculation';'You can skip this step by providing sensSoln.'})
                    obj.solutionScheme = 'fspSens';
                    [sensSoln] = obj.solve;
                    sensSoln = sensSoln.sens;
                end

                % Separate into observed and unobserved species.
                if isfield(obj.hybridOptions,'upstreamODEs')
                    speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                else
                    speciesStochastic = obj.species;
                end
                Nd = length(speciesStochastic);
                indsUnobserved=[];
                indsObserved=[];
                for i=1:Nd
                    if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                        indsUnobserved=[indsUnobserved,i];
                    else
                        indsObserved=[indsObserved,i];
                    end
                end

                % compute FIM for each time point
                fimResults = {};
                for it=length(sensSoln.data):-1:1
                    if isempty(indsUnobserved)
                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p, sensSoln.data{it}.S, obj.pdoOptions.PDO);
                    else
                        % Remove unobservable species.
                        redS = sensSoln.data{it}.S;
                        for ir = 1:length(redS)
                            redS(ir) = sensSoln.data{it}.S(ir).sumOver(indsUnobserved);
                        end

                        % Truncate to remove PDOs for unobserved species.
                        PDO = obj.pdoOptions.PDO;
                        if ~isempty(PDO)&&(length(PDO.conditionalPmfs)>length(obj.species)-length(indsUnobserved))
                            if length(PDO.conditionalPmfs)==length(obj.species)
                                PDO.conditionalPmfs = PDO.conditionalPmfs(indsObserved);
                                if ~isempty(PDO.dCdLam)
                                    PDO.dCdLam = PDO.dCdLam(indsObserved,indsObserved);
                                end
                            else
                                error('Not clear how to specify PDO for observed species')
                            end
                        end

                        % Update conditionalPmfs input size for calibrated PDO
                        if ~isempty(PDO)
                            if size(PDO.conditionalPmfs{1},2) <= size(redS(1).data)
                                max_xTrue = size(PDO.conditionalPmfs{1},2);
                                PDO_input = size(redS(1).data);                            
                                if PDO_input > max_xTrue
                                % Padding
                                    disp("Padding conditionalPmfs input to increase size for PDO: " + max_xTrue + " to " + PDO_input)
                                    padding = zeros(size(PDO.conditionalPmfs{1}, 1), PDO_input - max_xTrue);
                                    PDO.conditionalPmfs{1} = [PDO.conditionalPmfs{1}, padding];
                                elseif PDO_input < max_xTrue
                                % Cropping 
                                    disp("Warning! Cropping conditionalPmfs input size ? " + max_xTrue + " to " + PDO_input)
                                    PDO.conditionalPmfs{1} = PDO.conditionalPmfs{1}(:, 1:PDO_input);
                                end
                            end
                        end

                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p.sumOver(indsUnobserved), redS, PDO);
                    end
                    fimResults{it,1} = F;
                end

                % TODO -- We need to add capability for the PDO parameters
                % to be included in the FIM calculation in log space.
                % Right now, the following will give an error because the
                % dimensions will not match when PDO parameters are
                % included.  Also, the current code does not allow for some
                % PDO parameters to be free while others are fixed.

                if strcmp(scale,'log')
                    for it=length(sensSoln.data):-1:1
                        fimResults{it,1} = diag([obj.parameters{:,2}])*...
                            fimResults{it,1}*...
                            diag([obj.parameters{:,2}]);
                    end
                end

            end
        end

        function [fimTotal,mleCovEstimate,fimMetrics] = evaluateExperiment(obj,...
                fimResults,cellCounts,priorCoVariance)
            % This function evaluates the provided experiment design (in
            % "cellCounts" and produces an array of FIMs (one for each
            % parameter set.
            arguments
                obj
                fimResults
                cellCounts
                priorCoVariance = []
            end

            Ns = size(fimResults,2);
            Nt = size(fimResults,1);
            Np = size(fimResults{1,1},1);
            fimTotal = cell(1,Ns);
            mleCovEstimate = cell(1,Ns);

            % Add the prior covariance into the FIM calculation if
            % provided. The prior covariance should be in the same scale as
            % the parameters (e.g.m linear, log, or log10).
            if isempty(priorCoVariance)
                PriorFIM = zeros(Np);
            else
                PriorFIM = inv(priorCoVariance);
            end

            for is=1:Ns
                fimTotal{is} = PriorFIM; %0*fimResults{1,is};

                for it=1:Nt
                    fimTotal{is} = fimTotal{is} + cellCounts(it)*fimResults{it,is};
                end

                if nargout>=2
                    % Estimate MLE covariance
                    if rank(fimTotal{is})<Np
                        disp(['FIM has rank ',num2str(rank(fimTotal{is})),' and is not invertable for this experiment design'])
                        mleCovEstimate{1,is} = NaN*ones(Np);
                    else
                        mleCovEstimate{1,is} = fimTotal{is}^-1;
                    end
                end
            end

            if nargout>=3
                for is = Ns:-1:1
                    % Compute FIM metrics.
                    fimMetrics.det(1,is) = det(fimTotal{is});
                    fimMetrics.trace(1,is) = trace(fimTotal{is});
                    fimMetrics.minEigVal(1,is) = min(eig(fimTotal{is}));
                end
            end
        end

        function [NcDNewDesign] = optimizeCellCounts(obj,fims,nCellsTotalNew,FIMMetric,...
                NcGuess,NcFixed,NcMax,statistic,covPrior,incrementAdd)
            %% SSIT.optimizeCellCounts - This function optimizes the number 
            %% of cells per time point according to the user-provide metric. 
            % 
            % Inputs:
            %   * 'fims' - either an [Nt x 1] cell array containing the FIM 
            %      matrices for each of the Nt time points, or an [Nt x Ns]
            %      cellarray containing the FIM for each combination of Nt 
            %      time points and Ns different parameter sets
            %   * 'nCellsTotalNew' - the total number of cells to be 
            %       measured, spread out among the Nt time points
            %   * 'FIMmetric' - type of optimization, allowable metrics are:
            %       'Determinant' - maximize the expected determinant of 
            %                       the FIM
            %       'DetCovariance' - minimize the expected determinant of
            %                         MLE covariance
            %       'Smallest Eigenvalue' - maximize the smallest e.val of
            %                               the FIM
            %       'Trace' - maximize the trace of the FIM
            %       '[<i1>,<i2>,...]' - minimize the determinant of the 
            %                           inverse FIM for the specified 
            %                           indices, (all other parameters are
            %                           assumed to be free)
            %       'TR[<i1>,<i2>,...]' - maximize the determinant of the
            %                             FIM for the specified indices, 
            %                             (only the parameters in
            %                             obj.fittingOptions.modelVarsToFit 
            %                             are assumed to be free)
            %   * 'Nc' - an optimal guess for the optimal experiment 
            %            design
            %   * 'NcFixed' - a minimal number of cells to measure at each
            %      time point; this is useful for subsequent experiment
            %      design, having already obtained measured cells from a
            %      previous experiment
            %   * 'NcMax' - maximum total number of cells allowed for each 
            %      time point; this is useful in simulated experiment design,
            %      where there are only so many cells available in the real
            %      data
            %
            % Outputs:
            %   * 'Nc' is the optimized experiment design (number of cells 
            %      to measure at each point in time)
            %
            % Example: Model.optimizeCellCounts(fimResults,nCellsTotal,...
            %           'Determinant',[],[],[],[],diag(log10.^2));
            arguments
                obj
                fims
                nCellsTotalNew
                FIMMetric = 'Smallest Eigenvalue'
                NcGuess = []
                NcFixed = []
                NcMax = []
                statistic = 'mean'
                covPrior = []
                incrementAdd = 1
            end
            if mod(nCellsTotalNew,incrementAdd)~=0
                error('Number of cells must be evenly divisible by incrementAdd.')
            end
            switch FIMMetric
                case 'Determinant'
                    met = @(A)-max(0,det(A));
                case 'DetCovariance'
                    met = @(A)max(0,det(inv(A)));
                case 'Smallest Eigenvalue'
                    met = @(A)-min(eig(A));
                case 'Trace'
                    met = @(A)-trace(A);
                otherwise
                    if strcmp(FIMMetric(1:2),'TR')
                        k = eval(FIMMetric(3:end));
                        met = @(A)max(0,det(inv(A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'tr')
                        k = eval(FIMMetric(3:end));
                        met = @(A)-max(0,det((A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'GR')
                        k = eval(FIMMetric(3:end));
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    else  % all parameters are free.
                        k = eval(FIMMetric);
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    end
            end
            NT = size(fims,1);
            NS = size(fims,2);

            if isempty(NcFixed)
                NcFixed = zeros(1,NT);
            end

            if isempty(NcMax)
                NcMax = inf*ones(1,NT);
            end
            
            if isempty(NcGuess)
                % Distributed avaliable cells among experiments.
                NcGuess = NcFixed;
                iExpt = 1;
                while nCellsTotalNew>0&&iExpt<=length(NcGuess)
                    avblSlots = NcMax(iExpt) - NcFixed(iExpt);
                    if avblSlots>=nCellsTotalNew
                        NcGuess(iExpt) = NcGuess(iExpt) + nCellsTotalNew;
                        iExpt = inf;
                    else
                        while avblSlots >= incrementAdd
                            NcGuess(iExpt) = NcGuess(iExpt) + incrementAdd;
                            nCellsTotalNew = nCellsTotalNew - incrementAdd;
                            avblSlots = avblSlots - incrementAdd;
                        end
                        iExpt = iExpt + 1;
                        if iExpt>length(NcGuess)&&nCellsTotalNew>=0
                            NcDNewDesign = NcGuess - NcFixed;
                            warning('All cells have been distributed.')
                            return
                        end
                    end
                end
            else
                NcGuess = NcFixed+NcGuess;
            end

            % Process to search for optimal experiment
            Converged = 0;
            while Converged==0
                Converged = 1;
                % Iterate through the time points
                for i = 1:NT
                    % If 
                    while NcGuess(i)-incrementAdd>=NcFixed(i)
                        Ncp = NcGuess;
                        Ncp(i) = Ncp(i)-incrementAdd;
                        k = SSIT.findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd);
                        if k==i
                            break
                        end
                        NcGuess = Ncp;
                        NcGuess(k)=NcGuess(k)+incrementAdd;
                        Converged = 0;
                    end
                end
            end
            NcDNewDesign = NcGuess - NcFixed;
        end

        %% Data Loading and Fitting
        function [obj] = loadData(obj,dataFileName,linkedSpecies,conditions)
            % SSIT.loadData - Reads data from given file and associates 
            % it with specified model species and experimental conditions. 
            %
            % Inputs:
            %   * obj
            %   * dataFileName - name of data file, e.g., "dataFile.csv"
            %   * linkedSpecies - takes two strings: first, the names of  
            %   the species given to the SSIT model using the 'species'
            %   property (e.g., Model.species = {'RNA','Protein'}); and
            %   second, the names of the species in the data file (e.g., 
            %   {'RNA','x1';'Protein','x2'})
            %   * conditions - data conditions that can be used to filter 
            %                out data that do not meet specifications, 
            %                e.g., conditions = {'Rep_num','1'}  : only 
            %                the data in the 'Rep_num' column that is 
            %                exactly equal to '1' will be kept in the 
            %                data set
            %
            % Example:
            %   Model = Model.loadData("/data/dataFile.csv",...
            %    {'RNA','x1';'Protein','x2'},...
            %    {'Drug_Conc',100});
            arguments
                obj
                dataFileName
                linkedSpecies
                conditions = {};
            end
            obj.dataSet =[];
%             Tab = readtable(dataFileName);
%             obj.dataSet.dataNames = Tab.Properties.VariableNames;
%             obj.dataSet.DATA = table2cell(Tab);
% 
%             obj.dataSet.linkedSpecies = linkedSpecies;
% 
%             possibleTimeHeaders = {'time','Time','TIME','Time_index'};
%             Q = zeros(1,length(obj.dataSet.dataNames));
%             for iHead = 1:length(possibleTimeHeaders)
%                 Q = max(Q,strcmp(obj.dataSet.dataNames,possibleTimeHeaders{iHead}));
%             end
%             if sum(Q)>=1
%                 obj.dataSet.app.ParEstFitTimesList.Value = {};
%                 obj.dataSet.app.ParEstFitTimesList.Items = {};
%                 if sum(Q)>1
%                     error('Provided data more than one entry with keyword "time"')   
%                 end
%                 col_time = find(Q,1);
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_time_index = col_time;
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = sort(unique(cell2mat(obj.dataSet.DATA(:,col_time))));
%                 for i=1:length(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times)
%                     obj.dataSet.app.ParEstFitTimesList.Items{i} = num2str(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times(i));
%                     obj.dataSet.app.ParEstFitTimesList.Value{i} = num2str(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times(i));
%                 end
%                 % We need to make sure that the fitting times are included in the solution times.
% 
%             else
%                 error('Provided data set does not have required column named "time"')
%             end
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTable = obj.dataSet.DATA;
% 
%             Nd = length(obj.species);
%             nCol = length(obj.dataSet.dataNames);
% 
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix = ...
%                 zeros(Nd+3,nCol);
% 
%             % auto-detect and record 'time' column
%             Itime = Nd+1;
%             Jtime = find(Q);
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(Itime,Jtime) = 1;
% %             obj.dataSet.times = unique([obj.dataSet.DATA{:,Jtime}]);
% 
%             % record linked species
%             for i=1:size(linkedSpecies,1)
%                 J = find(strcmp(obj.dataSet.dataNames,linkedSpecies{i,2}));
%                 I = find(strcmp(obj.species,linkedSpecies{i,1}));
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(I,J)=1;
%             end
% 
%             % set up conditionals
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.conditionOnArray = {};
%             for i=1:size(conditions,1)
%                 J = find(strcmp(obj.dataSet.dataNames,conditions{i,1}));
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.conditionOnArray(end+1,:) = {J,conditions{i,2}};
%             end
% 
%             % set to marginalize over everything else
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(Nd+3,:) = ...
%                 sum(obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix)==0;
% 
%             obj.dataSet.app.SpeciesForFitPlot.Items = obj.species;
%             % [obj.dataSet.app,obj.dataSet.times] = filterAndMarginalize([],[],obj.dataSet.app);

% <<<<<<< HEAD
            %% Attempt to do same thing using tables
            if ischar(dataFileName)
                TAB = readtable(dataFileName);
            elseif iscell(dataFileName)
                TAB = table;
                for iCell = 1:length(dataFileName)
                    iTAB = readtable(dataFileName{iCell});
                    TAB = [TAB;iTAB];
                end
            end

            % Find time column
            timeField = TAB.Properties.VariableNames(contains(lower(TAB.Properties.VariableNames),'time'));
            if isempty(timeField)
                error('Data sheet does not have an entry with keyword "time"');
            elseif length(timeField)>2
                error('Data sheet has more than one entry with keyword "time"');
            end

            % Apply conditions
            for i = 1:size(conditions,1)
                if size(conditions,2)==2
                    if isnumeric(conditions{i,2})&&isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB(TAB.(conditions{i,1})==conditions{i,2},:);
                    elseif ischar(conditions{i,2})&&iscell(TAB.(conditions{i,1})(1))&&ischar(TAB.(conditions{i,1}){1})
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif ischar(conditions{i,2})&&ischar(TAB.(conditions{i,1})(1))
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB((TAB.(conditions{i,1}))==eval(conditions{i,2}),:);
                    end
                else
                    try
                        eval(['TAB = TAB(TAB.(conditions{i,1})',conditions{i,3},'conditions{i,2},:);'])
                    catch
                        eval(['TAB = TAB(',conditions{i,3},',:);'])
                    end
                end
            end
            obj.dataSet.DATA = table2cell(TAB);

            % Link Species
            % First, make sure that all linked species are in the order of
            % species.
            iSpe = [];
            for i = 1:length(obj.species)
                if max(contains(linkedSpecies(:,1),obj.species(i)))
                    j = find(strcmp(linkedSpecies(:,1),obj.species(i)));
                    iSpe = [iSpe,j];
                end
            end
            linkedSpecies = linkedSpecies(iSpe,:);

            TAB2 = table;
            TAB2.time = TAB.(timeField{1});
            for i = 1:size(linkedSpecies,1)
                if ~isempty(linkedSpecies{i,2})
                    TAB2.(linkedSpecies{i,1}) = TAB.(linkedSpecies{i,2});
                elseif ~isempty(linkedSpecies{i,3})
                    % This section allows for manipulation of data columns.
                    % Example: linkedSpecies = {'rna',[],'TAB.nuc+TAB.cyt'}
                    % results in TAB2.rna = TAB.nuc+TAB.cyt
                    eval(['TAB2.',linkedSpecies{i,1},' = ',linkedSpecies{i,3},';']);
                end

            end

            % Reorder table in order of species list
            [~,iA] = intersect(linkedSpecies(:,1),obj.species,'stable');
            TAB2 = TAB2(:,[1,iA'+1]);
              
            % dataTensor = sptensor(
            times = unique(TAB2.time);
            numTimes = length(times);
            timeAr = TAB2.time;
            for i = 1:numTimes
                timeAr(TAB2.time==times(i)) = i-1;
            end
            TAB2.time = timeAr;

            % Construct sparse tensor to hold data.
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor = sptensor(TAB2.Variables+1,ones(size(TAB2,1),1));

            % Define other properties needed in other functions.
            obj.dataSet.linkedSpecies = linkedSpecies;
            obj.dataSet.times = times';
% =======
% 
% 
%             %% ad hoc:
%             %% The gui data-loading function 'filterAndMarginalize', which 
%             %% is supposed to filter data by user-specified conditions, 
%             %% doesn't.
%             %% And it's a mess.  I tried and failed to fix it without 
%             %% breaking the Universe, so since this whole thing needs to be 
%             %% refactorized anyway, we're going to temporarily manually 
%             %% filter logic here in SSIT's 'loadData'. 
%             %% -AP
%             % Test for one condition:
%             %     conditionCol = find(strcmp(obj.dataSet.dataNames, conditions{i}));
%             %     conditionVals = obj.dataSet.DATA(:, conditionCol);
%             %   % Convert numeric values to strings for comparison
%             %     conditionValsStr = cellfun(@num2str, conditionVals, 'UniformOutput', false);
%             %     filteredIdx = strcmp(conditionValsStr, '1');
%             %     obj.dataSet.DATA = obj.dataSet.DATA(filteredIdx, :);
% 
%             % Apply all user-specified filtering conditions 
%             for i = 1:size(conditions, 1)
%                 conditionColName = conditions{i, 1};
%                 conditionTarget = conditions{i, 2};
% 
%                 % Find the column index for this condition
%                 conditionCol = find(strcmp(obj.dataSet.dataNames, conditionColName));
% 
%                 if isempty(conditionCol)
%                     error('Condition column "%s" not found in dataset.', conditionColName);
%                 end
% 
%                 % Extract and normalize the column values
%                 columnVals = obj.dataSet.DATA(:, conditionCol);
%                 columnValsStr = cellfun(@num2str, columnVals, 'UniformOutput', false);
%                 conditionTargetStr = num2str(conditionTarget);
% 
%                 % Find rows that match this condition
%                 matchedIdx = strcmp(columnValsStr, conditionTargetStr);
% 
%                 % Apply filter to keep only matching rows
%                 obj.dataSet.DATA = obj.dataSet.DATA(matchedIdx, :);
%             end
% 
% 
%             obj.dataSet.linkedSpecies = linkedSpecies;
% 
%             possibleTimeHeaders = {'time','Time','TIME','Time_index'};
%             Q = zeros(1,length(obj.dataSet.dataNames));
%             for iHead = 1:length(possibleTimeHeaders)
%                 Q = max(Q,strcmp(obj.dataSet.dataNames,possibleTimeHeaders{iHead}));
%             end
%             if sum(Q)>=1
%                 obj.dataSet.app.ParEstFitTimesList.Value = {};
%                 obj.dataSet.app.ParEstFitTimesList.Items = {};
%                 if sum(Q)>1
%                     error('Provided data more than one entry with keyword "time"')   
%                 end
%                 col_time = find(Q,1);
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_time_index = col_time;
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = sort(unique(cell2mat(obj.dataSet.DATA(:,col_time))));
%                 for i=1:length(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times)
%                     obj.dataSet.app.ParEstFitTimesList.Items{i} = num2str(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times(i));
%                     obj.dataSet.app.ParEstFitTimesList.Value{i} = num2str(obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times(i));
%                 end
%                 % We need to make sure that the fitting times are included in the solution times.
% 
%             else
%                 error('Provided data set does not have required column named "time"')
%             end
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTable = obj.dataSet.DATA;
% 
%             Nd = length(obj.species);
%             nCol = length(obj.dataSet.dataNames);
% 
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix = ...
%                 zeros(Nd+3,nCol);
% 
%             % auto-detect and record 'time' column
%             Itime = Nd+1;
%             Jtime = find(Q);
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(Itime,Jtime) = 1;
% %             obj.dataSet.times = unique([obj.dataSet.DATA{:,Jtime}]);
% 
%             % record linked species
%             for i=1:size(linkedSpecies,1)
%                 J = find(strcmp(obj.dataSet.dataNames,linkedSpecies{i,2}));
%                 I = find(strcmp(obj.species,linkedSpecies{i,1}));
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(I,J)=1;
%             end
% 
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.conditionOnArray = {};
%             for i=1:size(conditions,1)
%                 J = find(strcmp(obj.dataSet.dataNames,conditions{i,1}));
%                 val = conditions{i,2};
%                 if isnumeric(val)
%                     val = num2str(val);
%                 end
%                 obj.dataSet.app.DataLoadingAndFittingTabOutputs.conditionOnArray(end+1,:) = {J, val};
%             end
% 
% 
%             % set to marginalize over everything else
%             obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix(Nd+3,:) = ...
%                 sum(obj.dataSet.app.DataLoadingAndFittingTabOutputs.marginalMatrix)==0;
% 
% >>>>>>> main
            obj.dataSet.app.SpeciesForFitPlot.Items = obj.species;
            obj.dataSet.app.SpeciesForFitPlot.Items = linkedSpecies(:,1);
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = times';
            for i=1:numTimes
                obj.dataSet.app.ParEstFitTimesList.Items{i} = num2str(times(i));
            end
            obj.dataSet.app.ParEstFitTimesList.Value = obj.dataSet.app.ParEstFitTimesList.Items;

                     
            %%

%             obj.dataSet.times = unique([obj.dataSet.DATA{:,Jtime}]);

            sz = size(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor);
            obj.dataSet.nCells=zeros(sz(1),1);
            for i=1:sz(1)
                if length(sz)==2
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:)),'all');
                elseif length(sz)==3
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:)),'all');
                elseif length(sz)==4
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:)),'all');
                elseif length(sz)==5
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:,:)),'all');
                end
            end

            obj.tSpan = unique([obj.initialTime,obj.dataSet.times]);

            % Calculate the means and variances
            obj.dataSet.mean = zeros(sz(1),length(sz)-1);
            obj.dataSet.var = zeros(sz(1),length(sz)-1);
            for i=1:sz(1)
                for j=2:length(sz)
                    tmpInt{j-1} = [1:sz(j)];
                end
                TMP = squeeze(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,tmpInt{:})));
                for j = 1:length(sz)-1
                    if length(sz)>2
                        H = sum(TMP,[1:j-1,j+1:length(sz)-1]);
                    else
                        H = TMP;
                    end
                    obj.dataSet.mean(i,j) = sum([0:length(H)-1]'.*H(:))/sum(H);
                    x2 = sum(([0:length(H)-1].^2)'.*H(:))/sum(H);
                    obj.dataSet.var(i,j) = x2 - obj.dataSet.mean(i,j)^2;
                end
            end

            %% Automatically set unobserved species based on loaded data.
            obj.pdoOptions.unobservedSpecies = setdiff(obj.species,linkedSpecies(:,1),'stable')';

        end

        function [logL,gradient] = minusLogL(obj,pars,stateSpace,computeSensitivity)
            [logL,gradient] = computeLikelihood(obj,exp(pars),stateSpace,computeSensitivity);
            logL = -logL;
            gradient = -gradient.*exp(pars);
        end

        function [logLode] = computeLikelihoodODE(obj,pars,SIG)
            arguments
                obj
                pars = [];
                SIG = [];
            end
        
            if strcmp(obj.fittingOptions.timesToFit,'all')
                logTimesToFit = ones(1,length(obj.dataSet.times),'logical');
            else
                logTimesToFit = obj.fittingOptions.timesToFit;
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                indsParsToFit = [1:length(obj.parameters)];
            else
                indsParsToFit = obj.fittingOptions.modelVarsToFit;
            end
            nModelPars = length(indsParsToFit);

            if isempty(pars)
                pars = [obj.parameters{indsParsToFit,2}];
            end

            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            originalPars = obj.parameters;
            obj.tSpan = unique([obj.initialTime,obj.tSpan,obj.dataSet.times]);
            [~,IA,~] = intersect(obj.tSpan,obj.dataSet.times(logTimesToFit));

            % Update Model and PDO parameters using supplied guess
            obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

            obj.solutionScheme = 'ode'; % Chosen solutuon scheme
            for i=1:size(obj.parameters,1)
                obj.parameters{i,2} = round(obj.parameters{i,2},12);
            end
            solutions = obj.solve;  % Solve the ODE analysis

            obj.parameters =  originalPars;

            % Need to add likelihood calculation here.
            nt = length(IA);
%             ns = length(obj.species);

            for i = 1:size(obj.dataSet.linkedSpecies,1)
                J(i) = find(strcmp(obj.species,obj.dataSet.linkedSpecies{i,1}));
            end
            nds = length(J);

            nc = repmat(obj.dataSet.nCells(logTimesToFit),nds,1);

            vm = zeros(nt*nds,1); 
            tmp = solutions.ode(IA,J);
            vm(:) = tmp(:);
            
            vd = zeros(nt*nds,1); 
            vd(:) = obj.dataSet.mean(logTimesToFit,:);
            
            vm = real(vm);
            
            if isempty(SIG)
                % SIG = eye(nt*nds);
                vec = zeros(numel(obj.dataSet.var(logTimesToFit,:)),1);
                vec(:) = obj.dataSet.var(logTimesToFit,:);
                SIG = diag(vec);
            end

            logLode = -1/2*(sqrt(nc)'.*(vd-vm)')*SIG^(-1)*((vd-vm).*sqrt(nc));
            logLode = logLode+logPrior;
        end

        function [logL,gradient,fitSolutions] = computeLikelihood(obj,pars,stateSpace,computeSensitivity)
            % This function computes the log likelihood of the data given
            % the model. 
            % obj -- (SSIT class)
            % pars -- parameters of model in linear space.  Matches the
            %   order in obj.parameters, and downselected to the free
            %   parameters in obj.fittingOptions.modelVarsToFit.
            % stateSpace -- (optional) statespace for FSP solution.
            %   providing increases efficiency.
            % computeSensitivity -- (false) flag to request
            %   sensitivity of loglkelihood functon wrt parameters as a
            %   returned variable. 
            arguments
                obj
                pars = [];
                stateSpace =[];
                computeSensitivity = false;
            end

            % Reset state space if it has inconsistencies
            if ~isempty(stateSpace)&&size(stateSpace.states,2)~=stateSpace.state2indMap.Count
                stateSpace =[];
            end

            % select which parameters to consider in likelihood function
            % first for the model parameters
            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                indsParsToFit = [1:length(obj.parameters)];
            else
                indsParsToFit = obj.fittingOptions.modelVarsToFit;
            end
            nModelPars = length(indsParsToFit);

            % then for PDO parameters
            if strcmp(obj.fittingOptions.pdoVarsToFit,'all')
                indsPdoParsToFit = [1:length(obj.pdoOptions.props.ParameterGuess)];
            else
                indsPdoParsToFit = obj.fittingOptions.pdoVarsToFit;
            end
            nPdoPars = length(indsPdoParsToFit);

            % if parameters are not provided, use the ones stored in the
            % SSIT object.
            if isempty(pars)
                pars = [obj.parameters{indsParsToFit,2}];
            end

            % if there is no logprior, use zero.
            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            % save original parameters
            originalPars = obj.parameters;

            % remove duplicates from time span
            obj.tSpan = unique([obj.initialTime,obj.tSpan]);

            % Update Model and PDO parameters using supplied guess
            obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

            % Call routines to find the FSP solution with or without
            % sensitivity.
            if computeSensitivity&&nargout>=2
                obj.solutionScheme = 'fspSens'; % Chosen solution scheme 
                [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
            else
                obj.solutionScheme = 'FSP'; % Chosen solution scheme 
                [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
            end
            obj.parameters =  originalPars;

            % Formulate PDO if one is used and it has adjustable
            % parameters.
            if ~isempty(pars)&&nPdoPars>0
                obj.pdoOptions.props.ParameterGuess(indsPdoParsToFit) = pars(nModelPars+1:end);
                obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
            end

            % Separate out stochastic species if using a hybrid ode/fsp
            % model.
            if obj.useHybrid
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end
            
            % % Record which species of interest are linked to data.
            % % TODO - this might lead to errors if names are not fully
            % % unique.  Need to check.
            % Nd = length(speciesStochastic);
            % for i=Nd:-1:1
            %     indsPlots(i) = max(contains(obj.dataSet.linkedSpecies(:,1),speciesStochastic(i)));
            % end
            % 
            % % Find max lengths of FSP tensors in every species.
            % szP = zeros(1,Nd);
            % for it = length(obj.tSpan):-1:1
            %     if ~computeSensitivity||nargout<2
            %         szP = max(szP,size(solutions.fsp{it}.p.data));
            %     else
            %         szP = max(szP,size(solutions.sens.data{it}.p.data));
            %     end
            % end

            % % Create a full tensor with the results of the FSP solution.
            % % TODO - there must be an easir tensor-based solution to do
            % % this.
            % % Start by initializing the tensor to appropriate size.
            % P = zeros([length(obj.tSpan),szP(indsPlots)]);
            % for it = length(obj.tSpan):-1:1
            %     % Find inds that are marginalized over.
            %     indsIgnore = setdiff([1:Nd],find(indsPlots));
            %     if ~computeSensitivity||nargout<2
            %         % get FSP solution for current time.
            %         px = solutions.fsp{it}.p;
            %     else
            %         if computeSensitivity&&nargout>=2
            %             px = solutions.sens.data{it}.p;
            %             Sx = solutions.sens.data{it}.S;
            %             parCount = length(Sx);
            %             % Add effect of PDO.
            %             if ~isempty(obj.pdoOptions.PDO)
            %                 for iPar = 1:parCount
            %                     Sx(iPar) = obj.pdoOptions.PDO.computeObservationDistDiff(px, Sx(iPar), iPar);
            %                 end
            %             end
            %         end
            %     end
            % 
            %     % Add effect of PDO.
            %     if ~isempty(obj.pdoOptions.PDO)
            %         try
            %             px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
            %         catch
            %             obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
            %             px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
            %         end
            %     end
            % 
            %     % Sum over the marginalization indices (if any). The return
            %     % result as a double vector.
            %     if ~isempty(indsIgnore)
            %         d = double(px.sumOver(indsIgnore).data);
            %     else
            %         d = double(px.data);
            %     end
            % 
            %     % Copy over the non-zero numbers
            %     P(it,d~=0) = d(d~=0);
            % 
            %     if computeSensitivity&&nargout>=2
            %         for iPar = parCount:-1:1
            %             if ~isempty(indsIgnore)
            %                 d = double(Sx(iPar).sumOver(indsIgnore).data);
            %             else
            %                 d = double(Sx(iPar).data);
            %             end
            %             S{iPar}(it,d~=0) = d(d~=0);
            %         end
            %     end
            % end
            % 
            % % Padd P or Data to match sizes of tensors.
            % NP = size(P);
            % PD = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            % NDat = size(PD);
            % % Make sure the tensors have the same rank (matlab truncated
            % % singleton dimensions).
            % if length(NP)<Nd; NP(end+1:Nd)=1; end
            % 
            % % Pad if data longer than model.
            % % TODO - this logic is clunky.  Could be made morre
            % % understadable and more efficient. All we are doing here is
            % % adding zeros to pad the tensors to be the same size.
            % if max(NDat(2:end)-NP(2:length(NDat)))>0   % Pad if data longer than model
            %     NP(2:length(NDat)) = max(NP(2:length(NDat)),NDat(2:end));
            %     tmp = 'P(end';
            %     for j = 2:length(NDat)
            %         tmp = [tmp,',NP(',num2str(j),')'];
            %     end
            %     tmp = [tmp,')=0;'];
            %     eval(tmp);
            %     if computeSensitivity&&nargout>=2
            %         for iPar = 1:parCount
            %             tmp2 = strrep(tmp,'P(end',['S{',num2str(iPar),'}(end']);
            %             eval(tmp2);
            %         end
            %     end
            % end
            % 
            % % Now, pad the data tensor if the model tensor is longer.
            % if max(NP(2:length(NDat))-NDat(2:end))>0   % Pad if model longer than data
            %     NDat(2:length(NDat)) = max(NP(2:length(NDat)),NDat(2:end));
            %     tmp = 'PD(end';
            %     for j = 2:length(NDat)
            %         tmp = [tmp,',NDat(',num2str(j),')'];
            %     end
            %     tmp = [tmp,')=0;'];
            %     eval(tmp);
            %     %                 if computeSensitivity&&nargout>=2
            %     %                     for iPar = 1:parCount
            %     %                         tmp2 = strrep(tmp,'P(end',['S{',num2str(iPar),'}(end']);
            %     %                         eval(tmp2);
            %     %                     end
            %     %                 end
            % end
            % obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor=PD;
            % 
            % %             if max(NP(2:length(NDat))-NDat(2:end))>0   % truncate if model longer than data
            % %                 tmp = 'P = P(:';
            % %                 for j = 2:length(NDat)
            % %                     tmp = [tmp,',1:',num2str(NDat(j))];
            % %                 end
            % %                 for j = (length(NDat)+1):4
            % %                     tmp = [tmp,',1'];
            % %                 end
            % %                 tmp = [tmp,');'];
            % %                 eval(tmp)
            % %                 if computeSensitivity&&nargout>=2
            % %                     for iPar = 1:parCount
            % %                         tmp2 = strrep(tmp,'P = P',['S{',num2str(iPar),'} = S{',num2str(iPar),'}']);
            % %                         eval(tmp2);
            % %                     end
            % %                 end
            % %             end
            % 
            % % Set minimum value of model distribution at 10^-10.
            % P = max(P,1e-10);
            % % Remove imaginary entries and send warning to user.
            % if ~isreal(P)
            %     P = real(P);
            %     disp('removed imaginary elements of FSP solution')
            % end
            % 
            % % Find data times for fitting, and then downselect data to just
            % % those times. 
            % % TODO - this approach is clunky.  All we are doing is slizing
            % % a tensor.  Unfortunately, matlab sometimes removes singleton
            % % dimensions resulting in the wrong tensor size.
            % if strcmp(obj.fittingOptions.timesToFit,'all')
            %     times = obj.dataSet.times;
            %     fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
            %     obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            % else
            %     times = obj.dataSet.times(obj.fittingOptions.timesToFit);
            %     fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
            %     fitSolutions.ParEstFitTimesList.Value = obj.dataSet.app.ParEstFitTimesList.Value(obj.fittingOptions.timesToFit);
            %     if ndims(PD)==2
            %         PD = PD(find(obj.fittingOptions.timesToFit),:);
            %     elseif ndims(PD)==3
            %         PD = PD(find(obj.fittingOptions.timesToFit),:,:);
            %     elseif ndims(PD)==4
            %         PD = PD(find(obj.fittingOptions.timesToFit),:,:,:);
            %     end
            % end

            %% Try to redo this using tensors
            % TODO - The following code works to compute the likelihood and
            % it is much faster, but it has not yet been fully tested, and
            % we have not removed the existing slower code.

            if strcmp(obj.fittingOptions.timesToFit,'all')
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            else
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                fitSolutions.ParEstFitTimesList.Value = fitSolutions.ParEstFitTimesList.Items(obj.fittingOptions.timesToFit);
                timesToFit = zeros(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
                timesToFit(obj.fittingOptions.timesToFit) = true;
                obj.fittingOptions.timesToFit = timesToFit;
                
            end

            dataTensor = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            timesData = dataTensor.subs(:,1);
            timesUnique = unique(timesData);

            % Map measurement times to the solution times.
            J = zeros(1,length(obj.dataSet.times(obj.fittingOptions.timesToFit)));
            for it = 1:length(J)                    
                [~,J(it)] = min(abs(obj.tSpan-obj.dataSet.times(it)));
            end
            if ~computeSensitivity||nargout<2
                fsp = solutions.fsp(J);
            elseif computeSensitivity&&nargout>=2
                sens = solutions.sens.data(J);
            end
            numTimes = length(J);

            Nd = length(speciesStochastic);
            for i=Nd:-1:1
                indsPlots(i) = max(contains(obj.dataSet.linkedSpecies(:,1),speciesStochastic(i)));
            end
            indsIgnore = setdiff([1:Nd],find(indsPlots),'stable');

            LogLk = zeros(1,numTimes);
            
            % Set up storage for outputs if requested.
            if nargout>=3
                perfectMod = zeros(1,numTimes);
                numCells = obj.dataSet.nCells(obj.fittingOptions.timesToFit)';
                sz = [numTimes,max(solutions.stateSpace.states,[],2)'];
                sz = sz([true,indsPlots]);
                fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = sptensor(sz);
            end

            for it = 1:numTimes
                 if ~computeSensitivity||nargout<2
                     % get FSP solution for current time.
                     px = fsp{it}.p;
                 elseif computeSensitivity&&nargout>=2
                     px = sens{it}.p;
                     Sx = sens{it}.S;
                     parCount = length(Sx);
                     % Add effect of PDO.
                     if ~isempty(obj.pdoOptions.PDO)
                         for iPar = 1:parCount
                             Sx(iPar) = obj.pdoOptions.PDO.computeObservationDistDiff(px, Sx(iPar), iPar);
                         end
                     end
                     % Remove ignored species
                     for iPar = parCount:-1:1
                        if ~isempty(indsIgnore)
                            S{iPar} = Sx(iPar).sumOver(indsIgnore);
                        else
                            S{iPar} = Sx(iPar);
                        end
                        % S{iPar}(it,d~=0) = d(d~=0);
                    end
                 end
                 % Add effect of PDO.
                 if ~isempty(obj.pdoOptions.PDO)
                     try
                         px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                     catch
                         obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
                         px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                     end
                 end
                 % Sum over the marginalization indices (if any). The return
                 % result as a double vector.
                 if ~isempty(indsIgnore)
                     px = px.sumOver(indsIgnore);
                 end

                 % Get indices and number of all observed data.
                 inds = dataTensor.subs(timesData==timesUnique(it),2:end);
                 vals = dataTensor.vals(timesData==timesUnique(it));
                 szData = max(inds);
                 
                 % Pad Probability Distribution if support does not cover
                 % all data.
                 Pvals = px.data;
                 szModel = size(Pvals);
                 if max(szData-szModel)>0
                     Pvals(szData)=0;
                 end

                 Pvals = real(max(1e-10,double(Pvals)));
                 Pvals = Pvals/max(1,sum(Pvals,'all'));
                 logP = sptensor(log(Pvals));

                 LogLk(it) = vals'*logP(inds);
                 
                 if nargout>=3
                     perfectMod(it) = vals'*log(vals/sum(vals));
                     Pvt = sptensor(Pvals);
                     if length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs(:,1:end-1)]) = Pvt.vals;
                     elseif length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))-1
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs]) = Pvt.vals;
                     end
                 end

                 if computeSensitivity&&nargout>=2
                     for iPar = parCount:-1:1
                         St = S{iPar};
                         Svals = double(St.data);
                         dlogL_dPar(iPar,it) = sum(vals'*(Svals(inds)./Pvals(inds)));
                     end
                 end
            end
            % P = 
            % solnTensor = sptensor([length(solutions.fsp),max(solutions.stateSpace.states,[],2)'+1]);
            % solnT


            %%

            % Store data and model information for use in other routines.
            % The format used here is chosen to match an existing object in
            % the SSIT GUI.
            if nargout>=3
                % Make Full Tensor for Plotting                    
                for it = 1:numTimes


                end


                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = zeros([numTimes,sz(2:end)]);
                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData = zeros([numTimes,sz(2:end)]);
                fitSolutions.NameTable.Data = [speciesStochastic,speciesStochastic];
                fitSolutions.SpeciesForFitPlot.Value = speciesStochastic(indsPlots);
                fitSolutions.SpeciesForFitPlot.Items = speciesStochastic;
                fitSolutions.DataLoadingAndFittingTabOutputs.dataTensor = dataTensor;
                fitSolutions.FspPrintTimesField.Value = ['[',num2str(obj.tSpan),']'];
                if ~computeSensitivity
                    fitSolutions.FspTabOutputs.solutions = solutions.fsp;
                else
                    fitSolutions.FspTabOutputs.solutions = solutions;
                end
                fitSolutions.FIMTabOutputs.distortionOperator = obj.pdoOptions.PDO;
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.dataTimes = obj.dataSet.times(obj.fittingOptions.timesToFit);
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = timesUnique;
            end

            % % Initialize sensitivity derivative if needed.
            % if computeSensitivity&&nargout>=2
            %     dlogL_dPar = zeros(parCount,numTimes);
            % end
            % 
            % % Initialize log likelihood at zero for all times.
            % % LogLk = zeros(1,numTimes);
            % KS = zeros(1,numTimes);
            % numCells = zeros(1,numTimes);
            % 
            % % LogL for idealized models 
            % perfectMod = zeros(1,numTimes);
            % perfectModSmoothed = zeros(1,numTimes);
            % 
            % for i=1:numTimes
            %     % Find the closes time index 
            %     [diffTime,j] = min(abs(obj.tSpan-obj.dataSet.times(i)));
            %     if diffTime~=0
            %         warning('Exact match not found for time. Inaccuracies possible.')
            %     end
            % 
            %     Jind = PD.subs(:,1) == i;
            %     SpInds = PD.subs(Jind,:);
            % 
            %     SpVals = PD.vals(Jind);
            %     H = sptensor([ones(length(SpVals),1),SpInds(:,2:end)],SpVals,[1,NDat(2:end)]);
            %     H = double(H);
            %     Pt = P(j,:,:,:,:,:,:,:,:,:);
            %     Pt = Pt/max(1,sum(Pt,'all'));
            %     % LogLk(i) = sum(H(:).*log(Pt(:)));
            %     numCells(i) = sum(H(:));
            %     if computeSensitivity&&nargout>=2
            %         for iPar = parCount:-1:1
            %             St = S{iPar}(j,:,:,:,:,:,:);
            %             dlogL_dPar(iPar,i) = sum(H(:).*St(:)./Pt(:));
            %         end
            %     end
            %     if nargout>=3
            %         Q = H(:)/sum(H(:));
            %         KS(i) = max(abs(cumsum(Q(:))-cumsum(Pt(:))));
            %         smQ = smooth(Q); smQ=smQ/sum(smQ);
            %         logQ = log(Q); logQ(H==0)=1;
            %         logSmQ = log(smQ); logSmQ(H==0)=1;
            %         perfectMod(i) = sum(H(:).*logQ);
            %         perfectModSmoothed(i) = sum(H(:).*logSmQ);
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current(i,:,:,:,:,:,:) = Pt;
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:,:,:,:) = ...
            %             reshape(Q,size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:)));
            %     end
            % end
            logL = sum(LogLk) + logPrior;
            
            if imag(logL)~=0
                disp('Imaginary likelihood set to -inf.')
                logL = -inf;
            end
            if nargout>=3
                fitSolutions.DataLoadingAndFittingTabOutputs.V_LogLk = LogLk;
                fitSolutions.DataLoadingAndFittingTabOutputs.numCells = numCells;
                fitSolutions.DataLoadingAndFittingTabOutputs.perfectMod = perfectMod;
                % fitSolutions.DataLoadingAndFittingTabOutputs.perfectModSmoothed = perfectModSmoothed;
                % fitSolutions.DataLoadingAndFittingTabOutputs.V_KS = KS;
            end
            if computeSensitivity&&nargout>=2
                gradient = sum(dlogL_dPar,2); % need to also add gradient wrt prior!!
            else
                gradient = [];
            end
        end

        function fitErrors = likelihoodSweep(obj,parIndices,scalingRange,makePlot)
            % likelihoodSweep - sweep over range of parameters and return
            % likelihood function values at all parameter combinations.
            arguments
                obj
                parIndices
                scalingRange = linspace(0.5,1.5,15);
                makePlot = false
            end
            obj.fittingOptions.modelVarsToFit = parIndices;  % Choose which parameters to vary.
            pars0 = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];
            
            fspSoln = obj.solve(); 
            stateSpace = fspSoln.stateSpace;
            
            Ngrid=length(scalingRange);
            fitErrors = zeros(Ngrid,Ngrid);

            likeFunction = @(pars)obj.computeLikelihood(pars,stateSpace);
            for i = 1:Ngrid
                parfor j = 1:Ngrid
                    pars = pars0.*scalingRange([i,j]);
                    fitErrors(i,j) = likeFunction(pars);
                end
            end
            if makePlot
                fg = figure;
                set(0,'CurrentFigure',fg);
                if length(parIndices)>2
                    disp('plots are only created for first two parameters')
                end
                
                % Set minimum contour at -300
                lkhMin = max(fitErrors,[],'all')-300;
                contourf(scalingRange*pars0(1),scalingRange*pars0(2),max(fitErrors',lkhMin),30)
                set(gca,'fontsize',15)
                xlabel(obj.parameters{obj.fittingOptions.modelVarsToFit(1)});
                ylabel(obj.parameters{obj.fittingOptions.modelVarsToFit(2)});
                colorbar
                hold on

                [tmp,I] = max(fitErrors);
                [~,J] = max(tmp);
                plot(scalingRange([1,Ngrid])*pars0(1),pars0(2)*[1,1],'k--','linewidth',3)
                plot(pars0(1)*[1,1],scalingRange([1,Ngrid])*pars0(2),'k--','linewidth',3)
                plot(pars0(1)*scalingRange(I(J)),pars0(2)*scalingRange(J),'ro','MarkerSize',20,'MarkerFaceColor','r')
            end
        end
                               % WARNING: returns height of posterior instead of likelihood if priors are specified
        function [pars,likelihood,otherResults,obj] = maximizeLikelihood(obj,parGuess,fitOptions,fitAlgorithm) 
            arguments
                obj
                parGuess = [];
                fitOptions = optimset('Display','iter','MaxIter',2000);
                fitAlgorithm = 'fminsearch';
            end

            % parse fitting options
            allFitOptions.suppressFSPExpansion = true;
            fNames = fieldnames(fitOptions);
            for i=1:length(fNames)
                allFitOptions.(fNames{i}) = fitOptions.(fNames{i});
            end

            if isempty(obj.propensitiesGeneral)
                obj = formPropensitiesGeneral(obj);
            end

            if ischar(obj.fittingOptions.modelVarsToFit)&&strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = (1:size(obj.parameters,1));
            end
            if isempty(parGuess)
                parGuess = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}]';
            end

            if strcmp(obj.solutionScheme,'fspSens')   % Set solution scheme to FSP.
                obj.solutionScheme='FSP';
            end

            if strcmp(obj.solutionScheme,'FSP')   % Set solution scheme to FSP.
                [FSPsoln,~,obj] = obj.solve;  % Solve the FSP analysis
                % obj.fspOptions.bounds = bounds;% Save bound for faster analyses
                if allFitOptions.suppressFSPExpansion
                    tmpFSPtol = obj.fspOptions.fspTol;
                    obj.fspOptions.fspTol = inf;
                end
                objFun = @(x)-obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
            elseif strcmp(obj.solutionScheme,'ode')  % Set solution scheme to ode.
                objFun = @(x)-obj.computeLikelihoodODE(exp(x));  % We want to MAXIMIZE the likelihood.
            end

            x0 = log(parGuess);

            switch fitAlgorithm
                case 'fminsearch'
                    [x0,likelihood,~,otherResults]  = fminsearch(objFun,x0,allFitOptions);

                case 'fminunc'
                    obj.fspOptions.fspTol = inf;
                    objFun = @obj.minusLogL;  % We want to MAXIMIZE the likelihood.
                    x0 = log(parGuess);
                    [x0,likelihood]  = fminunc(objFun,x0,allFitOptions,FSPsoln.stateSpace,true);

                case 'particleSwarm'
                    obj.fspOptions.fspTol=inf;
                    rng('shuffle')
                    OBJps = @(x)objFun(x');
                    LB = -5*ones(size(x0'));
                    UB = 5*ones(size(x0'));
                    initSwarm = repmat(x0',fitOptions.SwarmSize-1,1);
                    initSwarm = [x0';initSwarm.*(1+0.1*randn(size(initSwarm)))];
                    fitOptions.InitialSwarmMatrix = initSwarm;
                    [x0,likelihood] = particleswarm(OBJps,length(x0),LB,UB,allFitOptions);

                case 'mlSearch'
                    % Not yet working efficiently.
                    defaultFitOptions.maxIter=1000;
                    defaultFitOptions.burnIn=30;
                    defaultFitOptions.updateRate=10;
                    defaultFitOptions.guessRate=1000;
                    defaultFitOptions.proposalDistribution=@(x)x+0.01*randn(size(x));
                    defaultFitOptions.useFIMforSearch = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.plotFunVals = false;
                    defaultFitOptions.proposalDistributionWide=@(x)x+randn(size(x));

                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if allFitOptions.logForm
                        objFun = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = log(parGuess);
                    else
                        objFun = @(x)obj.computeLikelihood(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = (parGuess);
                    end

                    [x0,likelihood]  = mlSearch(objFun,x0,allFitOptions);

                case 'MetropolisHastings'

                    defaultFitOptions.isPropDistSymmetric=true;
                    defaultFitOptions.thin=1;
                    defaultFitOptions.numberOfSamples=1000;
                    defaultFitOptions.burnIn=0;
                    defaultFitOptions.progress=true;
                    defaultFitOptions.proposalDistribution=@(x)x+0.1*randn(size(x));
                    defaultFitOptions.numChains = 1;
                    defaultFitOptions.useFIMforMetHast = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.obj = [];

                    j=1;
                    while exist(['TMPmh_',num2str(j),'.mat'],'file')
                        j=j+1;
                    end
                    defaultFitOptions.saveFile = ['TMPmh_',num2str(j),'.mat'];
                   
                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if isempty(allFitOptions.obj)
                        if allFitOptions.logForm
                            OBJmh = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        else
                            OBJmh = @(x)OBJfun(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        end
                    else
                        if allFitOptions.logForm
                            OBJmh = @(x)allFitOptions.obj(exp(x));
                        else
                            OBJmh = @(x)allFitOptions.obj(x);
                        end
                    end

                    if allFitOptions.logForm
                        x0 = log(parGuess);
                    else
                        x0 = (parGuess);
                    end

                    if allFitOptions.useFIMforMetHast
                        TMP = obj;
                        TMP.solutionScheme = 'fspSens'; % Set solutions scheme to FSP Sensitivity
                        [sensSoln] = TMP.solve;  % Solve the sensitivity problem

                        if allFitOptions.logForm
                            fimResults = TMP.computeFIM(sensSoln.sens,'log');
                        else
                            fimResults = TMP.computeFIM(sensSoln.sens);
                        end
                        
                        % Call function to assemble full FIM from cell
                        % counts and prior covariance information.
                        if allFitOptions.logForm
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.logPriorCovariance);
                        else
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.priorCovariance);                            
                        end

                        FIMfree = FIM{1}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);

                        if allFitOptions.logForm&&min(eig(FIMfree))<1
                            disp('Warning -- FIM has one or more small eigenvalues.  Reducing proposal width to 10x in those directions. MH Convergence may be slow.')
                            FIMfree = FIMfree + 1*eye(length(FIMfree));
                        end

                        covFree = FIMfree^-1;
                        covFree = allFitOptions.CovFIMscale*(covFree+covFree')/2;
                        allFitOptions.proposalDistribution=@(x)mvnrnd(x,covFree);
                    end

                    if allFitOptions.suppressFSPExpansion
                        obj.fspOptions.fspTol = inf;
                    end

                    rng('shuffle')
                    if allFitOptions.numChains==1
                        [otherResults.mhSamples,otherResults.mhAcceptance,otherResults.mhValue,x0,likelihood] = ...
                            ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                            'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,...
                            'symmetric',allFitOptions.isPropDistSymmetric,...
                            'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                            'progress',allFitOptions.progress,...
                            'saveFileName',allFitOptions.saveFile);
                    else
                        try
                            parpool
                        catch
                        end
                        allFitOptions.progress=0;
                        clear tmpMH*
                        parfor iChain = 1:allFitOptions.numChains
                            [mhSamples, mhAcceptance, mhValue,xbest,fbest] = ...
                                ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                                'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,'symmetric',...
                                allFitOptions.isPropDistSymmetric,...
                                'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                                'progress',allFitOptions.progress);
                            tmpMHSamp(iChain) = {mhSamples};
                            tmpMHAcceptance(iChain) = {mhAcceptance};
                            tmpMHValue(iChain) = {mhValue};
                            tmpMHxbest(iChain) = {xbest};
                            tmpMHfbest(iChain) = fbest;
                        end
                        [~,jBest] = max(tmpMHfbest);
                        x0 = tmpMHxbest{jBest}';
                        otherResults.mhSamples = tmpMHSamp;
                        otherResults.mhAcceptance = tmpMHAcceptance;
                        otherResults.mhValue = tmpMHValue;
                        clear tmpMH*
                    end
                    % If fit was in linear space, need to convert to log
                    % space before returning parameters.
                    if ~allFitOptions.logForm
                        pars = log(x0);
                    end

            end

            pars = exp(x0);

            if strcmp(obj.solutionScheme,'FSP')&&allFitOptions.suppressFSPExpansion
                obj.fspOptions.fspTol = tmpFSPtol;
            end

            if nargout>=4
                % Update best parameters set in returned model.
                obj.parameters(obj.fittingOptions.modelVarsToFit,2) = num2cell(pars);
            end


        end

        %% Model Reduction Functions
        function [obj,fspSoln] = computeModelReductionTransformMatrices(obj,fspSoln,phi)
            % This function computes linear transformation matrices (PHI
            % and PHIinv) that can be used to switch between the reduced
            % and origional FSP bases.
            arguments
                obj
                fspSoln = []
                phi = []
            end

            numConstraints = length(obj.fspOptions.bounds);

            if ~isfield(fspSoln,'stateSpace')
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                    % [~,IA] = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                    % stoich = obj.stoichiometry(IA,:);
                    % init = obj.initialCondition(IA,:);
                else
                    stoich = obj.stoichiometry;
                    init = obj.initialCondition;
                end
                fspSoln.stateSpace = ssit.FiniteStateSet(init, stoich);
                fspSoln.stateSpace = fspSoln.stateSpace.expand(obj.fspConstraints.f, obj.fspConstraints.b);

            end

            % Assemble for generator matrix for original FSP problem.
            if ~isfield(fspSoln,'A_total')
                fspSoln.Afsp = ssit.FspMatrix(obj.propensitiesGeneral, [obj.parameters{:,2}]', fspSoln.stateSpace, numConstraints);
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                else
                    fspSoln.A_total = fspSoln.Afsp.createSingleMatrix(obj.tSpan(1), [obj.parameters{:,2}]');
                end
            end

            % Remove FSP Sinks
            fspSoln.A_total = fspSoln.A_total(1:end-numConstraints,1:end-numConstraints);

            % Call function to compute transformation matrices.
            [obj.modelReductionOptions.phi,...
                obj.modelReductionOptions.phi_inv,...
                obj.modelReductionOptions.phiScale,...
                obj.modelReductionOptions.phiPlot,...
                obj.modelReductionOptions.redOutputs] = ...
                ssit.fsp_model_reduction.getTransformMatrices(...
                obj.modelReductionOptions,...
                fspSoln);

            fspSoln.tOut = obj.tSpan;
            obj.modelReductionOptions.fspSoln=fspSoln;

        end

        function redSolutions = solveReducedFSP(obj)
            arguments
                obj
            end

            numConstraints = length(obj.fspOptions.bounds);
            stateCount = obj.modelReductionOptions.fspSoln.stateSpace.getNumStates();
            % Use Approximate steady state as initial distribution if requested.
            if obj.fspOptions.initApproxSS
                jac = obj.modelReductionOptions.fspSoln.A_total;
                jac = jac(1:end-numConstraints,1:end-numConstraints);
                jac = jac+diag(sum(jac));
                try
                    warning('off')
                    [eigVec,~] = eigs(jac,1,'smallestabs');
                catch
                    try
                        [eigVec,~] = eigs(jac,0);
                    catch
                        try
                            eigVec = null(full(jac));
                        catch
                            disp('Could not find null space. Using uniform.')
                            eigVec = ones(size(jac,1),1);
                        end
                    end
                end
                obj.modelReductionOptions.fspSoln.P0 = [eigVec/sum(eigVec);zeros(numConstraints,1)];
            else % otherwise use user supplied IC.
                obj.modelReductionOptions.fspSoln.P0  = zeros(stateCount + numConstraints, 1);
                obj.modelReductionOptions.fspSoln.P0(1:size(obj.initialCondition,2)) = obj.initialProbs;
            end

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 sys = ss(fspSoln.A_total,fspSoln.P0,eye(nStates),[]);
                %                 sysred = balred(sys,n,redOutputs.info);
                %                 A_red = sysred.A;
                %                 q0 = sysred.B;
                %                 OutPutC = sysred.C;
            else
                q0 = obj.modelReductionOptions.phi_inv*obj.modelReductionOptions.fspSoln.P0;
                A_red = obj.modelReductionOptions.phi_inv*...
                    obj.modelReductionOptions.fspSoln.A_total*...
                    obj.modelReductionOptions.phi;
            end

            fspErrorCondition.tInit = obj.modelReductionOptions.fspSoln.tOut(1);
            [~, ~, ~, ~, solutionsNow] = ssit.fsp_ode_solvers.expv_modified(...
                obj.modelReductionOptions.fspSoln.tOut(end), A_red, q0,...
                1e-8, 30,...
                [],...
                obj.modelReductionOptions.fspSoln.tOut,...
                1e-3, [],...
                obj.modelReductionOptions.fspSoln.tOut(1),...
                fspErrorCondition);

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 redSolutionsNow = solutionsNow*OutPutC';
            else
                redSolutionsNow = solutionsNow*obj.modelReductionOptions.phi';
                redSolutionsNow = diag(1./sum(redSolutionsNow,2))*redSolutionsNow;
            end

            for j=size(redSolutionsNow,1):-1:1
                redSolutions.fsp{j} = struct(time=obj.modelReductionOptions.fspSoln.tOut(j),...
                    p=ssit.FspVector(obj.modelReductionOptions.fspSoln.stateSpace.states,...
                    redSolutionsNow(j,1:stateCount)),...
                    sinks=[]);
            end
            redSolutions.stateSpace = obj.modelReductionOptions.fspSoln.stateSpace.states;
        end

        %% Plotting/Visualization Functions
        function makePlot(obj,solution,plotType,indTimes,includePDO,figureNums,...
                lineProps,movieName,maxY,movieSpecies,senseVars,plotTitle)
            %% SSIT.makePlot - Tool to make plot of the FSP or SSA results.
            % Inputs:
            %    * solution - struct with SSIT solutions
            %    * plotType - string, chosen type of plot:
            %       ** FSP options:
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'marginals' - marginal distributions over time
            %            'joints' - joint distributions vs time
            %       ** sensFSP options:
            %            'marginals' - sensitivity of marginal 
            %                          distributions for each parameter 
            %                          and time point
            %       ** SSA options: 
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'trajectories' - set of individual trajectories 
            %                             vs time
            %    * indTimes - 
            %    * includePDO - boolean, include calibrated PDO
            %            default: false
            %    * figureNums - 
            %    * lineProps - 
            %    * movieName -
            %    * maxY - 
            %    * movieSpecies - 
            %    * senseVars - 
            %    * plotTitle - string, title for plot
            %
            % Examples:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [FSPsoln,bounds] = F.solve;  % Returns the solution and the
            %                                % bounds for the FSP projection
            %   F.makePlot(FSPsoln,'marginals')  % Make plot of FSP
            %                                    % marginal distributions
            %
            %   F.solutionScheme = 'fspSens'
            %   [sensSoln,bounds] = F.solve;  % Returns the sensitivity and the
            %                                   bounds for the FSP projection
            %   F.makePlot(sensSoln,'marginals') % Make plot of sensitivities 
            %                                      of marginal distributions
            %                                      at final time
            arguments
                obj
                solution
                plotType = 'means';
                indTimes = [];
                includePDO = false;
                figureNums = [];
                lineProps = {'linewidth',2};
                movieName = 'defaultMovie.mp4'
                maxY = []
                movieSpecies = []
                senseVars = []
                plotTitle = ''
            end
            if isempty(figureNums)
                h =  findobj('type','figure');
                if isfield(h,'Number')
                    figureNums = max([h.Number])+(1:10);
                else
                    figureNums = (1:10);
                end      
            end
            if obj.useHybrid
                specNames = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                specNames = obj.species;
            end

            kfig = 1;
            switch obj.solutionScheme
                case 'FSP'
                    app.FspTabOutputs.solutions = solution.fsp;
                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(app.FspTabOutputs.solutions)
                                app.FspTabOutputs.solutions{i}.p = obj.pdoOptions.PDO.computeObservationDist(app.FspTabOutputs.solutions{i}.p);
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end
                    app.FspPrintTimesField.Value = mat2str(obj.tSpan);
                    solution = exportFSPResults(app);
                    Nd = length(solution.Marginals{end});
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    Nt = length(indTimes);
                    switch plotType
                        case 'means'
                            plot(solution.T_array(indTimes),solution.Means(indTimes,:),lineProps{:});
                        case 'meansAndDevs'
                            fg = figure(figureNums(kfig)); set(0,'CurrentFigure',fg);
                            kfig=kfig+1;
                            for i = 1:Nd
                                subplot(Nd,1,i); hold on
                                errorbar(solution.T_array(indTimes),solution.Means(indTimes,i),sqrt(solution.Var(indTimes,i)),lineProps{:});
                                ylabel(specNames{i})
                            end
                            xlabel('time')
                        case 'marginals'
                            for j = 1:Nd
                                f = figure(figureNums(kfig)); kfig=kfig+1;
                                set(0,'CurrentFigure',f);
                                f.Name = ['Marginal Distributions of ',specNames{j}];
                                Nr = ceil(sqrt(Nt));
                                Nc = ceil(Nt/Nr);
                                for i = 1:Nt
                                    i2 = indTimes(i);
                                    subplot(Nr,Nc,i); hold on
                                    stairs(solution.Marginals{i2}{j},lineProps{:});
                                    set(gca,'fontsize',15)
                                    title(['t = ',num2str(solution.T_array(i2),2)])
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;                           
                            set(f,'Position',[ 1000         980         528         258])
                            
                            if isempty(maxY)
                                maxY = -inf*ones(1,Nd);
                                for j = 1:Nd
                                    for i = 1:Nt
                                        maxY = max(maxY,max(solution.Marginals{i}{j}));
                                    end
                                end
                            end
                            
                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    subplot(1,length(movieSpecies),j); 
                                    bar([0:length(solution.Marginals{i}{movieSpecies(j)})-1],...
                                        solution.Marginals{i}{movieSpecies(j)},lineProps{:});
                                    set(gca,'fontsize',15,'ylim',[0,maxY(movieSpecies(j))])
                                    if isempty(plotTitle)
                                        title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    else
                                        title(sprintf('%s; t = %.0f', plotTitle, solution.T_array(i)))
                                    end
        
                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);

                        case 'joints'
                            if Nd<2
                                error('Joint distributions only avaialble for 2 or more species.')
                            else
                                for j1 = 1:Nd
                                    for j2 = j1+1:Nd
                                        h = figure(figureNums(kfig)); set(0,'CurrentFigure',h); kfig=kfig+1;
                                        h.Name = ['Joint Distribution of ',specNames{j1},' and ',specNames{j2}];
                                        Nr = ceil(sqrt(Nt));
                                        Nc = ceil(Nt/Nr);
                                        for i = 1:Nt
                                            i2 = indTimes(i);
                                            subplot(Nr,Nc,i);
                                            contourf(log10(max(1e-16,solution.Joints{i2}{j1,j2})));
                                            colorbar
                                            title(['t = ',num2str(solution.T_array(i2),2)])
                                            %                                             if mod(i-1,Nc)==0;
                                            ylabel(['x',num2str(j1)]);
                                            %                                             end
                                            %                                             if (i+Nc)>Nt;
                                            xlabel(['x',num2str(j2)]);
                                            %                                             end
                                            set(gca,'FontSize',15)
                                        end
                                    end
                                end
                            end
                        case 'escapeTimes'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            subplot(2,1,1)
                            z = solution.EscapeCDF(indTimes,:);
                            t = solution.T_array(indTimes);
                            plot(t,z,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape CDF')

                            subplot(2,1,2)
                            zp = (z(2:end,:)-z(1:end-1,:))./(t(2:end)-t(1:end-1))';
                            tp = (t(2:end)+t(1:end-1))/2;
                            plot(tp',zp,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape PDF')
                            xlabel('time')
                    end
                case 'SSA'
                    Nd = size(solution.trajs,1);
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    switch plotType
                        case 'trajectories'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            for i=1:Nd
                                subplot(Nd,1,i)
                                plot(solution.T_array(indTimes),squeeze(solution.trajs(i,indTimes,:)));
                            end
                        case 'means'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            plot(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),lineProps{:});
                        case 'meansAndDevs'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            vars = var(solution.trajs(:,indTimes,:),[],3);
                            errorbar(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),sqrt(vars));
                    end
                case 'fspSens'

                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(solution.sens.data)
                                for j=1:length(solution.sens.data{i}.S)

                                    % Make sure defined PDO has sufficient input range.
                                    % tensorSizeSens = size(solution.sens.data{i}.S(j).data);
                                    % for iSp = 1:length(specNames)
                                    %     if tensorSizeSens(iSp)>size(obj.pdoOptions.PDO.conditionalPmfs{iSp},2)
                                    %         obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solution.sens.data,true);
                                    %     end
                                    % end

                                    solution.sens.data{i}.S(j) = obj.pdoOptions.PDO.computeObservationDist(solution.sens.data{i}.S(j));
                                end
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end

                    app.SensFspTabOutputs.solutions = solution.sens;
                    app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = specNames;
                    solution.plotable = exportSensResults(app);

                    Np = size(solution.plotable.sensmdist,1);
                    Nd = size(solution.plotable.sensmdist,2);
                    if isempty(indTimes)
                        if strcmp(plotType,'margmovie')
                            indTimes = solution.plotable.T_array;
                        else
                            indTimes = length(solution.plotable.T_array);
                        end
                    end
                    Nt = length(indTimes);
                    Nr = ceil(sqrt(Np));
                    Nc = ceil(Np/Nr);
                    switch plotType
                        case 'marginals'
                            for it = 1:Nt
                                it2 = indTimes(it);
                                for id = 1:Nd
                                    f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                                    f.Name = ['Marg. Dist. Sensitivities of x',num2str(id),' at t=',num2str(solution.plotable.T_array(it2))];
                                    for j = 1:Np
                                        subplot(Nr,Nc,j); hold on;
                                        stairs(solution.plotable.sensmdist{j,id,it2},lineProps{:});
                                        set(gca,'fontsize',15)
                                        title(obj.parameters{j,1})
                                        %                                         if mod(j-1,Nc)==0;
                                        ylabel(['sensitivity']);
                                        %                                         end
                                        %                                         if (j+Nc)>Np;
                                        xlabel(['x',num2str(id)]);
                                        %                                         end
                                    end
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;
                            set(f,'Position',[ 1000         985         419         253])
                            
                            if isempty(maxY)
                                maxY = [inf*ones(1,Nd);-inf*ones(1,Nd)];
                                for j = 1:Nd
                                    for i = 1:Nt
                                        for k = 1:size(solution.plotable.sensmdist,2)
                                        maxY(1,j) = min(maxY(1,j),min(solution.plotable.sensmdist{k,j,i}));
                                        maxY(2,j) = max(maxY(2,j),max(solution.plotable.sensmdist{k,j,i}));
                                        end
                                    end
                                end
                            end

                            if isempty(senseVars)
                                senseVars = [1:size(obj.parameters,1)];
                            end
                            
                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    for k = 1:length(senseVars)
                                        jPlot = (k-1)*length(movieSpecies)+j;
                                        subplot(length(senseVars),length(movieSpecies),jPlot); 
                                        bar([0:length(solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i})-1],...
                                        solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i},lineProps{:});
                                        set(gca,'fontsize',15,'ylim',[maxY(1,movieSpecies(j)),maxY(2,movieSpecies(j))])
                                        % title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    end
                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);


                    end
            end
        end

        function makeFitPlot(obj,fitSolution,smoothWindow,fignums,usePanels,varianceType,IQRrange)
            % Produces plots to compare model to experimental data.
            arguments
                obj
                fitSolution =[];
                smoothWindow = 1;
                fignums = [];
                usePanels=true;
                varianceType = 'STD';
                IQRrange = 0.25;
            end
            if isempty(fitSolution)     
                [~,~,fitSolution] = obj.computeLikelihood;
            end
            makeSeparatePlotOfData(fitSolution,smoothWindow,fignums,usePanels,varianceType,IQRrange)
        end

        function makeMleFimPlot(obj,MLE,FIM,indPars,CI,figNum,par0)
            arguments
                obj
                MLE = []
                FIM = []
                indPars = [1,2];
                CI = 0.95
                figNum=[]
                par0 = []
            end
            if isempty(figNum)
                f = gcf; set(0,'CurrentFigure',f);
            else
                f = figure(figNum); set(0,'CurrentFigure',f);
            end

            CIp = round(CI*100);

            legs = {};

            if ~isempty(MLE)
                scatter(MLE(indPars(1),:),MLE(indPars(2),:),100*ones(size(MLE(indPars(1),:))),'filled');
                covMLE = cov(MLE');
                muMLE = mean(MLE,2);
                hold on
                ssit.parest.ellipse(muMLE(indPars),icdf('chi2',CI,2)*covMLE(indPars,indPars),'linewidth',3)
                legs(end+1:end+2) = {['MLE, N=',num2str(length(MLE))],[num2str(CIp),'% CI (MLE)']};
                if isempty(par0)
                    par0 = muMLE;
                end
            end

            if ~isempty(FIM)
                covFIM = FIM^(-1);
                ssit.parest.ellipse(par0(indPars),icdf('chi2',CI,2)*covFIM(indPars,indPars),'--','linewidth',3)
                legs(end+1) = {[num2str(CIp),'% CI (FIM)']};
            end
            set(gca,'fontsize',15)
            legend(legs)

        end

        function plotMHResults(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true
            end

            obj.plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig)
        end
    end
    methods (Static)
        function plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence,plotColors)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true;
                plotColors = struct() % Optional: fields like scatter, ellipseFIM, ellipseMH, etc.
            end

            fieldsPropens2Test = {'timeDependentFactor','stateDependentFactor','jointDependentFactor','hybridFactor'};
                            for field = fieldsPropens2Test
                                if ~isempty(obj.propensitiesGeneral{1}.(field{1}))
                                    if ~isa(obj.propensitiesGeneral{1}.(field{1}),'function_handle')
                                        error('Missing Function')
                                    end
                                end
                                % 
                                %     if nargin(obj.propensitiesGeneral{1}.(field{1}))==1
                                %         obj.propensitiesGeneral{1}.(field{1})(0);
                                %     elseif nargin(obj.propensitiesGeneral{1}.(field{1}))==2
                                %         obj.propensitiesGeneral{1}.(field{1})(0,0);
                                %     end
                                % end
                            end

            if isfield(plotColors, 'scatter')
                scatterColor = plotColors.scatter;
            else
                scatterColor = [];
            end

            if isfield(plotColors, 'ellipseFIM')
                ellipseFIMColor = plotColors.ellipseFIM;
            else
                ellipseFIMColor = [];
            end

            if isfield(plotColors, 'ellipseMH')
                ellipseMHColor = plotColors.ellipseMH;
            else
                ellipseMHColor = 'm--';
            end

            if isfield(plotColors, 'marker')
                markerColor = plotColors.marker;
            else
                markerColor = 'k';
            end

            if isempty(obj)
                obj.fittingOptions.modelVarsToFit = 'all';
                obj.parameters(:,2) = num2cell(mean(exp(mhResults.mhSamples)));
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = ones(1,size(obj.parameters,1),'logical');
            end
            parNames = obj.parameters(obj.fittingOptions.modelVarsToFit,1);
            Np = length(parNames);

            if ~isempty(FIM)
                pars = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];

                if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                    parsScaled = log10(pars);
                elseif strcmp(mhPlotScale,'log')
                    parsScaled = log(pars);
                elseif strcmp(mhPlotScale,'lin')
                    parsScaled = pars;
                end

                if ~iscell(FIM)
                    FIM = {FIM};
                end
                %     FIM = diag(pars)*...
                %         FIM(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                %         diag(pars);
                %     covFIM{1} = FIM^(-1)/log(10)^2;
                % else
                for i=1:length(FIM)
                    if isempty(fimScale)||strcmp(fimScale,'lin')
                        FIMi = diag(pars)*...
                            FIM{i}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                            diag(pars);
                    else
                        FIMi = FIM{i};
                    end
                    FIMi = FIMi(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);
                    if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                        covFIM{i} = FIMi^(-1)/log(10)^2;
                    else
                        covFIM{i} = FIMi^(-1);
                    end
                end
                % end
            end

            if ~isempty(mhResults)
                % Make figures for MH convergence
                if showConvergence
                    fg = figure; set(0,'CurrentFigure',fg)
                    plot(mhResults.mhValue);
                    xlabel('Iteration number');
                    ylabel('log-likelihood')
                    title('MH Convergence')

                    fg = figure; set(0,'CurrentFigure',fg)
                    ac = xcorr(mhResults.mhValue-mean(mhResults.mhValue),'normalized');
                    ac = ac(size(mhResults.mhValue,1):end);
                    plot(ac,'LineWidth',3); hold on 
                    N = size(mhResults.mhValue,1);
                    tau = 1+2*sum((ac(2:N/100)));
                    Neff = N/tau;
                    xlabel('Lag');
                    ylabel('Auto-correlation')
                    title('MH Convergence')
                end

                if isempty(scatterFig)
                    fg = figure; set(0,'CurrentFigure',fg);
                else
                    fg = figure(scatterFig); set(0,'CurrentFigure',fg)
                end


                % Select second half of MH chain.
                mhResultsSecondHalf = mhResults;
                mhResultsSecondHalf.mhValue = mhResultsSecondHalf.mhValue(floor(end/2):end);
                mhResultsSecondHalf.mhSamples = mhResultsSecondHalf.mhSamples(floor(end/2):end,:);
                [valDoneSorted,J] = sort(mhResultsSecondHalf.mhValue);
                smplDone = mhResultsSecondHalf.mhSamples(J,:);

                % Compute and display parameter means and standard deviations
                mhMeans = mean(smplDone) / log(10);   % log10 scale
                mhStds  = std(smplDone) / log(10);

                fprintf('\nMH sample means and standard deviations (log10 scale):\n');
                for p = 1:Np
                    fprintf('%15s: mean = % .4f, std = %.4f\n', parNames{p}, mhMeans(p), mhStds(p));
                end

            end

            fimCols = {'k','c','b','g','r'};

            for i=1:Np-1
                for j = i+1:Np
                    subplot(Np-1,Np-1,(i-1)*(Np-1)+j-1);

                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        scatter(smplDone(:,j)/log(10),smplDone(:,i)/log(10),20,valDoneSorted,'filled'); hold on;
                        par0 = mean(smplDone(:,[j,i])/log(10));
                        cov12 = cov(smplDone(:,j)/log(10),smplDone(:,i)/log(10));
                    end
                    if ~isempty(FIM)
                        for iFIM = 1:length(covFIM)
                            ssit.parest.ellipse(parsScaled([j,i]),icdf('chi2',0.9,2)*covFIM{iFIM}([j,i],[j,i]),fimCols{mod(iFIM,5)+1},'linewidth',2); hold on;
                            plot(parsScaled(j),parsScaled(i),'ks','MarkerSize',15)
                            % plot(smplDone(end,j)/log(10),smplDone(end,i)/log(10),'cs','MarkerSize',15)
                        end
                    end
                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        ssit.parest.ellipse(par0,icdf('chi2',0.9,2)*cov12,'m--','linewidth',2);  hold on;
                        % Draw crosshairs at MH mean ± std
                        % plot([mhMeans(j)-mhStds(j), mhMeans(j)+mhStds(j)], [mhMeans(i), mhMeans(i)], 'm-', 'LineWidth', 1.5);
                        % plot([mhMeans(j), mhMeans(j)], [mhMeans(i)-mhStds(i), mhMeans(i)+mhStds(i)], 'm-', 'LineWidth', 1.5);
                        % 
                        % % Annotate mean location
                        % text(mhMeans(j), mhMeans(i), sprintf('\\leftarrow Mean'), 'Color', 'm', 'FontSize', 8, 'HorizontalAlignment', 'left');

                    end
                    xlabel(['log_{10}(',parNames{j},')']);
                    ylabel(['log_{10}(',parNames{i},')']);
                end
            end
        end
        function FIM = totalFim(fims,Nc,covPrior)
            arguments
                fims
                Nc
                covPrior = [];
            end
            if isempty(covPrior)
                fimPrior = zeros(size(fims{1}));
            else
                fimPrior = inv(covPrior);
            end
            Nt = size(fims,1);
            Ns = size(fims,2);
            FIM = cell(1,Ns);
            for is = 1:Ns
                FIM{is} = fimPrior;
                for it = 1:Nt
                    FIM{is} = FIM{is}+Nc(it)*fims{it,is};
                end
            end
        end
        function k = findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd)
            arguments
                fims
                Ncp
                met
                NcMax = []
                statistic='mean'
                covPrior=[]
                incrementAdd=1
            end
            if isempty(statistic)
                statistic='mean';
            end
            Nt = size(fims,1);
            if isempty(NcMax)
                NcMax = inf*ones(1,Nt);
            end
            Ns = size(fims,2);
            objFun = zeros(Nt,Ns);
            FIM0 = SSIT.totalFim(fims,Ncp,covPrior);
            for is = 1:Ns
                for it = 1:Nt
                    if Ncp(it)+incrementAdd<=NcMax(it)
                        % If one can do that experiment.
                        FIM = FIM0{is}+incrementAdd*fims{it,is};
                    else
                        % If there are no more cells avalable for that time
                        % point.
                        FIM = FIM0{is};
                    end
                    objFun(it,is) = met(FIM);
                end
            end
            switch statistic
                case 'median'
                    [~,k] = min(median(objFun,2));
                case 'mean'
                    [~,k] = min(mean(objFun,2));
                otherwise
                    [~,k] = min(median(objFun,2));
            end
        end
        function propensities = parameterizePropensities(GenProps,Parset)
            propensities = GenProps;
            for i=1:length(GenProps)
                if ~isempty(propensities{i}.stateDependentFactor)
                    propensities{i}.stateDependentFactor = @(x)GenProps{i}.stateDependentFactor(x,Parset);
                end
                if ~isempty(propensities{i}.hybridFactor)
                    propensities{i}.hybridFactor = @(t,v)GenProps{i}.hybridFactor(t,Parset,v');
                end
                if ~isempty(propensities{i}.hybridFactorVector)
                    propensities{i}.hybridFactorVector = @(t,v)GenProps{i}.hybridFactorVector(t,Parset,v');
                end
                if ~isempty(propensities{i}.timeDependentFactor)
                    propensities{i}.timeDependentFactor = @(t)GenProps{i}.timeDependentFactor(t,Parset);
                end
                if ~isempty(propensities{i}.hybridJointFactor)
                    propensities{i}.hybridJointFactor = @(t,x,v)GenProps{i}.hybridJointFactor(t,x,Parset,v');
                end
            end
        end
        function str = replaceSpeciesNames(str,species)
            % Check if species are named 'x1','x2', etc, and if not, find
            % order of species names longest to shortest. 
            namedXi = true;
            Len = NaN*ones(length(species));
            for i = 1:length(species)
                Len(i) = length(species{i});
                if ~strcmp(species{i},['x',num2str(i)])
                    namedXi = false;
                end
            end
            if namedXi % No need to change string.
                return
            end

            [~,order] = sort(Len,'descend');
            for i = 1:length(order)
                str = strrep(str,species{order(i)},['x',num2str(i)]);
            end

        end
    end
end
