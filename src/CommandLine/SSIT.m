classdef SSIT
    %% Create an instance of the SSIT class, example:  Model = SSIT;
    %
    % The SSIT allows users to specify and efficiently solve the chemical
    % master equation for discrete stochastic models.  SSIT is especially
    % useful for the analysis of single-cell gene regulaton. Functionality
    % includes:
    %   * Build, save, and load models defined by their species, parameters,
    %     propensity functions, stoichiometries, and initial conditions
    %       ** Models can be non-linear and have time-varying propensity
    %          functions (e.g., inputs), including logical statements
    %   * Load from / export to SimBiology
    %   * Load from / export to SBML
    %   * Solve models using:
    %       ** ODE analyses and basic moment closure analyses
    %       ** Stochastic trajectories generated by Gillepsie's
    %          Stochastic Simulation Algorithm (SSA)
    %       ** Finite State Projection (FSP)
    %       ** Hybrid solutions (deterministically + stochastically treated
    %          species population changes through time)
    %       ** Reduced order models (Model Reduction) by:
    %           *** Reduce models using Quasi-Steady State Approximations
    %               (QSSA) on fast species
    %           *** Reduce models using eigenvalue decomposition
    %           *** Reduce models using coarse meshes
    %           *** Reduce models using principle orthogonal decomposition
    %       ** SSITMultiModel to create multiple models associated with
    %          different data sets with shared parameter sets
    %   * Generate synthetic data from models using SSA
    %   * Compute sensitivity of solutions to parameter variations
    %   * Compute the Fisher Information Matrix to determine the amount of
    %     parameter information available from the chosen experiment
    %   * Compute first passage or escape time distributions for complex
    %     trajectories
    %   * Load and fit experimental data (e.g., spot counts or total
    %     intensity measurements from smFISH images or flow cytometry)
    %   * Compute the likelihood of the data given model
    %   * Maximize the likelihood using gradient and non-gradient based
    %     searches
    %   * Sample parameter uncertainty using the Metropolis-Hastings
    %     algorithm (with custom proposal distributions or
    %     proposal distributions based on Fisher Information)
    %   * Include custom priors on parameter distributions for Bayesian
    %     analysis
    %   * Model and account for experimental, measurement, and data
    %     processing noise
    %       ** Explore effects of extrinsic noise in parameters
    %       ** Calibrate empirical probability distortion operators (PDO)
    %          to quantify effects of data distortion
    %       ** Include data distortion corrections in parameter estimation
    %   * Inform and improve upon iterative experiment designs by searching
    %     an experiment design space for optimally informative experiments
    %       ** Utilize the FSP-FIM approach to compare the amount of
    %          information gainable by each potential next experiment
    %       ** Analyze possible next experiments using Bayesian sequential
    %          experiment design
    %       ** Automatically adjust designs to account for data distortion
    %          effects (allowing for informative cheaper, faster
    %          experiments)
    %   * Identify parameters that change with
    %     genetic / environmental / experimental conditions

    properties
        % List of parameters and their values, default: {'k',10; 'g',0.2};
        parameters = {'k',10; 'g',0.2};
        % List of species to be used in model, default: {'x1'};
        species = {'x1'};
        % Matrix of stoichiometric updates applied to each species given
        % each reaction, with species as rows and reactions as columns
        %   default: [1,-1];
        %   example: Model.stoichiometry = [-1,1,0,0;...
        %                                    1,-1,0,0;...
        %                                    0,0,1,-1];
        stoichiometry = [1,-1];
        % List of propensity functions, default: {'k'; 'g*x1'}
        propensityFunctions = {'k'; 'g*x1'}
        % List of time-varying input signals
        %   default: {};
        %   example:  Model.inputExpressions = ...
        %             {'Drug','(a0+a1*exp(-r1*t)*(1-exp(-r2*t))*(t>0))'};
        inputExpressions = {};
        % Struct containing user-supplied constraint functions for FSP
        %   default: {};
        %   example: Model.customConstraintFuns = {'offGene+onGene'};
        customConstraintFuns = {};
        % Options for FSP solver
        %    defaults:
        %       'fspTol',0.001
        %       'fspIntegratorRelTol',1e-2
        %       'fspIntegratorAbsTol',1e-4
        %       'odeSolver','auto'
        %       'verbose',false
        %       'bounds',[]
        %       'usePiecewiseFSP',false
        %       'initApproxSS',false
        %       'escapeSinks',[]
        %       'constantJacobian',false
        %       'constantJacobianTime',1.1
        fspOptions = struct('fspTol',0.001,'fspIntegratorRelTol',1e-2,...
            'fspIntegratorAbsTol',1e-4, 'odeSolver','auto',...
            'verbose',false,'bounds',[],'usePiecewiseFSP',false,...
            'initApproxSS',false,'escapeSinks',[],...
            'constantJacobian',false,'constantJacobianTime',1.1,'stateSpace',[]);
        % Options for FSP-Sensitivity solver
        %   defaults:
        %       'solutionMethod','finiteDifference'
        %       'useParallel',true
        %   example: Model.sensOptions.solutionMethod = 'finiteDifference';
        sensOptions = struct('solutionMethod','finiteDifference',...
            'useParallel',true);
        % Options for SSA solver
        %   defaults:
        %       'Nsims',1000
        %       'Nexp',1
        %       'nSimsPerExpt',NaN
        %       'useTimeVar',false
        %       'signalUpdateRate',[]
        %       'useParallel',false
        %       'useGPU',false
        %       'verbose',false
        ssaOptions = struct('Nsims',1000,'Nexp',1,'nSimsPerExpt',NaN,...
            'useTimeVar',false,'signalUpdateRate',[],...
            'useParallel',false,'verbose',false,...
            'useGPU',false);
        % Options for PDO
        %   defaults:
        %       'unobservedSpecies',[]
        %       'PDO',[]
        pdoOptions = struct('unobservedSpecies',[],'PDO',[]);
        % Options for FIM analyses
        %   defaults:
        %       'modelVarsToFit','all'
        %       'pdoVarsToFit',[]
        %       'timesToFit','all'
        %       'logPrior',[]
        %       'logPriorCovariance',[]
        %       'priorCovariance',[]
        fittingOptions = struct('modelVarsToFit','all',...
            'pdoVarsToFit',[],'timesToFit','all','logPrior',[],...
            'logPriorCovariance',[],'priorCovariance',[])
        % Initial population size of each species, default: [0];
        initialCondition = [0];
        % Probability mass of states given in initialCondition, default: 1
        initialProbs = 1;
        % Initial time, default: 0;
        initialTime = 0;
        % Times at which to find solutions, default: linspace(0,10,21);
        tSpan = linspace(0,10,21);
        % Chosen solution scheme ('FSP','SSA','ode'), default: 'FSP'
        solutionScheme = 'FSP'
        % Chosen sets of solution schemes to get and store (choose members
        % from ('FSP','SSA','ode').  Default is empty.
        odeIntegrator = 'ode23s'
        % Chosen integrator for ODEs {'ode23s' (default), 'ode15s', 'ode45'}.
        solutionSchemes = {};
        % Settings for model reduction tools
        %   defaults:
        %       'useModReduction',false
        %       'reductionType','None'
        modelReductionOptions = struct('useModReduction',false,...
            'reductionType','None')
        % Set data, default: [];
        dataSet = [];
        % Option to use hybrid model (deterministic + stochastic species)
        %   default: false
        useHybrid = false
        % Struct to define which species of the hybrid model will be
        % modelled using ODEs
        %   default: struct('upstreamODEs',[]);
        %   example: Model.hybridOptions.upstreamODEs = {'offGene','onGene'};
        hybridOptions = struct('upstreamODEs',[]);
        % Processed propensity functions for use in SSIt/FSP solvers,
        % default: [];
        propensitiesGeneral = [];
        % Processed propensity functions for use in ODE solver,
        % default: [];
        propensitiesGeneralODE = [];
        propensitiesGeneralMean = [];
        propensitiesGeneralMeanJac = [];
        propensitiesGeneralMoments = [];
        propensitiesGeneralMomentsJac

        % Solutions
        Solutions = []; % Field holding solutions for current model and
        %                 parameter combinations

        % Model description
        description = {'Add model description here'};
        GUIProps = [];  % Structure to hold GUI information for faster loading and saving.
    end

    properties (Dependent)
        fspConstraints % FSP Constraint Functions
        pars_container % Container for parameters
    end

    methods
        function [obj,MultiModelObj] = SSIT(modelFile,modelName,dataSettings,pipeline,pipelineArgs,saveName)
            %% SSIT - Create an instance of the SSIT class.
            %
            % The SSIT purpose is to allow users to specify and efficiently
            % solve the chemical master equation for discrete stochastic
            % models.
            %
            % SSIT models can be generated through several options
            % depending on content of input 'modelFile'.
            %
            %% Inputs:
            %%   modelFile (string, optional) -- Create from saved file or
            %      from specified template.
            %      {'[NAME].mat',   % Load SSIT Model from file [NAME].mat
            %       'BirthDeath',    % 1 species pre-formatted example (default)
            %       'CentralDogma',  % 2 species pre-formatted example
            %       'ToggleSwitch',  % 2 species pre-formatted example
            %       'Repressilator', % 3 species pre-formatted example
            %       'BurstingSpatialCentralDogma'}  % 4 species pre-formatted example
            %
            %%   modelName (string, optional) -- Name of model within
            %       modelFile. This is needed in cases where the modelFile
            %       .mat contains multiple variables.
            %
            %%   dataSettings (Cell array, optional) -- Settings for loading data
            %       This is a cell array. For SSIT models, this will should
            %       be a {1x3} cell with the structure:
            %       dataSettings = {dataFileName,linkedSpecies,conditions}.
            %       See method 'SSIT.loadData' for interpretation of these
            %       inputs.
            %       For MultiModels, there should be one row of these
            %       variables for each of the sub-models.
            %
            %%   pipeline (string, optional) -- Name of an executable matlab
            %       function that will be run to analyse the created model.
            %       The arguments of the function are (Model, ARGS), where
            %       ARGS is a cell structure containing all remaining
            %       arguments expected by the function.
            %
            %%   pipelineArgs (Struct, optional) --
            %       Structure containing any optional arguments needed for
            %       the pipeline to run.
            %
            %%   saveName - (String, optional) -- name of file to save results
            %       of pipeline.
            %
            %% Example Usage:
            %% Example 1 - Pre-formatted model for central dogma:
            %   Mod = SSIT('CentralDogma'); % Load preset model for
            %                               % transcription and translation
            %
            %% Example 2 - Load existing model 'ExampleSSITModel.mat':
            %   Mod = SSIT('preGeneratedModels/savedRepressilatorModel');
            %      % Load saved model.
            %
            %% Example 3 - Load Model and Add Data
            %   Mod = SSIT('BirthDeath',[],{'data/STL1.csv',{'mRNA','rna'}})
            %      % Load preset model 'CentralDogma' and associate the
            %
            %% Example 4 - Load Model, Add Data and Run Pipeline Routine
            %   DataSettings = {'data/STL1.csv',{'mRNA','rna'}};
            %   Pipeline = 'fittingPipelineExample';
            %   pipelineArgs.maxIter = 20;
            %   pipelineArgs.display = 'iter';
            %   saveFile = 'exampleResults.mat';
            %
            %   % Create model from preset, associate with data, run
            %   % 'fittingPipeline', and save result.
            %   SSIT('BirthDeath','Model',DataSettings,Pipeline,pipelineArgs,saveFile);
            %
            %   % Load model from file, run 'fittingPipeline', and save result.
            %   SSIT(saveFile,'Model',[],Pipeline,pipelineArgs,saveFile);

            arguments
                modelFile = []   % Name of file where SSIT Model/MultiModel has been saved. Must be a '.mat'.
                modelName = []   % Name of the SSIT Model/MultiModel within the above file.
                dataSettings = {}% Data Settings to load into Model/MultiModel.
                pipeline = []    % Pipeline (matlab script) to run on model.
                pipelineArgs = []% Pipeline arguments (matlab structure).
                saveName = []    % File name to save model after it has been generated.
            end

            % SSIT Construct an instance of the SSIT class
            addpath(genpath('../src'));
            if ~isempty(modelFile)
                if length(modelFile)>4 && (strcmp(modelFile(end-3:end),'.mat')||exist([modelFile,'.mat'],"file"))
                    % Load existing model from .mat file.
                    try
                        if ~isempty(modelName)
                            TMP = load(modelFile,modelName);
                            if isa(TMP.(modelName),'SSIT')
                                obj = TMP.(modelName);
                                disp(['Successfully loaded SSIT Model ',modelName])
                            elseif isa(TMP.(modelName),'SSITMultiModel')
                                MultiModelObj = TMP.(modelName);
                                obj = MultiModelObj.SSITModels{1};
                                disp(['Successfully loaded a CombinedModel ',modelName, ' and extracted first model.'])
                            end
                        else
                            TMP = load(modelFile);
                            fnames = fieldnames(TMP);
                            for i=1:length(fnames)
                                if isa(TMP.(fnames{i}),'SSIT')
                                    obj = TMP.(fnames{i});
                                    disp(['Successfully loaded SSIT Model named "',fnames{i},'" from "',modelFile,'"'])
                                    modelName = fnames{i};
                                    break
                                elseif isa(TMP.(fnames(i)),'SSITMultiModel')
                                    MultiModelObj = TMP.(fnames{i});
                                    obj = MultiModelObj.SSITModels{1};
                                    disp(['Successfully loaded a CombinedModel  named "',fnames{i},'" and extracted first model.'])
                                    modelName = fnames{i};
                                    break
                                end
                            end
                        end
                    catch
                        disp(['Could not load model from ',modelFile])
                        disp('Check that file exists and that it contains only the SSIT model of interest')
                        disp('Use the optional argument "modelName" to specify which model to load.')
                    end

                    % Test to see if propensity functions are available. If
                    % not, create them.
                    if ~isempty(obj.propensitiesGeneral)
                        try
                            fieldsPropens2Test = {'timeDependentFactor','stateDependentFactor','jointDependentFactor','hybridFactor'};
                            for field = fieldsPropens2Test
                                if ~isempty(obj.propensitiesGeneral{1}.(field{1}))
                                    if ~isa(obj.propensitiesGeneral{1}.(field{1}),'function_handle')
                                        error('Missing Function')
                                    end
                                end
                                %
                                %     if nargin(obj.propensitiesGeneral{1}.(field{1}))==1
                                %         obj.propensitiesGeneral{1}.(field{1})(0);
                                %     elseif nargin(obj.propensitiesGeneral{1}.(field{1}))==2
                                %         obj.propensitiesGeneral{1}.(field{1})(0,0);
                                %     end
                                % end
                            end
                        catch
                            disp(['Propensity functions are missing -- regenerating now with name: ',modelName])
                            obj = obj.formPropensitiesGeneral(modelName);
                        end
                    end
                else
                    % Create model from template
                    obj = pregenModel(obj,modelFile);
                    if ~strcmp(modelFile,'Empty')
                        obj = obj.formPropensitiesGeneral(modelFile);
                    end
                end
            end

            % Load Data if provided
            if ~isempty(dataSettings)
                if size(dataSettings,2)<3
                    dataSettings{1,3} = {};
                end
                if exist('MultiModelObj','var')
                    nModels = length(MultiModelObj.SSITModels);
                    for iModel = 1:nModels
                        MultiModelObj.SSITModels{iModel} =  MultiModelObj.SSITModels{iModel}.loadData( ...
                            dataSettings{iModel,1},dataSettings{iModel,2},dataSettings{iModel,3});
                    end
                else
                    obj = obj.loadData(dataSettings{1,1},dataSettings{1,2},dataSettings{1,3});
                end

            end

            if ~isempty(pipeline)
                if strcmp(pipeline(end-1:end),'.m')
                    pipeline=pipeline(1:end-2);
                end
                fun = str2func(pipeline);
                if exist('MultiModelObj','var')
                    [outputs,MultiModelObj] = fun(MultiModelObj,pipelineArgs);
                    obj = MultiModelObj.SSITModels{1};
                else
                    [outputs,obj] = fun(obj,pipelineArgs);
                end
                disp(['Pipeline "',pipeline,'" run successfully.'])
            end

            if ~isempty(saveName)
                if exist('MultiModelObj','var')
                    if ~isempty(modelName)
                        eval([modelName,'=MultiModelObj;']);
                        save(saveName,"outputs",modelName)
                    else
                        save(saveName,"outputs",'MultiModelObj')
                    end
                    obj = MultiModelObj.SSITModels{1};
                else

                    if ~isempty(modelName)
                        eval([modelName,'=obj;']);
                        save(saveName,"outputs",modelName)
                    else
                        ModelObj = obj;
                        save(saveName,'outputs','ModelObj')
                    end
                end

                % if exist("combinedModel","var")
                %     outputs = executeRoutine(ModelObj);
                %     ModelObj=outputs.model;
                % eval([modelName,'=outputs.model.SSITModels{1};']);
                % /save(saveName,"outputs",modelName,'ModelObj')
                % else
                %     outputs = executeRoutine(obj);
                % eval([modelName,'=ModelObj;']);
                % save(saveName,"outputs",modelName)
                % end
            end

        end

        function Pars_container = get.pars_container(obj)
            if ~isempty(obj.parameters)
                Pars_container = containers.Map(obj.parameters(:,1), obj.parameters(:,2));
            else
                Pars_container =[];
            end
        end

        function obj = formPropensitiesGeneral(obj,prefixName,computeSens)
            %% SSIT.formPropensitiesGeneral - Create callable functions
            %% for all propensity functions.
            %
            % This function compiles and stores the given reaction
            % propensities into symbolic expression functions that use
            % sparse matrices to operate on the system based on the current
            % state. The functions are stored with the given prefix, e.g.,
            % 'Model_1'
            %
            % Inputs:
            %    * obj - SELF
            %    * prefixName - (string) the prefix name used to name the
            %                   saved propensity functions
            %                   default: 'default'
            %    * computeSens - (logical) indicates whether derivatives
            %                    are calculated for use in sensitivity
            %                    analysis
            %                    default: true
            %
            % Outputs: Model, callable symbolic expression functions
            %
            % Example: Model = Model.formPropensitiesGeneral('Model_1')
            arguments
                obj
                prefixName = 'default';
                computeSens = true;
            end
            % This function starts the process to write m-file for each
            % propensity function.

            if ~exist([pwd,'/tmpPropensityFunctions'],'dir')
                mkdir([pwd,'/tmpPropensityFunctions'])
            end
            addpath([pwd,'/tmpPropensityFunctions'])

            if strcmpi(obj.solutionScheme,'ode')
                delete([pwd,'/tmpPropensityFunctions/',prefixName,'_mean'],...
                    [pwd,'/tmpPropensityFunctions/',prefixName,'_mean_jac'])
                clear([prefixName,'_mean'],[prefixName,'_mean_jac']);
                momentOdeFileName = [pwd,'/tmpPropensityFunctions/',prefixName,'_mean'];
                try
                    jacCreated = ssit.moments.writeFunForMomentsODESymb(obj.stoichiometry,...
                        obj.propensityFunctions,...
                        obj.species,...
                        obj.parameters(:,1),...
                        momentOdeFileName, ...
                        false,...
                        obj.inputExpressions, ...
                        [momentOdeFileName,'_jac']);
                    obj.propensitiesGeneralMean = eval(['@(t,v,pars)',prefixName,'_mean(t,v,pars)']);
                    if jacCreated
                        obj.propensitiesGeneralMeanJac = eval(['@(t,v,pars)',prefixName,'_mean_jac(t,v,pars)']);
                    else
                        obj.propensitiesGeneralMeanJac = [];
                    end
                catch
                    disp('Could not write ODE equations (possibly due to incompatible logical functions in propensities).')
                end
                return
            elseif strcmpi(obj.solutionScheme,'moments')||strcmpi(obj.solutionScheme,'gaussian')
                delete([pwd,'/tmpPropensityFunctions/',prefixName,'_momentsgaussian'],...
                    [pwd,'/tmpPropensityFunctions/',prefixName,'_momentsgaussian_jac'])
                clear([prefixName,'_momentsgaussian'],[prefixName,'_momentsgaussian_jac']);
                try
                    momentOdeFileName = [pwd,'/tmpPropensityFunctions/',prefixName,'_momentsgaussian'];
                    jacCreated = ssit.moments.writeFunForMomentsODESymb(obj.stoichiometry,...
                        obj.propensityFunctions,...
                        obj.species,...
                        obj.parameters(:,1),...
                        momentOdeFileName, ...
                        true,...
                        obj.inputExpressions,...
                        [momentOdeFileName,'_jac']);
                    obj.propensitiesGeneralMoments = eval(['@(t,v,pars)',prefixName,'_momentsgaussian(t,v,pars)']);
                    if jacCreated
                        obj.propensitiesGeneralMomentsJac = eval(['@(t,v,pars)',prefixName,'_momentsgaussian_jac(t,v,pars)']);
                    else
                        obj.propensitiesGeneralMomentsJac = [];
                    end
                catch
                    disp('Could not write moments equations (possibly due to incompatible logical functions in propensities).')
                end
                return
            end

            delete([pwd,'/tmpPropensityFunctions/',prefixName,'_fsp*'])
            clear([prefixName,'_fsp*'])

            n_reactions = length(obj.propensityFunctions);
            % Propensity for hybrid models will include
            % solutions from the upstream ODEs.
            sm = cell(1,n_reactions);
            logicTerms = cell(1,n_reactions);
            logCounter = 0;
            for i = 1:n_reactions
                st = obj.propensityFunctions{i};
                for jI = 1:size(obj.inputExpressions,1)
                    st = regexprep(st,['\<',obj.inputExpressions{jI,1},'\>'],['(',obj.inputExpressions{jI,2},')']);
                end
                [st,logicTerms{i},logCounter] = ssit.Propensity.stripLogicals(st,obj.species,logCounter);
                
                % Detect variables automatically
                vars = symvar(st);    
                % Create symbolic variables and assume they are real
                for k = 1:numel(vars)
                    syms(vars{k},'real')
                end

                % Convert the string into a symbolic expression
                sm{i} = str2sym(st);
            end

            % if ~strcmp(obj.solutionScheme,'ode')||~ismember('ode',obj.solutionSchemes)
            if obj.useHybrid
                PropensitiesGeneral = ...
                    ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                    obj.parameters, obj.species, obj.hybridOptions.upstreamODEs,...
                    logicTerms, [prefixName,'_fsp'], computeSens);
            else
                PropensitiesGeneral = ...
                    ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                    obj.parameters, obj.species, [], logicTerms, [prefixName,'_fsp'], computeSens);
            end
            % else
            %     PropensitiesGeneral = [];
            % end

            try
                delete([pwd,'/tmpPropensityFunctions/',prefixName,'_ODE*'])
                objODE = obj;
                objODE.solutionScheme='ode';
                objODE.solutionSchemes = {};
                objODE.useHybrid = true;
                objODE.hybridOptions.upstreamODEs = obj.species;
                obj.propensitiesGeneralODE = ...
                    ssit.Propensity.createAsHybridVec(sm, objODE.stoichiometry,...
                    objODE.parameters, objODE.species, objODE.hybridOptions.upstreamODEs,...
                    logicTerms, [prefixName,'_ODE'], computeSens);
            catch
                disp('ODE propensities could not be formed, potentially due to logical values')
            end

            obj.propensitiesGeneral = PropensitiesGeneral;
        end
        %%
        function constraints = get.fspConstraints(obj)
            % Makes a list of FSP constraints that can be used by the FSP
            % solver.
            if obj.useHybrid
                stochasticSpecies = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                stochasticSpecies = obj.species;
            end

            nSpecies = length(stochasticSpecies);
            Data = cell(nSpecies*2,3);
            for i = 1:nSpecies
                Data(i,:) = {['-x',num2str(i)],'<',0};
                Data(nSpecies+i,:) = {['x',num2str(i)],'<',1};
            end

            % Add custom constraints into the FSP state space
            % determination.
            if ~isempty(obj.customConstraintFuns)
                [~,J] = sort(cellfun('length',stochasticSpecies),'descend');
                for i = 1:length(obj.customConstraintFuns)
                    constraintStr = SSIT.replaceSpeciesNames(obj.customConstraintFuns{i},stochasticSpecies);
                    Data(2*nSpecies+i,:) = {constraintStr,'<',1};
                end
            end
            constraints.f = readConstraintsForAdaptiveFsp([], stochasticSpecies, Data);
            if isempty(obj.fspOptions.bounds)||size(Data,1)~=length(obj.fspOptions.bounds)
                constraints.b = [Data{:,3}]';
                obj.fspOptions.bounds = constraints.b;
            else
                constraints.b = obj.fspOptions.bounds;
            end

            % Define polynomial constraints for first passage time sinks
            % (i.e., states corresponding to boundaries that we are trying
            % to calculate the escape times toward).
            if ~isempty(obj.fspOptions.escapeSinks)
                nEscape = length(obj.fspOptions.escapeSinks.f);
                escapeData = cell(nEscape,3);
                for i = 1:nEscape
                    constraintStr = SSIT.replaceSpeciesNames(obj.fspOptions.escapeSinks.f{i},obj.species);
                    escapeData(i,:) = {constraintStr,'<',1};
                end
                constraints.fEscape = readConstraintsForAdaptiveFsp([], stochasticSpecies, escapeData);
                constraints.bEscape = obj.fspOptions.escapeSinks.b;
            else
                constraints.fEscape = [];
                constraints.bEscape = [];
            end
        end

        function plotStatespace(obj,showPoints,showLines,pointMarker)
            % This function makes a plot of the FSP state space based on
            % the supplied constatint functions and the current bounds.
            % Plots are only made for 2D and 3D problems.
            %
            % Inputs:
            %   showPoints (true) -- show states as points in plots.
            %   showLines (true) -- show constraints as lines/surfaces in plots.
            %   pointMarker ('o') -- marker type ('o','+','x','s',etc) for
            %                       state points
            %
            % 3D Example:
            %   Model = SSIT('Repressilator');  % Load pre-made model.
            %   [~,~,Model] = Model.solve;      % Solve to get FSP projection
            %   RepGenes_Model.plotStatespace(true,true,'s'); % Make plot of FSP projection statespace.
            %
            % 2D Example:
            %   Model = SSIT('ToggleSwitch');  % Load pre-made model.
            %   [~,~,Model] = Model.solve;     % Solve to get FSP projection
            %   RepGenes_Model.plotStatespace(true,true,'s'); % Make plot of FSP projection statespace.

            arguments
                obj
                showPoints = true;
                showLines = true;
                pointMarker = 'o'
            end

            map = colormap(jet(length(obj.fspOptions.bounds)+1));

            switch length(obj.species)
                case 2
                    figure;
                    legs = {};
                    if isfield(obj.fspOptions,'stateSpace')&&showPoints
                        scatter(obj.fspOptions.stateSpace.states(1,:)',...
                            obj.fspOptions.stateSpace.states(2,:)',pointMarker);
                        hold on;
                        legs = {'FSP states'};
                    end
                    if showLines
                        fimplicit(@(x,y)(-x-obj.fspOptions.bounds(1)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(-y-obj.fspOptions.bounds(2)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(x-obj.fspOptions.bounds(3)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(y-obj.fspOptions.bounds(4)),'linewidth',2);hold on;
                        legs = [legs,{[obj.species{1},'>=',num2str(-obj.fspOptions.bounds(1))]}];
                        legs = [legs,{[obj.species{2},'>=',num2str(-obj.fspOptions.bounds(2))]}];
                        legs = [legs,{[obj.species{1},'<=',num2str(obj.fspOptions.bounds(3))]}];
                        legs = [legs,{[obj.species{2},'<=',num2str(obj.fspOptions.bounds(4))]}];
                        for i = 1:length(obj.customConstraintFuns)
                            str = ['@(',obj.species{1},',',obj.species{2},')',obj.customConstraintFuns{i},'-',num2str(obj.fspOptions.bounds(4+i))];
                            fun = eval(str);
                            fimplicit(fun,'linewidth',2);hold on;
                            legs = [legs,{[obj.customConstraintFuns{i},'<=',num2str(obj.fspOptions.bounds(i+4))]}];
                        end
                    end
                    set(gca,'xlim',[obj.fspOptions.bounds(1)-1,obj.fspOptions.bounds(3)*1.1]);
                    set(gca,'ylim',[obj.fspOptions.bounds(2)-1,obj.fspOptions.bounds(4)*1.1]);
                    xlabel(obj.species{1});
                    ylabel(obj.species{2});
                    set(gca,'FontSize',16)
                    legend(legs)


                case 3
                    figure;
                    legs = {};
                    if isfield(obj.fspOptions,'stateSpace')&&showPoints
                        scatter3(obj.fspOptions.stateSpace.states(1,:)',...
                            obj.fspOptions.stateSpace.states(2,:)',...
                            obj.fspOptions.stateSpace.states(3,:)',pointMarker);
                        hold on;
                        legs = {'FSP states'};
                    end

                    if showLines
                        fimplicit3(@(x,y,z)(-x-obj.fspOptions.bounds(1)),'EdgeColor','none','FaceColor',map(2,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(-y-obj.fspOptions.bounds(2)),'EdgeColor','none','FaceColor',map(3,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(-z-obj.fspOptions.bounds(3)),'EdgeColor','none','FaceColor',map(4,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(x-obj.fspOptions.bounds(4)),'EdgeColor','none','FaceColor',map(5,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(y-obj.fspOptions.bounds(5)),'EdgeColor','none','FaceColor',map(6,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(z-obj.fspOptions.bounds(6)),'EdgeColor','none','FaceColor',map(7,:),'FaceAlpha',0.1);hold on;
                        legs = [legs,{[obj.species{1},'>=',num2str(-obj.fspOptions.bounds(1))]}];
                        legs = [legs,{[obj.species{2},'>=',num2str(-obj.fspOptions.bounds(2))]}];
                        legs = [legs,{[obj.species{3},'>=',num2str(-obj.fspOptions.bounds(3))]}];
                        legs = [legs,{[obj.species{1},'<=',num2str(obj.fspOptions.bounds(4))]}];
                        legs = [legs,{[obj.species{2},'<=',num2str(obj.fspOptions.bounds(5))]}];
                        legs = [legs,{[obj.species{3},'<=',num2str(obj.fspOptions.bounds(6))]}];
                        for i = 1:length(obj.customConstraintFuns)
                            str = ['@(',obj.species{1},',',obj.species{2},',',obj.species{3},')',obj.customConstraintFuns{i},'-',num2str(obj.fspOptions.bounds(6+i))];
                            fun = eval(str);
                            fimplicit3(fun,'EdgeColor','none','FaceColor',map(7+1,:),'FaceAlpha',0.1);hold on;
                            legs = [legs,{[obj.customConstraintFuns{i},'<=',num2str(obj.fspOptions.bounds(i+6))]}];
                        end
                    end
                    set(gca,'xlim',[obj.fspOptions.bounds(1),obj.fspOptions.bounds(4)*1.1]);
                    set(gca,'ylim',[obj.fspOptions.bounds(2),obj.fspOptions.bounds(5)*1.1]);
                    set(gca,'zlim',[obj.fspOptions.bounds(3),obj.fspOptions.bounds(6)*1.1]);
                    xlabel(obj.species{1});
                    ylabel(obj.species{2});
                    ylabel(obj.species{3});
                    set(gca,'FontSize',16)
                    legend(legs)

                otherwise
                    error('visualization of FSP StateSpace only supported 2D and 3D models.')
            end
        end
        %% Model Building Functions
        function [obj] = pregenModel(obj,modelFile)
            % pregenModel - creates a pregenerated model from a template:
            % Possible Templates include:
            %   Empty -- nothing
            %   BirthDeath -- one species 'mRNA' with birth rate 'k' and
            %       death rate 'g'
            %   CentralDogma -- Time varying 2-species model with:
            %       mRNA species 'rna' with birth rate 'kr*I(t)' and
            %       degradation rate 'gr'. Protein species 'protein' with
            %       translation rate 'kr' and degradation rate 'gp'.
            %   ToggleSwitch -- two proteins that prepress one another with
            %       non-linear functions.
            switch modelFile
                case 'Empty'
                    obj.parameters = {};
                    obj.species = {};
                    obj.stoichiometry = [];
                    obj.propensityFunctions = {};
                    obj.initialCondition = [];
                case 'BirthDeath'
                    obj.parameters = {'k',10;'g',0.2};
                    obj.species = {'mRNA'};
                    obj.stoichiometry = [1,-1];
                    obj.propensityFunctions = {'k';'g*mRNA'};
                    obj.initialCondition = [0];
                case 'CentralDogma'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1};
                    obj.species = {'rna';'protein'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*rna';'kp*rna';'gp*protein'};
                    obj.initialCondition = [0;0];
                case 'BurstingGene'
                    obj.parameters = {'kon',1;'koff',1;'kr',1;'gr',0.1};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kon*(1-geneState)';'koff*geneState';'kr*geneState';'gr*rna'};
                    obj.initialCondition = [0;0];
                case 'CentralDogmaTV'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1;'omega',2*pi/5};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*I1*geneState';'kp*geneState';'gp*rna'};
                    obj.initialCondition = [0;0];
                    obj.inputExpressions = {'I1','1+cos(omega*t)'};
                case 'ToggleSwitch'
                    obj.parameters = {'kb',10;'ka',80;'M',20;'g',1};
                    obj.species = {'LacI';'LamCI'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kb+ka*M^3/(M^3+LamCI^3)';...
                        'g*LacI';...
                        'kb+ka*M^3/(M^3+LacI^3)';...
                        'g*LamCI'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(LacI-3).^2.*(LamCI-3).^2'};
                case 'ToggleSwitch2'
                    obj.parameters = {'ka1',4;'kb1',80;'kd1',1;'k1',20;...
                        'ka2',4;'kb2',80;'kd2',1;'k2',20;...
                        'ket',0.1;'ks',1;'kg',1};
                    obj.species = {'x1';'x2'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'ket*(ka1+((kb1*(k1^3))/((k1^3)+(x2)^3)))';...
                        '(kd1+((ks*kg)/(1+ks)))*(x1)';...
                        'ket*(ka2+((kb2*(k2^3))/((k2^3)+(x1)^3)))';...
                        'kd2*(x2)'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2'};
                case 'Repressilator'
                    obj.parameters = {'kn0',0;'kn1',25;'a',5;'n',6;'g',1};
                    obj.species = {'x1';'x2';'x3'};
                    obj.stoichiometry = [1,0,0,-1,0,0;...
                        0,1,0,0,-1,0;...
                        0,0,1,0,0,-1];
                    obj.propensityFunctions = {'kn0+kn1*(1/(1+a*(x2^n)))';...
                        'kn0+kn1*(1/(1+a*(x3^n)))';...
                        'kn0+kn1*(1/(1+a*(x1^n)))';...
                        'g*x1';...
                        'g*x2';...
                        'g*x3'};
                    obj.initialCondition = [30;0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2*(x3-3).^2'};

                case 'RepressilatorGenes'
                    obj.parameters = {'kn0',0;'kn1',25;'kb',2000;'ku',10;'g',1};
                    obj.species = {'x1';'x2';'x3';'x4';'x5';'x6';'x7';'x8';'x9'};
                    obj.stoichiometry = zeros(9,12);
                    obj.stoichiometry(1,1:2) = [-1 1];
                    obj.stoichiometry(2,1:2) = [1 -1];
                    obj.stoichiometry(6,1:2) = [-3 3];
                    obj.stoichiometry(3,3) =  1;
                    obj.stoichiometry(3,4) = -1;
                    obj.propensityFunctions(1:4) = {'kb*x1*x6*(x6-1)/2*(x6-2)/6';'ku*x2';'kn0*x2+kn1*x1';'g*x3'};
                    obj.stoichiometry(4,5:6) = [-1 1];
                    obj.stoichiometry(5,5:6) = [1 -1];
                    obj.stoichiometry(9,5:6) = [-3 3];
                    obj.stoichiometry(6,7) =  1;
                    obj.stoichiometry(6,8) = -1;
                    obj.propensityFunctions(5:8) = {'kb*x4*x9*(x9-1)/2*(x9-2)/6';'ku*x5';'kn0*x5+kn1*x4';'g*x6'};
                    obj.stoichiometry(7,9:10) = [-1 1];
                    obj.stoichiometry(8,9:10) = [1 -1];
                    obj.stoichiometry(3,9:10) = [-3 3];
                    obj.stoichiometry(9,11) =  1;
                    obj.stoichiometry(9,12) = -1;
                    obj.propensityFunctions(9:12) = {'kb*x7*x3*(x3-1)/2*(x3-2)/6';'ku*x8';'kn0*x8+kn1*x7';'g*x9'};
                    obj.initialCondition = [1;0;30;0;1;0;0;1;0];
                    obj.customConstraintFuns = {'(x3-3).^3.*(x6-3).^3.*(x9-3).^3'};

                case 'BurstingSpatialCentralDogma'
                    obj.parameters = {'kon',1;'koff',2;...
                        'kr',5;'grn',0.1;'kt',0.5;...
                        'grc',0.1;...
                        'kp',1;'gp',0.1};
                    obj.species = {'x1';'x2';'x3';'x4'};
                    obj.stoichiometry = [1,-1,0,0,0,0,0,0;...
                        0,0,1,-1,-1,0,0,0;...
                        0,0,0,0,1,-1,0,0;...
                        0,0,0,0,0,0,1,-1];
                    obj.propensityFunctions = {'kon*(1-x1)';'koff*x1';...
                        'kr*x1';'grn*x2';'kt*x2';...
                        'grc*x3';...
                        'kp*x3';'gp*x4'};
                    obj.initialCondition = [0;0;0;0];
                    obj.customConstraintFuns = {};

            end
            obj.propensitiesGeneral = [];
            obj.propensitiesGeneralODE = [];
            obj.propensitiesGeneralMean = [];
            obj.propensitiesGeneralMeanJac = [];
            obj.propensitiesGeneralMoments = [];
            obj.propensitiesGeneralMomentsJac = [];      
        end

        function [obj] = createModelFromSBML(obj,sbmlFile,scaleVolume)
            arguments
                obj
                sbmlFile
                scaleVolume = false
            end
            % This function allows one to create a model directly from an
            % SBML file.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSBML('../SBML_test_cases/00010/00010-sbml-l1v2.xml');
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            sbmlobj = sbmlimport(sbmlFile);
            [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume);
            obj.propensitiesGeneral = [];
            obj.propensitiesGeneralODE = [];
            obj.propensitiesGeneralMean = [];
            obj.propensitiesGeneralMeanJac = [];
            obj.propensitiesGeneralMoments = [];
            obj.propensitiesGeneralMomentsJac = [];      

        end

        function [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume)
            % This function allows one to create a model directly from an
            % simBiology object.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSimBiol(sbmlobj);
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            arguments
                obj
                sbmlobj
                scaleVolume = false
            end
            nR = length(sbmlobj.Reactions);
            nS = length(sbmlobj.Species);

            % Extract species names and stoichiometry
            [obj.stoichiometry, obj.species] = getstoichmatrix(sbmlobj);

            % Extract parameter names
            nP = length(sbmlobj.Parameter);
            obj.parameters = {};
            for i = 1:nP
                obj.parameters{i,1} = sbmlobj.Parameter(i).Name;
                obj.parameters{i,2} = sbmlobj.Parameter(i).Value;
            end

            if length(sbmlobj.Compartments)>1
                error('SSIT Tools not yet set up to support multi-compartment models.')
            end

            obj.propensityFunctions={};
            for i = 1:nR
                reactRate = sbmlobj.Reactions(i).ReactionRate;
                reactRate = strrep(reactRate,'compartment*','');
                if contains(reactRate,'time')
                    % obj.propensityFunctions{i,1} = strrep(reactRate,'time','Ig');
                    obj.propensityFunctions{i,1} = regexprep(reactRate,'\<time\>','Ig');
                    obj.inputExpressions = {'Ig','t'};
                else
                    obj.propensityFunctions{i,1} = reactRate;
                end

            end

            if scaleVolume
                % Replace species numbers (Xi) with concentrations (Xi/Volume).
                for i = 1:nR
                    for j = 1:nS
                        % obj.propensityFunctions{i,1} = strrep(obj.propensityFunctions{i,1},...
                        %     obj.species{j},['(',obj.species{j},'/Volume)']);
                        obj.propensityFunctions{i,1} = regexprep(obj.propensityFunctions{i,1},...
                            ['\<',obj.species{j},'\>'],['(',obj.species{j},'/Volume)']);

                    end
                    obj.propensityFunctions{i,1} = [obj.propensityFunctions{i,1},'*Volume'];
                end

                % Scale Initial Condition and Volume to remove fractional
                % concentrations.
                frac = false;
                scl = 0;
                for i = 1:nS
                    if rem(sbmlobj.Species(i).Value,1)~=0
                        frac = true;
                    end
                    scl = max(scl,sbmlobj.Species(i).Value);
                end
                if frac
                    scl = round(100/scl);
                    disp(['Fractional species values detected.  Scaling by Vol=',num2str(scl),' and rounding.'])
                    disp(' ')
                    IC(1:nS,1) = round(scl*[sbmlobj.Species.Value]);
                end
                obj.parameters(end+1,:) = {'Volume',scl};
            else
                IC(1:nS,1) = [sbmlobj.Species.Value];
            end
            obj.initialCondition = IC;
            obj.summarizeModel;
            obj.propensitiesGeneral = [];
            obj.propensitiesGeneralODE = [];
            obj.propensitiesGeneralMean = [];
            obj.propensitiesGeneralMeanJac = [];
            obj.propensitiesGeneralMoments = [];
            obj.propensitiesGeneralMomentsJac = [];      

        end

        function exportToSBML(obj,modelName)
            % This function exports the model to an SBML file called
            % <modelName>.
            arguments
                obj
                modelName
            end
            sbModel = exportSimBiol(obj);
            sbmlexport(sbModel, modelName)
        end

        function sbModel = exportSimBiol(obj,verifyAndPlot)
            % This function converts the model to a simple simbiology model
            % and returns that simbiology object.
            % Arguments:
            %   verifyAndPlot (true/false0) -- option to verify the model
            %       and run simBiology to make a plot of its results.
            %
            % Outputs:
            %   smModel -- the resulting simBiology model.
            arguments
                obj
                verifyAndPlot = false;
            end

            sbModel = sbiomodel('simpleModel');

            s = cell(1,length(obj.species));
            for is = 1:size(obj.stoichiometry,1)
                s{is} = addspecies(sbModel,obj.species{is},obj.initialCondition(is));
            end

            for is = 1:size(obj.parameters,1)
                p{is} = addparameter(sbModel,obj.parameters{is,1},obj.parameters{is,2});
            end

            % Parse time varying components in the reaction rate equations.
            props = obj.propensityFunctions;
            for is = 1:size(obj.inputExpressions,1)
                % tvComp = strrep(obj.inputExpressions{is,2},'t','time');
                tvComp = regexprep(obj.inputExpressions{is,2},'\<t\>','time');
                for ir = 1:length(props)
                    % props{ir} = strrep(props{ir},obj.inputExpressions{is,1},['(',tvComp,')']);
                    props{ir} = regexprep(props{ir},['\<',obj.inputExpressions{is,1},'\>'],['(',tvComp,')']);
                end
            end

            for ir=1:size(obj.stoichiometry,2)
                strReactants = [];
                strProducts =  [];
                for is = 1:size(obj.stoichiometry,1)
                    if obj.stoichiometry(is,ir)<0
                        strReactants =[strReactants,'+ ',[num2str(-obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    elseif obj.stoichiometry(is,ir)>0
                        strProducts =[strProducts,'+ ',[num2str(obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    end
                end
                if isempty(strProducts); strProducts = '  null '; end
                if isempty(strReactants); strReactants = '  null '; end
                rxn = [strReactants(3:end),' -> ',strProducts(3:end)];
                RXN{is} = addreaction(sbModel,rxn,'ReactionRate',props{ir});
            end

            if verifyAndPlot
                verify(sbModel)
                csObj = getconfigset(sbModel,'active');
                set(csObj,'Stoptime',max(obj.tSpan));
                [t,x,names] = sbiosimulate(sbModel);
                plot(t,x);
                xlabel('Time');
                ylabel('Amount');
                legend(names);
            end
        end

        function [obj] = addSpecies(obj,newSpecies,initialCond)
            % addSpecies - add new species to reaction model.
            % example:
            %     F = SSIT;
            %     F = F.addSpecies('x2');
            arguments
                obj
                newSpecies
                initialCond = [];
            end
            obj.species =  [obj.species;newSpecies];
            obj.stoichiometry(end+1,:) = 0;
            if isempty(initialCond)
                initialCond = zeros(size(newSpecies,1),1);
            end
            obj.initialCondition = [obj.initialCondition;initialCond];
            obj.propensitiesGeneral = [];
            obj.propensitiesGeneralODE = [];
            obj.propensitiesGeneralMean = [];
            obj.propensitiesGeneralMeanJac = [];
            obj.propensitiesGeneralMoments = [];
            obj.propensitiesGeneralMomentsJac = [];      

        end

        function [obj] = addParameter(obj,newParameters)
            % addParameter - add new parameter to reaction model
            % example:
            %     F = SSIT;
            %     F = F.addParameter({'kr',0.1})
            obj.parameters =  [obj.parameters;newParameters];
        end

        function [obj] = addReaction(obj,newRxn,confirm)
            arguments
                obj
                newRxn
                confirm = false
            end

            % addParameter - add new reaction to reaction model
            % example:
            % F = SSIT('Empty')
            % newRxn(1).propensity = 'kr + kr1*x1';
            % newRxn(1).stoichiometry = {'x1',1};
            % newRxn(1).parameters = {'kr',2;'kr1',0.01};
            % newRxn(2).propensity = 'g*x1';
            % newRxn(2).stoichiometry = {'x1',-1};
            % newRxn(2).parameters = {'g',0.1};
            % F = F.addReaction(newRxn);
            for iRxn = 1:length(newRxn)
                obj.propensityFunctions =  [obj.propensityFunctions;newRxn(iRxn).propensity];
                rxnNum = size(obj.stoichiometry,2)+1;
                for iSpe = 1:size(newRxn(iRxn).stoichiometry,1)
                    specName = newRxn(iRxn).stoichiometry{iSpe,1};
                    specChange = newRxn(iRxn).stoichiometry{iSpe,2};
                    specNum = find(strcmp(obj.species,specName));
                    if isempty(specNum)
                        disp(['Adding species ',specName,' with initial condition 0.'])
                        obj = obj.addSpecies(specName,0);
                        specNum = length(obj.species);
                    end
                    obj.stoichiometry(specNum,rxnNum) = specChange;
                end
                for iPar = 1:size(newRxn(iRxn).parameters,1)
                    parName = newRxn(iRxn).parameters{iPar,1};
                    parValue = newRxn(iRxn).parameters{iPar,2};
                    if ~isempty(obj.parameters)
                        parNum = find(strcmp(obj.parameters(:,1),parName));
                    else
                        parNum=[];
                    end
                    if isempty(parNum)
                        disp(['Adding parameter ',parName,' with value ',num2str(parValue)]);
                        obj = obj.addParameter({parName,parValue});
                    else
                        disp(['Updating parameter ',parName,' to new value ',num2str(parValue)]);
                        obj.parameters{parNum,2} = parValue;
                    end
                end
            end
            obj.propensitiesGeneral = [];
            obj.propensitiesGeneralODE = [];
            obj.propensitiesGeneralMean = [];
            obj.propensitiesGeneralMeanJac = [];
            obj.propensitiesGeneralMoments = [];
            obj.propensitiesGeneralMomentsJac = [];      
        end

        function [obj] = removeReaction(obj,numRxn,confirm)
            % Removes a reaction from propensity functions and
            % stoichiometry matrix.
            arguments
                obj
                numRxn
                confirm = false
            end
            inds = ones(1,length(obj.propensityFunctions),'logical');
            inds(numRxn) = false;
            obj.stoichiometry = obj.stoichiometry(:,inds);
            obj.propensityFunctions = obj.propensityFunctions(inds);
        end

        function [obj] = calibratePDO(obj,dataFileName,measuredSpecies,...
            trueColumns,measuredColumns,pdoType,showPlot,parGuess,...
            conditions, opts)
            %% SSIT.calibratePDO - This function calibrates a probabilistic 
            %% distortion operator (PDO) to match 'true' and 'observed' 
            %% (distorted) spot numbers. Note: it also calls generatePDO() 
            %% Calibrate the PDO from empirical data, for example, the 
            % number of spots that have been measured using different 
            % assays in data columns 'nTotal' for the 'true' data set and 
            % in the columns 'nSpots0' for a different label, or in columns 
            % 'intens1' for the integrated fluorescent intensity. 
            %% Inputs: 
            % * obj 
            % * dataFileName - (string), name of the data file 
            % * measuredSpecies - (string), name of the model species 
            % * trueColumns - (string), name of the 'true' data for the model species 
            % * measuredColumns - (string), name of the 'observed', or distorted, data for the model species 
            % * pdoType - (string), the type of distribution that represents the type (default: 'AffinePoiss')
            % * showPlot - (logical), default: false 
            % * parGuess - (double), guesses for the hyperparameter values, i.e., the parameters that define the 
            % PDO distribution (not to be confused with the model parameters) default: []; 
            % * conditions - (cell) filters to apply before calibration, 
            %       e.g. {'Replica',1} or {'Drug_Conc','>=',100}
            % Plotting opts (used only when showPlot==true):
            %   opts.Title (1,1) string = ""
            %   opts.FontSize (1,1) double {mustBePositive} = 18
            %   opts.LegendFontSize (1,1) double {mustBePositive} = 18
            %   opts.LegendLocation (1,1) string = "best"
            %   opts.XLabel (1,1) string = "Observed data"
            %   opts.YLabel (1,1) string = "True counts"
            %   opts.XLim double = []
            %   opts.YLim double = []
            %% Outputs: 
            %% Example: 
            % Model_PDO = Model.calibratePDO('/data/pdoData.csv',... 
            % {'rna'},{'nTotal'},{'nSpots0'},'AffinePoiss',true); 
            %% The 'AffinePoiss' PDO models the obervation probability with 
            % a Poisson distribution, where the mean value is affine 
            % linearly related to the true value: P(y|x) = Poiss(a0 + a1*x); arguments

            arguments
                obj
                dataFileName
                measuredSpecies
                trueColumns
                measuredColumns
                pdoType = 'AffinePoiss'
                showPlot = false
                parGuess = []
                conditions = {}
                opts.Title (1,1) string = ""
                opts.FontSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Observed data"
                opts.YLabel (1,1) string = "True counts"
                opts.XLim double = []
                opts.YLim double = []
            end

            obj.pdoOptions.type = pdoType;

            % Read table(s)
            if ischar(dataFileName) || isstring(dataFileName)
                TAB = readtable(dataFileName);
            elseif iscell(dataFileName)
                TAB = table;
                for iCell = 1:numel(dataFileName)
                    iTAB = readtable(dataFileName{iCell});
                    TAB = [TAB; iTAB];
                end
            else
                error('dataFileName must be string/char or cell array of file names.');
            end

            % Apply conditions (same logic as loadData)
            for i = 1:size(conditions,1)
                if size(conditions,2)==2
                    if isnumeric(conditions{i,2}) && isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB(TAB.(conditions{i,1})==conditions{i,2},:);
                    elseif ischar(conditions{i,2}) && iscell(TAB.(conditions{i,1})(1)) && ischar(TAB.(conditions{i,1}){1})
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif ischar(conditions{i,2}) && ischar(TAB.(conditions{i,1})(1))
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB((TAB.(conditions{i,1}))==eval(conditions{i,2}),:);
                    end
                else
                    try
                        eval(['TAB = TAB(TAB.(conditions{i,1})',conditions{i,3},'conditions{i,2},:);'])
                    catch
                        eval(['TAB = TAB(',conditions{i,3},',:);'])
                    end
                end
            end

            if height(TAB)==0
                error('calibratePDO:NoRowsAfterFilter', ...
                      'No rows remain after applying conditions. Check your filters.');
            end

            dataNames = TAB.Properties.VariableNames;

            % Validate requested columns exist
            for k = 1:numel(trueColumns)
                if ~any(strcmp(dataNames,trueColumns{k}))
                    error('calibratePDO:MissingTrueColumn', ...
                          'True column "%s" not found in the data file.', trueColumns{k});
                end
            end
            for k = 1:numel(measuredColumns)
                if ~any(strcmp(dataNames,measuredColumns{k}))
                    error('calibratePDO:MissingMeasuredColumn', ...
                          'Measured column "%s" not found in the data file.', measuredColumns{k});
                end
            end

            % Cast specified true/measured columns to integer counts
            for k = 1:numel(trueColumns)
                col = trueColumns{k};
                if ~isempty(col) && isnumeric(TAB.(col))
                    TAB.(col) = double(int64(TAB.(col)));
                end
            end
            for k = 1:numel(measuredColumns)
                col = measuredColumns{k};
                if ~isempty(col) && isnumeric(TAB.(col))
                    TAB.(col) = double(int64(TAB.(col)));
                end
            end

            DATA = table2cell(TAB);

            % Initial guess for PDO parameters
            if isempty(parGuess)
                lambdaTemplate = obj.findPdoError(pdoType);
            else
                lambdaTemplate = parGuess;
            end

            lambda = [];

            % Identify stochastic species (exclude upstream ODEs in hybrids)
            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species, obj.hybridOptions.upstreamODEs, 'stable');
            else
                speciesStochastic = obj.species;
            end

            maxSize = zeros(1,length(speciesStochastic));
            options = optimset('display','none');

            for i = 1:length(speciesStochastic)
                if sum(strcmp(measuredSpecies, speciesStochastic{i})) == 1
                    k = find(strcmp(measuredSpecies, speciesStochastic{i}));
                    jTrue = find(strcmp(dataNames, trueColumns{k}));
                    jObsv = find(strcmp(dataNames, measuredColumns{k}));

                    if isempty(jTrue) || isempty(jObsv)
                        error('calibratePDO:ColumnIndexError', ...
                              'Could not resolve true/measured columns for species "%s".', speciesStochastic{i});
                    end

                    xTrue = [DATA{:,jTrue}]';
                    xObsv = [DATA{:,jObsv}]';
                    if isempty(xTrue) || isempty(xObsv)
                        error('calibratePDO:EmptyColumns', ...
                              'Columns for species "%s" are empty after filtering.', speciesStochastic{i});
                    end

                    maxSize(i) = max(xTrue);

                    objPDO = @(x) -obj.findPdoError(pdoType, x, xTrue, xObsv);
                    lambdaNew = fminsearch(objPDO, lambdaTemplate, options);

                    if showPlot
                        [~,PDO] = obj.findPdoError(pdoType, lambdaNew, xTrue, xObsv);
                        Z = max(-25, log10(PDO));
                        fg = figure; set(0,'CurrentFigure',fg);
                        contourf(0:size(PDO,2)-1, 0:size(PDO,1)-1, Z);
                        colorbar
                        hold on
                        scatter(xTrue, xObsv, 100, 'sk', 'filled')

                        % --- Apply opts ---
                        if strlength(opts.XLabel) > 0
                            xlabel(opts.XLabel);
                        end
                        if strlength(opts.YLabel) > 0
                            ylabel(opts.YLabel);
                        end
                        if ~isempty(opts.XLim)
                            xlim(opts.XLim);
                        end
                        if ~isempty(opts.YLim)
                            ylim(opts.YLim);
                        end
                        lgd = legend('PDO','Data','Location',char(opts.LegendLocation));
                        if ~isempty(lgd) && isvalid(lgd)
                            lgd.FontSize = opts.LegendFontSize;
                        end
                        if strlength(opts.Title) > 0
                            tt = title(opts.Title);
                        else
                            tt = title(sprintf('PDO fit: %s', speciesStochastic{i}));
                        end
                        if ~isempty(tt) && isvalid(tt)
                            tt.FontSize = opts.FontSize;
                        end
                        % ---------------

                        set(gca, 'fontsize', max(10, round(0.8*opts.FontSize))); % modest tie-in
                    end
                else
                    maxSize(i) = 0;
                    lambdaNew = 0*lambdaTemplate;
                end
                lambda = [lambda, lambdaNew];
            end

            obj.pdoOptions.props.PDOpars = lambda;
            obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions, lambda, [], [], maxSize);
        end



        function obj = setICfromFspVector(obj,stateSpace,fspVector)
            % This function converts an FSP vector to initial states
            % and initial probabilities.
            nSpecies = length(obj.species);
            nStates = size(fspVector.p.data.subs,1);
            if obj.useHybrid
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
                nUpstream = length(obj.hybridOptions.upstreamODEs);
                upStreamInit = [fspVector.upstreamODEs,zeros(nUpstream,nStates-1)];
            elseif ~isempty(fspVector.upstreamODEs)
                upStreamInit = repmat(fspVector.upstreamODEs,1,nStates);
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
            else
                upStreamInit = [];
                jStochastic = [1:nSpecies];
                jUpstreamODE = [];
            end

            obj.initialCondition = zeros(nSpecies,nStates);
            obj.initialCondition(jStochastic,:) = fspVector.p.data.subs'-1;
            obj.initialCondition(jUpstreamODE,:) = upStreamInit;
            obj.initialProbs = zeros(nStates,1);
            obj.initialProbs = max(0,real(fspVector.p.data.vals));

        end

        function [pdo] = generatePDO(obj,pdoOptions,paramsPDO,fspSoln,variablePDO,maxSize)
            %% SSIT.generatePDO - This function generates the Probabilistic
            %% Distortion Operator (PDO) according to user choice.
            %
            % Inputs:
            %   * app
            %   * paramsPDO - ()
            %   * FSPoutputs - ()
            %   * indsObserved - ()
            %   * variablePDO - (logical), default: false
            %   * maxSize - ()
            %
            % Output:
            %
            % Example:
            arguments
                obj
                pdoOptions
                paramsPDO = []
                fspSoln = []
                variablePDO =[]
                maxSize=[];
            end
            app.DistortionTypeDropDown.Value = pdoOptions.type;
            app.FIMTabOutputs.PDOProperties.props = pdoOptions.props;

            % Separate into observed and unobserved species.
            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end
            Nd = length(speciesStochastic);

            indsUnobserved=[];
            indsObserved=[];
            for i=1:Nd
                if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                    indsUnobserved=[indsUnobserved,i];
                else
                    indsObserved=[indsObserved,i];
                end
            end
            [~,pdo] = ssit.pdo.generatePDO(app,paramsPDO,fspSoln,indsObserved,variablePDO,maxSize);
        end

        function [logL,P] = findPdoError(obj,pdoType,lambda,True,Distorted)
            % This function calculates the likelihood of observed data
            % given true data and an assumed PDO model.
            arguments
                obj
                pdoType = 'AffinePoiss';
                lambda = [];
                True = [];
                Distorted =[];
            end

            if nargin<=2
                switch pdoType
                    case 'LinPoiss'
                        logL = [0.1, 1];
                    case 'AffinePoiss'
                        logL = [1 5 0.5];
                    case 'QuadPoiss'
                        logL = [1 5 0.5];
                end
                return
            end

            % Computes likelihood of observed data given the model of affine poisson
            % extra spot counting and probability of measurmeent failure.
            NmaxTrue = max(True);
            NmaxObs = max(Distorted);

            switch pdoType
                case 'LinPoiss'
                    Np = ceil(max(NmaxObs,lambda(1)+lambda(2)*NmaxTrue));
                case 'AffinePoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue));
                case 'QuadPoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue+lambda(4)*NmaxTrue^2));
            end
            P = zeros(Np+1,NmaxTrue+1);

            for xi = 0:NmaxTrue
                switch pdoType
                    case 'LinPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)*xi));
                    case 'AffinePoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi));
                    case 'QuadPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi+lambda(4)*xi^2));
                end
            end

            % compute likelihood of observed given true
            logP = max(log(P),-100);
            logL = 0;
            for i = 1:length(True)
                logL = logL + logP(Distorted(i)+1,True(i)+1);
            end

            % apply constraints
            switch pdoType
                case 'LinPoiss'
                    logL = logL-1e4*(lambda(1)<0);
                case 'AffinePoiss'
                    logL = logL-1e4*(lambda(1)<0);
            end
        end

        function summarizeModel(obj)
            %% SSIT.summarizeModel - Prints a summary of an SSIT model:
            %% Species, Reactions (with Stoichiometric updates),
            %% Model Parameters
            %
            % Input:  SSIT model
            %
            % Output:  Summary text to screen
            %
            % Example:  Model.summarizeModel
            arguments
                obj;
            end
            % Show the model species
            nS = size(obj.stoichiometry,1);
            disp('Species:')
            for i = 1:nS
                if ~isempty(obj.hybridOptions.upstreamODEs)&&max(contains(obj.hybridOptions.upstreamODEs,obj.species{i}))
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  upstream ODE']);
                else
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  discrete stochastic']);
                end
            end
            disp(' ')

            % Show the model stoichiometries and propensity functions
            disp('Reactions:')
            nR = size(obj.stoichiometry,2);
            for iR = 1:nR
                s = obj.stoichiometry(:,iR);
                disp(['  Reaction ',num2str(iR),':'])
                jReactant = find(s<0);
                jProd = find(s>0);
                if isempty(jReactant)
                    reactTxt = 'NULL';
                else
                    reactTxt = [num2str(-s(jReactant(1))),'*',obj.species{jReactant(1)}];
                    for i = 2:length(jReactant)
                        reactTxt = [reactTxt,' + ',num2str(-s(jReactant(i))),'*',obj.species{jReactant(i)}];
                    end
                end
                if isempty(jProd)
                    prodTxt = 'NULL';
                else
                    prodTxt = [num2str(s(jProd(1))),'*',obj.species{jProd(1)}];
                    for i = 2:length(jProd)
                        prodTxt = [prodTxt,' + ',num2str(s(jProd(i))),'*',obj.species{jProd(i)}];
                    end
                end
                disp(['     s',num2str(iR),': ',reactTxt, ' --> ', prodTxt])

                disp(['     w',num2str(iR),': ',obj.propensityFunctions{iR}])

            end

            if ~isempty(obj.inputExpressions)
                disp(' ')
                disp('Input Signals:')
                nI = size(obj.inputExpressions,1);
                for i = 1:nI
                    disp(['     ',obj.inputExpressions{i,1},'(t) = ',obj.inputExpressions{i,2}])
                end
            end

            disp(' ')
            disp('Model Parameters:')
            disp(obj.parameters)

        end

        %% Model Analysis Functions
        function obj = fspSolve(obj)
            obj.solutionScheme='FSP';
            [~,~,obj] = obj.solve;
        end
        function [Solution, bConstraints, obj] = solve(obj,stateSpace,saveFile,fspSoln)
            arguments
                obj
                stateSpace = [];
                saveFile=[];
                fspSoln=[];
            end
            % Solve the model using the specified method in
            %    obj.solutionScheme (default: 'FSP')
            % Inputs:
            %   obj
            %   stateSpace = [];
            %   saveFile = [];
            %   fspSoln = [];
            % Example:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [soln,bounds] = F.solve;  % Returns the solution and the
            %                             % bounds for the FSP projection
            %   F.solutionScheme = 'fspSens'
            %   [soln,bounds] = F.solve;  % Returns the sensitivity and the
            %                             % bounds for the FSP projection
            % See also: SSIT.makePlot for information on how to visualize
            % the solution data.
            if obj.initialTime>obj.tSpan(1)
                error('First time in tspan cannot be earlier than the initial time.')
            elseif obj.initialTime~=obj.tSpan(1)
                %                 warning('First time in tspan is not the same as initial time.')
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);
            end

            if isempty(stateSpace)&&~isempty(obj.fspOptions.stateSpace)
                stateSpace = obj.fspOptions.stateSpace;
            end

            if strcmpi(obj.solutionScheme(1:3),'fsp')
                propensityGeneral = obj.propensitiesGeneral;
                if isempty(propensityGeneral)
                    disp('Forming Propensity Functions.')
                    obj = formPropensitiesGeneral(obj);
                elseif ~isempty(obj.hybridOptions)&&~strcmp(obj.solutionScheme,'ode')&&length(obj.hybridOptions.upstreamODEs)~=length(propensityGeneral{1}.ODEstoichVector)
                    disp('(Re)Forming Propensity Functions Due to Detected Change in Hybrid Model Dimension.')
                    obj = formPropensitiesGeneral(obj,'hybrid',true);
                end


                if obj.modelReductionOptions.useModReduction
                    if ~isfield(obj.modelReductionOptions,'phi')
                        error('Model Reduction Matrices have not yet been Defined.')
                    end
                    useReducedModel = true;
                    modRedTransformMatrices.phi = obj.modelReductionOptions.phi;
                    modRedTransformMatrices.phi_inv = obj.modelReductionOptions.phi_inv;
                    modRedTransformMatrices.phiScale = obj.modelReductionOptions.phiScale;
                    modRedTransformMatrices.phiPlot = obj.modelReductionOptions.phiPlot;
                else
                    useReducedModel = false;
                    modRedTransformMatrices = [];
                end
            elseif strcmpi(obj.solutionScheme,'moments')||strcmpi(obj.solutionScheme,'momentsgaussian')
                propensityGeneral = obj.propensitiesGeneralMoments;
                if isempty(propensityGeneral)
                    disp('Forming Propensity Functions.')
                    obj = formPropensitiesGeneral(obj);
                end
            elseif strcmpi(obj.solutionScheme,'ode')
                propensityGeneral = obj.propensitiesGeneralMean;
                if isempty(propensityGeneral)
                    disp('Forming Propensity Functions.')
                    obj = formPropensitiesGeneral(obj);
                end
            end

            switch lower(obj.solutionScheme)
                case 'fsp'
                    if ~isempty(stateSpace)&&size(stateSpace.states,2)~=length(stateSpace.state2indMap.keys)
                        error('Mismatch in statespace definition.')
                    end

                    % specificPropensities = SSIT.parameterizePropensities(obj.propensitiesGeneral,[obj.parameters{:,2}]');

                    [Solution.fsp, bConstraints,Solution.stateSpace] = ssit.fsp.adaptiveFspSolve(obj.tSpan,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.propensitiesGeneral, ...
                        [obj.parameters{:,2}]', ...
                        obj.fspOptions.fspTol, ...
                        obj.fspConstraints.f, ...
                        obj.fspConstraints.b,...
                        obj.fspOptions.verbose, ...
                        obj.fspOptions.fspIntegratorRelTol, ...
                        obj.fspOptions.fspIntegratorAbsTol, ...
                        obj.fspOptions.odeSolver, ...
                        stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape, ...
                        obj.fspOptions.constantJacobian,...
                        obj.fspOptions.constantJacobianTime,...
                        obj.odeIntegrator);
                    obj.fspOptions.stateSpace = Solution.stateSpace;
                    obj.fspOptions.bounds = bConstraints;

                case 'ssa'
                    Solution.T_array = obj.tSpan;
                    Nt = length(Solution.T_array);

                    if ~isnan(obj.ssaOptions.nSimsPerExpt)
                        nSims = round(obj.ssaOptions.Nexp*obj.ssaOptions.nSimsPerExpt*Nt);
                    else
                        nSims = obj.ssaOptions.Nsims;
                    end

                    % Write callable SSA code for better efficiency.
                    % W = obj.propensitiesGeneral;
                    % if obj.ssaOptions.useGPU
                    % Write a GPU Friendly Code and then Execute.
                    k = [obj.parameters{:,2}];
                    % Parameters for the model.

                    w = obj.propensityFunctions;
                    % Replace input signals with their actual functions.
                    for i = 1:size(obj.inputExpressions,1)
                        w = regexprep(w,['\<',obj.inputExpressions{i,1},'\>'],['(',obj.inputExpressions{i,2},')']);
                    end
                    % Replace species with vector
                    for i = 1:length(obj.species)
                        w = regexprep(w,['\<',obj.species{i},'\>'],['x',num2str(i)]);
                    end
                    % Replace parameters with $i
                    for i = 1:size(obj.parameters,1)
                        w = regexprep(w,['\<',obj.parameters{i,1},'\>'],['$',num2str(i)]);
                    end
                    % Replace $ with k
                    w = strrep(w,'$','k');

                    S = obj.stoichiometry;  % Stoichiometry matrix.

                    x0 = obj.initialCondition;
                    % initial condition.

                    % Call code to write a GPU friendly SSA code.
                    fun_name = 'TmpGPUSSACode';
                    clear TmpGPUSSACode % Clear function from cache just in case.
                    ssit.ssa.WriteGPUSSA(k,w,S,obj.tSpan,fun_name);
                    % TODO -- this part where the SSA codes are written
                    % could be moved out of the solve routine.  Right now,
                    % the code is being re-written for every new parameter
                    % set.  Because the code writing time is short compared
                    % to the solution time (~2%), this is not a big concern.


                    fun = str2func(fun_name);
                    % Convert the function name string to a function handle.

                    % Run SSA on GPU, in parallel, or in series as
                    % requested.
                    if obj.ssaOptions.useGPU
                        Solution.trajs=fun(x0,nSims,k,'GPU');
                    elseif obj.ssaOptions.useParallel
                        Solution.trajs=fun(x0,nSims,k,'Parallel');
                    else
                        Solution.trajs=fun(x0,nSims,k,'Series');
                    end
                    disp([num2str(nSims),' SSA Runs Completed'])

                    % Apply PDO, if applicable
                    if ~isempty(obj.pdoOptions.PDO)
                        Solution.trajsDistorted = zeros(length(obj.species),...
                            length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                        for iS = 1:length(obj.species)
                            PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                            nDpossible = size(PDO,1);
                            Q = Solution.trajs(iS,:,:);
                            for iD = 1:length(Q(:))
                                Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                            end
                            Solution.trajsDistorted(iS,:,:) = Q;
                        end
                        disp('PDO applied to SSA results')
                    end

                    % Save results if requested.
                    if ~isempty(saveFile)
                        A = table;
                        if ~isnan(obj.ssaOptions.nSimsPerExpt)
                            % Write table for independent experiments.
                            for j=1:Nt
                                A.time((j-1)*obj.ssaOptions.nSimsPerExpt+1:j*obj.ssaOptions.nSimsPerExpt) = obj.tSpan(j);
                                for i = 1:obj.ssaOptions.Nexp
                                    for k=1:obj.ssaOptions.nSimsPerExpt
                                        for s = 1:size(Solution.trajs,1)
                                            warning('off')
                                            A.(['exp',num2str(i),'_s',num2str(s)])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                                Solution.trajs(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                            if ~isempty(obj.pdoOptions.PDO)
                                                A.(['exp',num2str(i),'_s',num2str(s),'_Distorted'])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                                    Solution.trajsDistorted(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            % Write table for dependent experiments.
                            for j=1:Nt
                                A.time((j-1)*obj.ssaOptions.Nsims+1:j*obj.ssaOptions.Nsims) = obj.tSpan(j);
                                for i = 1:obj.ssaOptions.Nexp
                                    for k=1:obj.ssaOptions.Nsims
                                        for s = 1:size(Solution.trajs,1)
                                            warning('off')
                                            A.(['exp',num2str(i),'_s',num2str(s)])((j-1)*obj.ssaOptions.Nsims+(1:obj.ssaOptions.Nsims)) = ...
                                                Solution.trajs(s,j,:);
                                            if ~isempty(obj.pdoOptions.PDO)
                                                A.(['exp',num2str(i),'_s',num2str(s),'_Distorted'])((j-1)*obj.ssaOptions.Nsims+k) = ...
                                                    Solution.trajsDistorted(s,j,:);
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        writetable(A,saveFile)
                        disp(['SSA Results saved to ',saveFile])
                    end

                    bConstraints = max(obj.fspConstraints.f((reshape(Solution.trajs,[size(Solution.trajs,1),size(Solution.trajs,2)*size(Solution.trajs,3)]))),[],2);
                    bConstraints = max(bConstraints,obj.fspConstraints.b);

                case 'fspsens'
                    if strcmp(obj.sensOptions.solutionMethod,'forward')&&isempty(obj.propensitiesGeneral{1}.sensTimeFactorVec)
                        obj = formPropensitiesGeneral(obj,'Sensitivities',true);
                    end
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = obj.species;

                    [Solution.sens, bConstraints] = ...
                        ssit.sensitivity.computeSensitivity(...
                        obj.parameters,...
                        obj.propensitiesGeneral,...
                        obj.tSpan,...
                        obj.fspOptions.fspTol,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.fspConstraints.f,...
                        obj.fspConstraints.b,...
                        [], obj.fspOptions.verbose, 0,...
                        obj.sensOptions.solutionMethod,...
                        app,stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...
                        obj.sensOptions.useParallel,...
                        fspSoln,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape,...
                        obj.fspOptions.constantJacobian,obj.fspOptions.constantJacobianTime,...
                        obj.odeIntegrator);
                    %                     app.SensFspTabOutputs.solutions = Solution.sens;
                    %                     app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    %                     Solution.plotable = exportSensResults(app);

                case 'ode'
                    % Initial condition is assumed to be a delta
                    % distribution, where the
                    initMeans = obj.initialCondition;
                    
                    RHS = @(t,v)obj.propensitiesGeneralMean(t,v,[obj.parameters{:,2}]);
                    odeIntegrat = str2func(obj.odeIntegrator);

                    if ~isempty(obj.propensitiesGeneralMeanJac)
                        JAC = @(t,v)obj.propensitiesGeneralMeanJac(t,v,[obj.parameters{:,2}]);
                        options = odeset('Jacobian',JAC);
                    else
                        options = [];
                    end

                    [~,soln] =  odeIntegrat(RHS,obj.tSpan,initMeans,options);
                    Solution.ode = soln;

                    bConstraints = max(obj.fspConstraints.f(Solution.ode),[],2);
                    bConstraints = max(bConstraints,obj.fspConstraints.b);

                case {'moments','momentsgaussian'}
                    % Initial condition is assumed to be a delta
                    % distribution, where the
                    initMeans = obj.initialCondition;

                    nSp = length(obj.species);
                    initMeansSquared = zeros(nSp*(nSp+1)/2,1);
                    k = 0;
                    for iS = 1:nSp
                        for jS = iS:nSp
                            k =k+1;
                            initMeansSquared(k) = obj.initialCondition(iS)*obj.initialCondition(jS);
                        end
                    end
                    initCond = [initMeans;initMeansSquared];

                    RHS = @(t,v)obj.propensitiesGeneralMoments(t,v,[obj.parameters{:,2}]);
                    odeIntegrat = str2func(obj.odeIntegrator);

                    if ~isempty(obj.propensitiesGeneralMomentsJac)
                        JAC = @(t,v)obj.propensitiesGeneralMomentsJac(t,v,[obj.parameters{:,2}]);
                        options = odeset('Jacobian',JAC);
                    else
                        options = [];
                    end

                    [~,soln] =  odeIntegrat(RHS,obj.tSpan,initCond,options);
                    Solution.moments = soln';
                   
                    bConstraints = max(obj.fspConstraints.f((reshape(Solution.moments(1:nSp,:),[nSp,length(obj.tSpan)]))),[],2);
                    bConstraints = max(bConstraints,obj.fspConstraints.b);
            end

            if nargout>=3
                % Save all new solution fields WITHOUT overwriting existing
                % solutions.
                newFields = fieldnames(Solution);
                for ifield = 1:length(newFields)
                    obj.Solutions.(newFields{ifield}) = Solution.(newFields{ifield});
                end
            end

        end

        function A = sampleDataFromFSP(obj,fspSoln,saveFile)
            % Function to create simulated single-cell snapshot data by
            % sampling from the FSP solution.
            % Arguments:
            %       fspSoln -- solution of current model using FSP.
            %       saveFile -- filename (.csv) to save data.
            Solution.T_array = obj.tSpan;
            Nt = length(Solution.T_array);
            if ~isnan(obj.ssaOptions.nSimsPerExpt)
                nSims = obj.ssaOptions.nSimsPerExpt*obj.ssaOptions.Nexp;
            else
                nSims = obj.ssaOptions.Nsims;
            end
            Solution.trajs = zeros(length(obj.species),...
                length(obj.tSpan),nSims);% Creates an empty Trajectories matrix
            % from the size of the time array and number of simulations
            for it = 1:length(obj.tSpan)
                clear PP
                PP = double(fspSoln.fsp{it}.p.data);
                clear w
                w(:) = PP(:); w(w<0)=0;
                % TODO - there has to be another way of doing this.
                [I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11] =  ind2sub(size(PP),randsample(length(w), nSims, true, w ));
                for iSp = 1:length(obj.species)
                    eval(['Solution.trajs(iSp,it,:) = I',num2str(iSp),'-1;']);
                end
            end
            if ~isempty(obj.pdoOptions.PDO)
                Solution.trajsDistorted = zeros(length(obj.species),...
                    length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                for iS = 1:length(obj.species)
                    PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                    nDpossible = size(PDO,1);
                    Q = Solution.trajs(iS,:,:);
                    for iD = 1:length(Q(:))
                        Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                    end
                    Solution.trajsDistorted(iS,:,:) = Q;
                end
                disp('PDO applied to FSP Samples')
            end
            if ~isempty(saveFile)
                A = table;
                for it=1:Nt
                    A.time((it-1)*nSims+1:it*nSims) = obj.tSpan(it);
                    for ie = 1:obj.ssaOptions.Nexp
                        for s = 1:size(Solution.trajs,1)
                            warning('off')
                            A.(['exp',num2str(ie),'_s',num2str(s)])((it-1)*nSims+(1:nSims)) = ...
                                Solution.trajs(s,it,(ie-1)*nSims+(1:nSims));
                            if ~isempty(obj.pdoOptions.PDO)
                                A.(['exp',num2str(ie),'_s',num2str(s),'_Distorted'])((it-1)*nSims+(1:nSims)) = ...
                                    Solution.trajsDistorted(s,it,(ie-1)*nSims+(1:nSims));
                            end
                        end
                    end
                end
                writetable(A,saveFile)
                disp(['FSP Samples saved to ',saveFile])
            end
        end

        function [fimResults,sensSoln] = computeFIM(obj,sensSoln,scale,MHSamples)
            %% computeFIM - Computes the Fisher Information Matrix (FIM)
            %%              at all time points.
            % Inputs:
            %   * sensSoln (optional) - previously computed FSP
            %                           sensitivity, automatically
            %                           computed by computeFIM if not
            %                           provided
            %   * scale - choice of FIM based on linear parameters or
            %             their natural logarithm ('lin' or 'log'),
            %             default: 'lin'
            %   * MHSamples (optional) - set of parameter sets at which
            %                            to calculate the FIM
            %
            % Outputs:
            %   * fimResults - FIM at each time point in obj.tSpan
            %   * sensSoln - FSP sensitivity solutions
            arguments
                obj
                sensSoln = [];
                scale = 'lin';
                MHSamples = [];
            end

            if ~isempty(MHSamples)
                % For FIM calculation
                nSamples = size(MHSamples,1);
                Nt = length(obj.tSpan);
                fimResults = cell(Nt,nSamples);
                if isempty(sensSoln)||length(sensSoln)~=nSamples
                    sensSoln = cell(1,nSamples);
                end
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    obj.fittingOptions.modelVarsToFit = 1:size(obj.parameters,1);
                end
                if nargout == 2
                    saveSens = true;
                else
                    saveSens = false;
                end

                for i=1:nSamples
                    objTMP = obj;
                    objTMP.parameters(objTMP.fittingOptions.modelVarsToFit,2) = ...
                        num2cell(MHSamples(i,:));
                    if saveSens
                        [fimResults(:,i),sensSoln{i}] = computeFIM(obj,sensSoln{i},scale);
                    else
                        fimResults(:,i) = objTMP.computeFIM(sensSoln{i},scale);
                    end
                end
            else
                if isempty(sensSoln)
                    if isfield(obj.Solutions,'sens')
                        sensSoln = obj.Solutions.sens;
                    else
                        % disp({'Running Sensitivity Calculation';'You can skip this step by providing sensSoln.'})
                        obj.solutionScheme = 'fspSens';
                        [sensSoln] = obj.solve;
                        sensSoln = sensSoln.sens;
                    end
                end

                % Separate into observed and unobserved species.
                if isfield(obj.hybridOptions,'upstreamODEs')
                    speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                else
                    speciesStochastic = obj.species;
                end
                Nd = length(speciesStochastic);
                indsUnobserved=[];
                indsObserved=[];
                for i=1:Nd
                    if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                        indsUnobserved=[indsUnobserved,i];
                    else
                        indsObserved=[indsObserved,i];
                    end
                end

                % compute FIM for each time point
                fimResults = {};
                for it=length(sensSoln.data):-1:1
                    if isempty(indsUnobserved)
                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p, sensSoln.data{it}.S, obj.pdoOptions.PDO);
                    else
                        % Remove unobservable species.
                        redS = sensSoln.data{it}.S;
                        for ir = 1:length(redS)
                            redS(ir) = sensSoln.data{it}.S(ir).sumOver(indsUnobserved);
                        end

                        % Truncate to remove PDOs for unobserved species.
                        PDO = obj.pdoOptions.PDO;
                        if ~isempty(PDO)&&(length(PDO.conditionalPmfs)>length(obj.species)-length(indsUnobserved))
                            if length(PDO.conditionalPmfs)==length(obj.species)
                                PDO.conditionalPmfs = PDO.conditionalPmfs(indsObserved);
                                if ~isempty(PDO.dCdLam)
                                    PDO.dCdLam = PDO.dCdLam(indsObserved,indsObserved);
                                end
                            else
                                error('Not clear how to specify PDO for observed species')
                            end
                        end

                        % Update conditionalPmfs input size for calibrated PDO
                        if ~isempty(PDO)
                            if size(PDO.conditionalPmfs{1},2) <= size(redS(1).data)
                                max_xTrue = size(PDO.conditionalPmfs{1},2);
                                PDO_input = size(redS(1).data);
                                if PDO_input > max_xTrue
                                    % Padding
                                    disp("Padding conditionalPmfs input to increase size for PDO: " + max_xTrue + " to " + PDO_input)
                                    padding = zeros(size(PDO.conditionalPmfs{1}, 1), PDO_input - max_xTrue);
                                    PDO.conditionalPmfs{1} = [PDO.conditionalPmfs{1}, padding];
                                elseif PDO_input < max_xTrue
                                    % Cropping
                                    disp("Warning! Cropping conditionalPmfs input size ? " + max_xTrue + " to " + PDO_input)
                                    PDO.conditionalPmfs{1} = PDO.conditionalPmfs{1}(:, 1:PDO_input);
                                end
                            end
                        end

                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p.sumOver(indsUnobserved), redS, PDO);
                    end
                    fimResults{it,1} = F;
                end

                % TODO -- We need to add capability for the PDO parameters
                % to be included in the FIM calculation in log space.
                % Right now, the following will give an error because the
                % dimensions will not match when PDO parameters are
                % included.  Also, the current code does not allow for some
                % PDO parameters to be free while others are fixed.

                if strcmp(scale,'log')
                    for it=length(sensSoln.data):-1:1
                        fimResults{it,1} = diag([obj.parameters{:,2}])*...
                            fimResults{it,1}*...
                            diag([obj.parameters{:,2}]);
                    end
                end

            end
        end

        function [fimTotal,mleCovEstimate,fimMetrics] = evaluateExperiment(obj,...
                fimResults,cellCounts,priorCoVariance)
            % This function evaluates the provided experiment design (in
            % "cellCounts" and produces an array of FIMs (one for each
            % parameter set.
            arguments
                obj
                fimResults
                cellCounts
                priorCoVariance = []
            end

            Ns = size(fimResults,2);
            Nt = size(fimResults,1);
            Np = size(fimResults{1,1},1);
            fimTotal = cell(1,Ns);
            mleCovEstimate = cell(1,Ns);

            % Add the prior covariance into the FIM calculation if
            % provided. The prior covariance should be in the same scale as
            % the parameters (e.g.m linear, log, or log10).
            if isempty(priorCoVariance)
                PriorFIM = zeros(Np);
            else
                PriorFIM = inv(priorCoVariance);
            end

            for is=1:Ns
                fimTotal{is} = PriorFIM; %0*fimResults{1,is};

                for it=1:Nt
                    fimTotal{is} = fimTotal{is} + cellCounts(it)*fimResults{it,is};
                end

                if nargout>=2
                    % Estimate MLE covariance
                    if rank(fimTotal{is})<Np
                        disp(['FIM has rank ',num2str(rank(fimTotal{is})),' and is not invertable for this experiment design'])
                        mleCovEstimate{1,is} = NaN*ones(Np);
                    else
                        mleCovEstimate{1,is} = fimTotal{is}^-1;
                    end
                end
            end

            if nargout>=3
                for is = Ns:-1:1
                    % Compute FIM metrics.
                    fimMetrics.det(1,is) = det(fimTotal{is});
                    fimMetrics.trace(1,is) = trace(fimTotal{is});
                    fimMetrics.minEigVal(1,is) = min(eig(fimTotal{is}));
                end
            end
        end

        function [NcDNewDesign] = optimizeCellCounts(obj,fims,nCellsTotalNew,FIMMetric,...
                NcGuess,NcFixed,NcMax,statistic,covPrior,incrementAdd)
            %% SSIT.optimizeCellCounts - This function optimizes the number
            %% of cells per time point according to the user-provide metric.
            %
            % Inputs:
            %   * 'fims' - either an [Nt x 1] cell array containing the FIM
            %      matrices for each of the Nt time points, or an [Nt x Ns]
            %      cellarray containing the FIM for each combination of Nt
            %      time points and Ns different parameter sets
            %   * 'nCellsTotalNew' - the total number of cells to be
            %       measured, spread out among the Nt time points
            %   * 'FIMmetric' - type of optimization, allowable metrics are:
            %       'Determinant' - maximize the expected determinant of
            %                       the FIM
            %       'DetCovariance' - minimize the expected determinant of
            %                         MLE covariance
            %       'Smallest Eigenvalue' - maximize the smallest e.val of
            %                               the FIM
            %       'Trace' - maximize the trace of the FIM
            %       '[<i1>,<i2>,...]' - minimize the determinant of the
            %                           inverse FIM for the specified
            %                           indices, (all other parameters are
            %                           assumed to be free)
            %       'TR[<i1>,<i2>,...]' - maximize the determinant of the
            %                             FIM for the specified indices,
            %                             (only the parameters in
            %                             obj.fittingOptions.modelVarsToFit
            %                             are assumed to be free)
            %   * 'Nc' - an optimal guess for the optimal experiment
            %            design
            %   * 'NcFixed' - a minimal number of cells to measure at each
            %      time point; this is useful for subsequent experiment
            %      design, having already obtained measured cells from a
            %      previous experiment
            %   * 'NcMax' - maximum total number of cells allowed for each
            %      time point; this is useful in simulated experiment design,
            %      where there are only so many cells available in the real
            %      data
            %
            % Outputs:
            %   * 'Nc' is the optimized experiment design (number of cells
            %      to measure at each point in time)
            %
            % Example: Model.optimizeCellCounts(fimResults,nCellsTotal,...
            %           'Determinant',[],[],[],[],diag(log10.^2));
            arguments
                obj
                fims
                nCellsTotalNew
                FIMMetric = 'Smallest Eigenvalue'
                NcGuess = []
                NcFixed = []
                NcMax = []
                statistic = 'mean'
                covPrior = []
                incrementAdd = 1
            end
            if mod(nCellsTotalNew,incrementAdd)~=0
                error('Number of cells must be evenly divisible by incrementAdd.')
            end
            switch FIMMetric
                case 'Determinant'
                    met = @(A)-max(0,det(A));
                case 'DetCovariance'
                    met = @(A)max(0,det(inv(A)));
                case 'Smallest Eigenvalue'
                    met = @(A)-min(eig(A));
                case 'Trace'
                    met = @(A)-trace(A);
                otherwise
                    if strcmp(FIMMetric(1:2),'TR')
                        k = eval(FIMMetric(3:end));
                        met = @(A)max(0,det(inv(A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'tr')
                        k = eval(FIMMetric(3:end));
                        met = @(A)-max(0,det((A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'GR')
                        k = eval(FIMMetric(3:end));
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    else  % all parameters are free.
                        k = eval(FIMMetric);
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    end
            end
            NT = size(fims,1);
            NS = size(fims,2);

            if isempty(NcFixed)
                NcFixed = zeros(1,NT);
            end

            if isempty(NcMax)
                NcMax = inf*ones(1,NT);
            end

            if isempty(NcGuess)
                % Distributed avaliable cells among experiments.
                NcGuess = NcFixed;
                iExpt = 1;
                while nCellsTotalNew>0&&iExpt<=length(NcGuess)
                    avblSlots = NcMax(iExpt) - NcFixed(iExpt);
                    if avblSlots>=nCellsTotalNew
                        NcGuess(iExpt) = NcGuess(iExpt) + nCellsTotalNew;
                        iExpt = inf;
                    else
                        while avblSlots >= incrementAdd
                            NcGuess(iExpt) = NcGuess(iExpt) + incrementAdd;
                            nCellsTotalNew = nCellsTotalNew - incrementAdd;
                            avblSlots = avblSlots - incrementAdd;
                        end
                        iExpt = iExpt + 1;
                        if iExpt>length(NcGuess)&&nCellsTotalNew>=0
                            NcDNewDesign = NcGuess - NcFixed;
                            warning('All cells have been distributed.')
                            return
                        end
                    end
                end
            else
                NcGuess = NcFixed+NcGuess;
            end

            % Process to search for optimal experiment
            Converged = 0;
            while Converged==0
                Converged = 1;
                % Iterate through the time points
                for i = 1:NT
                    % If
                    while NcGuess(i)-incrementAdd>=NcFixed(i)
                        Ncp = NcGuess;
                        Ncp(i) = Ncp(i)-incrementAdd;
                        k = SSIT.findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd);
                        if k==i
                            break
                        end
                        NcGuess = Ncp;
                        NcGuess(k)=NcGuess(k)+incrementAdd;
                        Converged = 0;
                    end
                end
            end
            NcDNewDesign = NcGuess - NcFixed;
        end

        %% Data Loading and Fitting
        function [obj] = loadData(obj,dataFileName,linkedSpecies,conditions)
            % SSIT.loadData - Reads data from given file and associates
            % it with specified model species and experimental conditions.
            %
            % Inputs:
            %   * obj
            %   * dataFileName - name of data file, e.g., "dataFile.csv"
            %   * linkedSpecies - takes two strings: first, the names of
            %   the species given to the SSIT model using the 'species'
            %   property (e.g., Model.species = {'RNA','Protein'}); and
            %   second, the names of the species in the data file (e.g.,
            %   {'RNA','x1';'Protein','x2'})
            %   * conditions - data conditions that can be used to filter
            %                out data that do not meet specifications,
            %                e.g., conditions = {'Rep_num','1'}  : only
            %                the data in the 'Rep_num' column that is
            %                exactly equal to '1' will be kept in the
            %                data set
            %
            % Example:
            %   Model = Model.loadData("/data/dataFile.csv",...
            %    {'RNA','x1';'Protein','x2'},...
            %    {'Drug_Conc',100});
            arguments
                obj
                dataFileName
                linkedSpecies
                conditions = {};
            end
            obj.dataSet =[];
            if ischar(dataFileName)||isstring(dataFileName)
                TAB = readtable(dataFileName);
            elseif iscell(dataFileName)
                TAB = table;
                for iCell = 1:length(dataFileName)
                    iTAB = readtable(dataFileName{iCell});
                    TAB = [TAB;iTAB];
                end
            end

            % Find time column
            timeField = TAB.Properties.VariableNames(contains(lower(TAB.Properties.VariableNames),'time'));
            if isempty(timeField)
                error('Data sheet does not have an entry with keyword "time"');
            elseif length(timeField)>2
                error('Data sheet has more than one entry with keyword "time"');
            end

            % Apply conditions
            for i = 1:size(conditions,1)
                if size(conditions,2)==2
                    if isnumeric(conditions{i,2})&&isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB(TAB.(conditions{i,1})==conditions{i,2},:);
                    elseif ischar(conditions{i,2})&&iscell(TAB.(conditions{i,1})(1))&&ischar(TAB.(conditions{i,1}){1})
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif ischar(conditions{i,2})&&ischar(TAB.(conditions{i,1})(1))
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB((TAB.(conditions{i,1}))==eval(conditions{i,2}),:);
                    end
                else
                    try
                        eval(['TAB = TAB(TAB.(conditions{i,1})',conditions{i,3},'conditions{i,2},:);'])
                    catch
                        eval(['TAB = TAB(',conditions{i,3},',:);'])
                    end
                end
            end
            obj.dataSet.DATA = table2cell(TAB);

            % Link Species
            % First, make sure that all linked species are in the order of
            % species.
            iSpe = [];
            for i = 1:length(obj.species)
                if max(contains(linkedSpecies(:,1),obj.species(i)))
                    j = find(strcmp(linkedSpecies(:,1),obj.species(i)));
                    iSpe = [iSpe,j];
                end
            end
            linkedSpecies = linkedSpecies(iSpe,:);

            TAB2 = table;
            TAB2.time = TAB.(timeField{1});
            for i = 1:size(linkedSpecies,1)
                if ~isempty(linkedSpecies{i,2})
                    TAB2.(linkedSpecies{i,1}) = TAB.(linkedSpecies{i,2});
                elseif ~isempty(linkedSpecies{i,3})
                    % This section allows for manipulation of data columns.
                    % Example: linkedSpecies = {'rna',[],'TAB.nuc+TAB.cyt'}
                    % results in TAB2.rna = TAB.nuc+TAB.cyt
                    eval(['TAB2.',linkedSpecies{i,1},' = ',linkedSpecies{i,3},';']);
                end

            end

            % Reorder table in order of species list
            [~,iA] = intersect(linkedSpecies(:,1),obj.species,'stable');
            TAB2 = TAB2(:,[1,iA'+1]);

            % dataTensor = sptensor(
            times = unique(TAB2.time);
            numTimes = length(times);
            timeAr = TAB2.time;
            for i = 1:numTimes
                timeAr(TAB2.time==times(i)) = i-1;
            end
            TAB2.time = timeAr;

            % Construct sparse tensor to hold data.
            TAB2.Variables = max(0,TAB2.Variables);
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor = sptensor(TAB2.Variables+1,ones(size(TAB2,1),1));

            % Define other properties needed in other functions.
            obj.dataSet.linkedSpecies = linkedSpecies;
            obj.dataSet.times = times';

            obj.dataSet.app.SpeciesForFitPlot.Items = obj.species;
            obj.dataSet.app.SpeciesForFitPlot.Items = linkedSpecies(:,1);
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = times';
            for i=1:numTimes
                obj.dataSet.app.ParEstFitTimesList.Items{i} = num2str(times(i));
            end
            obj.dataSet.app.ParEstFitTimesList.Value = obj.dataSet.app.ParEstFitTimesList.Items;


            %%
            sz = size(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor);
            obj.dataSet.nCells=zeros(sz(1),1);
            for i=1:sz(1)
                if length(sz)==2
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:)),'all');
                elseif length(sz)==3
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:)),'all');
                elseif length(sz)==4
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:)),'all');
                elseif length(sz)==5
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:,:)),'all');
                end
            end

            obj.tSpan = unique([obj.initialTime,obj.dataSet.times]);

            % Calculate the means and variances
            obj.dataSet.mean = zeros(sz(1),length(sz)-1);
            obj.dataSet.var = zeros(sz(1),length(sz)-1);
            for i=1:sz(1)
                for j=2:length(sz)
                    tmpInt{j-1} = [1:sz(j)];
                end
                TMP = squeeze(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,tmpInt{:})));
                for j = 1:length(sz)-1
                    if length(sz)>2
                        H = sum(TMP,[1:j-1,j+1:length(sz)-1]);
                    else
                        H = TMP;
                    end
                    obj.dataSet.mean(i,j) = sum([0:length(H)-1]'.*H(:))/sum(H);
                    x2 = sum(([0:length(H)-1].^2)'.*H(:))/sum(H);
                    obj.dataSet.var(i,j) = x2 - obj.dataSet.mean(i,j)^2;
                end
            end

            %% Automatically set unobserved species based on loaded data.
            obj.pdoOptions.unobservedSpecies = setdiff(obj.species,linkedSpecies(:,1),'stable')';

        end

        function [logL,gradient] = minusLogL(obj,pars,stateSpace,computeSensitivity)
            [logL,gradient] = computeLikelihood(obj,exp(pars),stateSpace,computeSensitivity);
            logL = -logL;
            gradient = -gradient.*exp(pars);
        end

        function [logLode] = computeLikelihoodODE(obj,pars,SIG)
            arguments
                obj
                pars = [];
                SIG = [];
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                logTimesToFit = ones(1,length(obj.dataSet.times),'logical');
            else
                logTimesToFit = obj.fittingOptions.timesToFit;
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                indsParsToFit = [1:length(obj.parameters)];
            else
                indsParsToFit = obj.fittingOptions.modelVarsToFit;
            end
            nModelPars = length(indsParsToFit);

            if isempty(pars)
                pars = [obj.parameters{indsParsToFit,2}];
            end

            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            originalPars = obj.parameters;
            obj.tSpan = unique([obj.initialTime,obj.tSpan,obj.dataSet.times]);
            [~,IA,~] = intersect(obj.tSpan,obj.dataSet.times(logTimesToFit));

            % Update Model and PDO parameters using supplied guess
            obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

            obj.solutionScheme = 'ode'; % Chosen solutuon scheme
            for i=1:size(obj.parameters,1)
                obj.parameters{i,2} = round(obj.parameters{i,2},12);
            end
            solutions = obj.solve;  % Solve the ODE analysis

            obj.parameters =  originalPars;

            % Need to add likelihood calculation here.
            nt = length(IA);
            %             ns = length(obj.species);

            for i = 1:size(obj.dataSet.linkedSpecies,1)
                J(i) = find(strcmp(obj.species,obj.dataSet.linkedSpecies{i,1}));
            end
            nds = length(J);

            nc = repmat(obj.dataSet.nCells(logTimesToFit),nds,1);

            vm = zeros(nt*nds,1);
            tmp = solutions.ode(IA,J);
            vm(:) = tmp(:);

            vd = zeros(nt*nds,1);
            vd(:) = obj.dataSet.mean(logTimesToFit,:);

            vm = real(vm);

            if isempty(SIG)
                % SIG = eye(nt*nds);
                vec = zeros(numel(obj.dataSet.var(logTimesToFit,:)),1);
                vec(:) = obj.dataSet.var(logTimesToFit,:);
                SIG = diag(vec);
            end

            logLode = -1/2*(sqrt(nc)'.*(vd-vm)')*SIG^(-1)*((vd-vm).*sqrt(nc));
            logLode = logLode+logPrior;
        end

        function [logL,gradient,fitSolutions] = computeLikelihood(obj,pars, ...
                stateSpace,computeSensitivity,reuseExistingSolution)
            % This function computes the log likelihood of the data given
            % the model.
            % obj -- (SSIT class)
            % pars -- parameters of model in linear space.  Matches the
            %   order in obj.parameters, and downselected to the free
            %   parameters in obj.fittingOptions.modelVarsToFit.
            % stateSpace -- (optional) statespace for FSP solution.
            %   providing increases efficiency.
            % computeSensitivity -- (false) flag to request
            %   sensitivity of loglkelihood functon wrt parameters as a
            %   returned variable.
            % reuseExistingSolution -- (false) flag to reuse existing SSIT
            %   solutions already in memory.
            arguments
                obj
                pars = [];
                stateSpace =[];
                computeSensitivity = false;
                reuseExistingSolution = false
            end

            if reuseExistingSolution
                solutions = obj.Solutions;  % Solve the FSP analysis

            else
                % Reset state space if it has inconsistencies
                if ~isempty(stateSpace)&&size(stateSpace.states,2)~=length(stateSpace.state2indMap.keys)
                    stateSpace =[];
                end

                % select which parameters to consider in likelihood function
                % first for the model parameters
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    indsParsToFit = [1:length(obj.parameters)];
                else
                    indsParsToFit = obj.fittingOptions.modelVarsToFit;
                end
                nModelPars = length(indsParsToFit);

                % then for PDO parameters
                if strcmp(obj.fittingOptions.pdoVarsToFit,'all')
                    indsPdoParsToFit = [1:length(obj.pdoOptions.props.ParameterGuess)];
                else
                    indsPdoParsToFit = obj.fittingOptions.pdoVarsToFit;
                end
                nPdoPars = length(indsPdoParsToFit);

                % if parameters are not provided, use the ones stored in the
                % SSIT object.
                if isempty(pars)
                    pars = [obj.parameters{indsParsToFit,2}];
                end

                % save original parameters
                originalPars = obj.parameters;

                % remove duplicates from time span
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);

                % Update Model and PDO parameters using supplied guess
                obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));


                % TODO - it would be nice to be able to reuse existing
                % solutions, but for this to work robustly, we need to have
                % some means to check that the old solutions is for the exact
                % same conditions and paramters as the new one.
                % if max(abs([originalPars{:,2}]-[obj.parameters{:,2}]))==0&&~isempty(obj.Solutions)&&...
                %         (strcmpi(obj.solutionScheme,'fsp')&&~isempty(obj.Solutions.fsp))||...
                %         (strcmpi(obj.solutionScheme,'fspsens')&&~isempty(obj.Solutions.sens))
                %
                %     solutions = obj.Solutions;
                % else
                % Call routines to find the FSP solution with or without
                % sensitivity.
                if computeSensitivity&&nargout>=2
                    obj.solutionScheme = 'fspSens'; % Chosen solution scheme
                    [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
                else
                    obj.solutionScheme = 'FSP'; % Chosen solution scheme
                    [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
                end
                obj.parameters =  originalPars; % Reset back to the original parameters.
                % end
            end

            % if there is no logprior, use zero.
            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            % Formulate PDO if one is used and it has adjustable
            % parameters.
            if ~isempty(pars)&&nPdoPars>0
                obj.pdoOptions.props.ParameterGuess(indsPdoParsToFit) = pars(nModelPars+1:end);
                obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
            end

            % Separate out stochastic species if using a hybrid ode/fsp
            % model.
            if obj.useHybrid
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            else
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                fitSolutions.ParEstFitTimesList.Value = fitSolutions.ParEstFitTimesList.Items(obj.fittingOptions.timesToFit);
                timesToFit = zeros(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
                timesToFit(obj.fittingOptions.timesToFit) = true;
                obj.fittingOptions.timesToFit = timesToFit;

            end

            dataTensor = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            timesData = dataTensor.subs(:,1);
            timesUnique = unique(timesData);

            % Map measurement times to the solution times.
            J = zeros(1,length(obj.dataSet.times(obj.fittingOptions.timesToFit)));
            for it = 1:length(J)
                [~,J(it)] = min(abs(obj.tSpan-obj.dataSet.times(it)));
            end
            if ~computeSensitivity||nargout<2
                fsp = solutions.fsp(J);
            elseif computeSensitivity&&nargout>=2
                sens = solutions.sens.data(J);
            end
            numTimes = length(J);

            Nd = length(speciesStochastic);
            for i=Nd:-1:1
                indsPlots(i) = max(contains(obj.dataSet.linkedSpecies(:,1),speciesStochastic(i)));
            end
            indsIgnore = setdiff([1:Nd],find(indsPlots),'stable');

            LogLk = zeros(1,numTimes);

            % Set up storage for outputs if requested.
            if nargout>=3
                perfectMod = zeros(1,numTimes);
                numCells = obj.dataSet.nCells(obj.fittingOptions.timesToFit)';
                sz = [numTimes,max(solutions.stateSpace.states,[],2)'];
                sz = sz([true,indsPlots]);
                fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = sptensor(sz);
            end

            for it = 1:numTimes
                if ~computeSensitivity||nargout<2
                    % get FSP solution for current time.
                    px = fsp{it}.p;
                elseif computeSensitivity&&nargout>=2
                    px = sens{it}.p;
                    Sx = sens{it}.S;
                    parCount = length(Sx);
                    % Add effect of PDO.
                    if ~isempty(obj.pdoOptions.PDO)
                        for iPar = 1:parCount
                            Sx(iPar) = obj.pdoOptions.PDO.computeObservationDistDiff(px, Sx(iPar), iPar);
                        end
                    end
                    % Remove ignored species
                    for iPar = parCount:-1:1
                        if ~isempty(indsIgnore)
                            S{iPar} = Sx(iPar).sumOver(indsIgnore);
                        else
                            S{iPar} = Sx(iPar);
                        end
                        % S{iPar}(it,d~=0) = d(d~=0);
                    end
                end
                % Add effect of PDO.
                if ~isempty(obj.pdoOptions.PDO)
                    try
                        px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                    catch
                        obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
                        px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                    end
                end
                % Sum over the marginalization indices (if any). The return
                % result as a double vector.
                if ~isempty(indsIgnore)
                    px = px.sumOver(indsIgnore);
                end

                % Get indices and number of all observed data.
                inds = dataTensor.subs(timesData==timesUnique(it),2:end);
                vals = dataTensor.vals(timesData==timesUnique(it));
                szData = max(inds);

                % Pad Probability Distribution if support does not cover
                % all data.
                Pvals = px.data;
                szModel = size(Pvals);
                if max(szData-szModel)>0
                    Pvals(szData)=0;
                end

                Pvals = real(max(1e-10,double(Pvals)));
                Pvals = Pvals/max(1,sum(Pvals,'all'));
                logP = sptensor(log(Pvals));

                LogLk(it) = vals'*logP(inds);

                if nargout>=3
                    perfectMod(it) = vals'*log(vals/sum(vals));
                    Pvt = sptensor(Pvals);
                    if length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs(:,1:end-1)]) = Pvt.vals;
                    elseif length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))-1
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs]) = Pvt.vals;
                    end
                end

                if computeSensitivity&&nargout>=2
                    for iPar = parCount:-1:1
                        St = S{iPar};
                        Svals = double(St.data);
                        dlogL_dPar(iPar,it) = sum(vals'*(Svals(inds)./Pvals(inds)));
                    end
                end
            end
            % P =
            % solnTensor = sptensor([length(solutions.fsp),max(solutions.stateSpace.states,[],2)'+1]);
            % solnT


            %%

            % Store data and model information for use in other routines.
            % The format used here is chosen to match an existing object in
            % the SSIT GUI.
            if nargout>=3
                % Make Full Tensor for Plotting
                for it = 1:numTimes


                end


                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = zeros([numTimes,sz(2:end)]);
                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData = zeros([numTimes,sz(2:end)]);
                fitSolutions.NameTable.Data = [speciesStochastic,speciesStochastic];
                fitSolutions.SpeciesForFitPlot.Value = speciesStochastic(indsPlots);
                fitSolutions.SpeciesForFitPlot.Items = speciesStochastic;
                fitSolutions.DataLoadingAndFittingTabOutputs.dataTensor = dataTensor;
                fitSolutions.FspPrintTimesField.Value = ['[',num2str(obj.tSpan),']'];
                if ~computeSensitivity
                    fitSolutions.FspTabOutputs.solutions = solutions.fsp;
                else
                    fitSolutions.FspTabOutputs.solutions = solutions;
                end
                fitSolutions.FIMTabOutputs.distortionOperator = obj.pdoOptions.PDO;
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.dataTimes = obj.dataSet.times(obj.fittingOptions.timesToFit);
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = timesUnique;
            end

            % % Initialize sensitivity derivative if needed.
            % if computeSensitivity&&nargout>=2
            %     dlogL_dPar = zeros(parCount,numTimes);
            % end
            %
            % % Initialize log likelihood at zero for all times.
            % % LogLk = zeros(1,numTimes);
            % KS = zeros(1,numTimes);
            % numCells = zeros(1,numTimes);
            %
            % % LogL for idealized models
            % perfectMod = zeros(1,numTimes);
            % perfectModSmoothed = zeros(1,numTimes);
            %
            % for i=1:numTimes
            %     % Find the closes time index
            %     [diffTime,j] = min(abs(obj.tSpan-obj.dataSet.times(i)));
            %     if diffTime~=0
            %         warning('Exact match not found for time. Inaccuracies possible.')
            %     end
            %
            %     Jind = PD.subs(:,1) == i;
            %     SpInds = PD.subs(Jind,:);
            %
            %     SpVals = PD.vals(Jind);
            %     H = sptensor([ones(length(SpVals),1),SpInds(:,2:end)],SpVals,[1,NDat(2:end)]);
            %     H = double(H);
            %     Pt = P(j,:,:,:,:,:,:,:,:,:);
            %     Pt = Pt/max(1,sum(Pt,'all'));
            %     % LogLk(i) = sum(H(:).*log(Pt(:)));
            %     numCells(i) = sum(H(:));
            %     if computeSensitivity&&nargout>=2
            %         for iPar = parCount:-1:1
            %             St = S{iPar}(j,:,:,:,:,:,:);
            %             dlogL_dPar(iPar,i) = sum(H(:).*St(:)./Pt(:));
            %         end
            %     end
            %     if nargout>=3
            %         Q = H(:)/sum(H(:));
            %         KS(i) = max(abs(cumsum(Q(:))-cumsum(Pt(:))));
            %         smQ = smooth(Q); smQ=smQ/sum(smQ);
            %         logQ = log(Q); logQ(H==0)=1;
            %         logSmQ = log(smQ); logSmQ(H==0)=1;
            %         perfectMod(i) = sum(H(:).*logQ);
            %         perfectModSmoothed(i) = sum(H(:).*logSmQ);
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current(i,:,:,:,:,:,:) = Pt;
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:,:,:,:) = ...
            %             reshape(Q,size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:)));
            %     end
            % end
            logL = sum(LogLk) + logPrior;

            if imag(logL)~=0
                disp('Imaginary likelihood set to -inf.')
                logL = -inf;
            end
            if nargout>=3
                fitSolutions.DataLoadingAndFittingTabOutputs.V_LogLk = LogLk;
                fitSolutions.DataLoadingAndFittingTabOutputs.numCells = numCells;
                fitSolutions.DataLoadingAndFittingTabOutputs.perfectMod = perfectMod;
                % fitSolutions.DataLoadingAndFittingTabOutputs.perfectModSmoothed = perfectModSmoothed;
                % fitSolutions.DataLoadingAndFittingTabOutputs.V_KS = KS;
            end
            if computeSensitivity&&nargout>=2
                gradient = sum(dlogL_dPar,2); % need to also add gradient wrt prior!!
            else
                gradient = [];
            end
        end


        function [lossFunction] = computeLossFunctionSSA(obj,lossFun,pars, ...
                enforceIndependence, reuseExistingSolution)
            % This function computes general loss functions forthe data given
            % the model.
            % obj -- (SSIT class)
            % lossFun -- ('cdf_one_norm') Name of predefined loss function
            % or handle to user-defined loss function. If using a
            % userdefined loss function, it should take as inputs the
            % histograms Hdata and Hmodel which will be evaluated for every
            % time point and every species and the results will be summed
            % together. Example:
            %       customLossMeans = @(Hmod,Hdata)([0:length(Hmod)-1]*Hmod-[0:length(Hdata)-1]*Hdata).^2;
            % pars -- parameters of model in linear space.  Matches the
            %   order in obj.parameters, and downselected to the free
            %   parameters in obj.fittingOptions.modelVarsToFit.
            % enforceIndependence -- (false) flag to decide if SSA runs are
            % split up to ensure each time point has independent data
            % points.
            % reuseExistingSolution -- (false) flag to reuse existing SSIT
            %   solutions already in memory.
            arguments
                obj
                lossFun = 'KS'
                pars = [];
                enforceIndependence = true
                reuseExistingSolution = false
            end

            if ~strcmpi(obj.solutionScheme,'ssa')
                error('computeLossFunctionSSA only meant for models using SSA solution scheme. Please change solutionScheme and try again.')
            end

            if reuseExistingSolution
                solutions = obj.Solutions;  % Load previous model solutions.

            else

                % Select which parameters to consider in loss function
                % first for the model parameters
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    indsParsToFit = [1:length(obj.parameters)];
                else
                    indsParsToFit = obj.fittingOptions.modelVarsToFit;
                end
                nModelPars = length(indsParsToFit);

                % then for PDO parameters
                if strcmp(obj.fittingOptions.pdoVarsToFit,'all')
                    indsPdoParsToFit = [1:length(obj.pdoOptions.props.ParameterGuess)];
                else
                    indsPdoParsToFit = obj.fittingOptions.pdoVarsToFit;
                end
                nPdoPars = length(indsPdoParsToFit);

                % Formulate PDO if one is used and it has adjustable
                % parameters.
                if ~isempty(pars)&&nPdoPars>0
                    obj.pdoOptions.props.ParameterGuess(indsPdoParsToFit) = pars(nModelPars+1:end);
                    obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
                end

                % If parameters are not provided, use the ones stored in the
                % SSIT object.
                if isempty(pars)
                    pars = [obj.parameters{indsParsToFit,2}];
                end

                % save original parameters for later recovery
                originalPars = obj.parameters;

                % remove duplicates from time span
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);

                % Update Model and PDO parameters using supplied guess
                obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

                % Solve model
                [solutions] = obj.solve;  % Solve the SSA analysis

                obj.parameters =  originalPars; % Reset back to the original parameters.
            end

            % If there is no logprior, use zero.
            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            else
                timesToFit = zeros(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
                timesToFit(obj.fittingOptions.timesToFit) = true;
                obj.fittingOptions.timesToFit = timesToFit;
            end


            dataTensor = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            timesData = dataTensor.subs(:,1);
            timesUnique = unique(timesData);

            % Map measurement times to the solution times.
            Jtime = zeros(1,length(obj.dataSet.times(obj.fittingOptions.timesToFit)));
            for it = 1:length(Jtime)
                [~,Jtime(it)] = min(abs(obj.tSpan-obj.dataSet.times(it)));
            end
            numTimes = length(Jtime);

            % Map measurement species to observed species;
            Jspecies = [];
            for is = 1:size(obj.dataSet.linkedSpecies,1)
                Jspecies = [Jspecies,find(strcmp(obj.species,obj.dataSet.linkedSpecies{is,1}))];
            end
            numSpecies = length(Jspecies);

            % Extract SSA solutions at data times.
            if isempty(obj.pdoOptions.PDO)
                ssaTrajs = solutions.trajs(Jspecies,Jtime,:);
            else
                ssaTrajs = solutions.trajsDistorted(Jspecies,Jtime,:);
            end

            % Find 1D Histograms for Data and Model
            Hdata = cell(numSpecies,numTimes);
            Hmod = cell(numSpecies,numTimes);
            for is = 1:numSpecies
                sumOver = [1:is-1,is+1:numSpecies];
                if isempty(sumOver)
                    dataVecP = full(dataTensor);
                else
                    dataVecP = sum(full(dataTensor),sumOver);
                end
                for it = 1:numTimes
                    % Find CDF of current species and time from
                    % data.
                    dataVecPt = double(dataVecP(it,:));
                    H = cumsum(dataVecPt);
                    Hdata{is,it} = H/H(end);

                    % Find CDF of current species and time from
                    % model.
                    if enforceIndependence
                        npe = obj.ssaOptions.nSimsPerExpt;
                        modelVec = squeeze(ssaTrajs(is,it,(it-1)*npe+1:it*npe));
                    else
                        modelVec = squeeze(ssaTrajs(is,it,:));
                    end
                    H = cumsum(histcounts(modelVec,[0:max(max(modelVec),length(H))]))';
                    Hmod{is,it}=H/H(end);

                    % Pad the shorter of the two vectors.
                    if length(Hdata{is,it})>length(Hmod{is,it})
                        Hmod{is,it}(end+1:length(Hdata{is,it})) = 1;
                    elseif length(Hdata{is,it})<length(Hmod{is,it})
                        Hdata{is,it}(end+1:length(Hmod{is,it})) = 1;
                    end
                end
            end

            if isa(lossFun,'function_handle')
                lossFunction = 0;
                for is = 1:numSpecies
                    for it = 1:numTimes
                        lossFunction = lossFunction + lossFun(Hmod{is,it},Hdata{is,it});
                    end
                end
            else

                switch lower(lossFun)
                    case 'cdf_one_norm'
                        lossFunction = 0;
                        for is = 1:numSpecies
                            for it = 1:numTimes
                                lossFunction = lossFunction + sum(abs(Hmod{is,it}-Hdata{is,it}));
                            end
                        end
                    case 'maxks'
                        lossFunction = 0;
                        for is = 1:numSpecies
                            for it = 1:numTimes
                                lossFunction = max(lossFunction,max(abs(Hmod{is,it}-Hdata{is,it})));
                            end
                        end
                    case ''

                    otherwise
                        error(['Loss function ''',lossFun,''' not defined'])
                end
            end
        end

        function fitErrors = likelihoodSweep(obj,parIndices,scalingRange,makePlot)
            % likelihoodSweep - sweep over range of parameters and return
            % likelihood function values at all parameter combinations.
            arguments
                obj
                parIndices
                scalingRange = linspace(0.5,1.5,15);
                makePlot = false
            end
            obj.fittingOptions.modelVarsToFit = parIndices;  % Choose which parameters to vary.
            pars0 = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];

            fspSoln = obj.solve();
            stateSpace = fspSoln.stateSpace;

            Ngrid=length(scalingRange);
            fitErrors = zeros(Ngrid,Ngrid);

            likeFunction = @(pars)obj.computeLikelihood(pars,stateSpace);
            for i = 1:Ngrid
                parfor j = 1:Ngrid
                    pars = pars0.*scalingRange([i,j]);
                    fitErrors(i,j) = likeFunction(pars);
                end
            end
            if makePlot
                fg = figure;
                set(0,'CurrentFigure',fg);
                if length(parIndices)>2
                    disp('plots are only created for first two parameters')
                end

                % Set minimum contour at -300
                lkhMin = max(fitErrors,[],'all')-300;
                contourf(scalingRange*pars0(1),scalingRange*pars0(2),max(fitErrors',lkhMin),30)
                set(gca,'fontsize',15)
                xlabel(obj.parameters{obj.fittingOptions.modelVarsToFit(1)});
                ylabel(obj.parameters{obj.fittingOptions.modelVarsToFit(2)});
                colorbar
                hold on

                [tmp,I] = max(fitErrors);
                [~,Jtime] = max(tmp);
                plot(scalingRange([1,Ngrid])*pars0(1),pars0(2)*[1,1],'k--','linewidth',3)
                plot(pars0(1)*[1,1],scalingRange([1,Ngrid])*pars0(2),'k--','linewidth',3)
                plot(pars0(1)*scalingRange(I(Jtime)),pars0(2)*scalingRange(Jtime),'ro','MarkerSize',20,'MarkerFaceColor','r')
            end
        end
        % WARNING: returns height of posterior instead of likelihood if priors are specified
        function [pars,likelihood,otherResults,obj] = maximizeLikelihood(obj,parGuess,fitOptions,fitAlgorithm)
            arguments
                obj
                parGuess = [];
                fitOptions = optimset('Display','iter','MaxIter',2000);
                fitAlgorithm = 'fminsearch';
            end
            % Compute the maximum likelihood estimate (if priors are not
            % provided) or the maximum posterior estimate (if priors are
            % provided).  

            % parse fitting options
            allFitOptions.suppressFSPExpansion = true;
            fNames = fieldnames(fitOptions);
            for i=1:length(fNames)
                allFitOptions.(fNames{i}) = fitOptions.(fNames{i});
            end

            if isempty(obj.propensitiesGeneral)
                obj = formPropensitiesGeneral(obj);
            end

            if ischar(obj.fittingOptions.modelVarsToFit)&&strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = (1:size(obj.parameters,1));
            end
            if isempty(parGuess)
                parGuess = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}]';
            end

            if strcmpi(obj.solutionScheme,'fspsens')   % Set solution scheme to FSP.
                obj.solutionScheme='FSP';
            end

            if strcmpi(obj.solutionScheme,'FSP')   % Set solution scheme to FSP.
                [FSPsoln,~,obj] = obj.solve;  % Solve the FSP analysis
                % obj.fspOptions.bounds = bounds;% Save bound for faster analyses
                if allFitOptions.suppressFSPExpansion
                    tmpFSPtol = obj.fspOptions.fspTol;
                    obj.fspOptions.fspTol = inf;
                end
                objFun = @(x)-obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
            elseif strcmpi(obj.solutionScheme,'ode')  % Set solution scheme to ode.
                objFun = @(x)-obj.computeLikelihoodODE(exp(x));  % We want to MAXIMIZE the likelihood.
            end

            x0 = log(parGuess);

            switch lower(fitAlgorithm)
                case 'fminsearch'
                    [x0,likelihood,~,otherResults]  = fminsearch(objFun,x0,allFitOptions);

                case 'fminunc'
                    obj.fspOptions.fspTol = inf;
                    objFun = @obj.minusLogL;  % We want to MAXIMIZE the likelihood.
                    x0 = log(parGuess);
                    [x0,likelihood]  = fminunc(objFun,x0,allFitOptions,FSPsoln.stateSpace,true);

                case 'particleswarm'
                    obj.fspOptions.fspTol=inf;
                    rng('shuffle')
                    OBJps = @(x)objFun(x');
                    LB = -5*ones(size(x0'));
                    UB = 5*ones(size(x0'));
                    initSwarm = repmat(x0',fitOptions.SwarmSize-1,1);
                    initSwarm = [x0';initSwarm.*(1+0.1*randn(size(initSwarm)))];
                    fitOptions.InitialSwarmMatrix = initSwarm;
                    [x0,likelihood] = particleswarm(OBJps,length(x0),LB,UB,allFitOptions);

                case 'mlsearch'
                    % Not yet working efficiently.
                    defaultFitOptions.maxIter=1000;
                    defaultFitOptions.burnIn=30;
                    defaultFitOptions.updateRate=10;
                    defaultFitOptions.guessRate=1000;
                    defaultFitOptions.proposalDistribution=@(x)x+0.01*randn(size(x));
                    defaultFitOptions.useFIMforSearch = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.plotFunVals = false;
                    defaultFitOptions.proposalDistributionWide=@(x)x+randn(size(x));

                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if allFitOptions.logForm
                        objFun = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = log(parGuess);
                    else
                        objFun = @(x)obj.computeLikelihood(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = (parGuess);
                    end

                    [x0,likelihood]  = mlSearch(objFun,x0,allFitOptions);

                case 'metropolishastings'

                    defaultFitOptions.isPropDistSymmetric=true;
                    defaultFitOptions.thin=1;
                    defaultFitOptions.numberOfSamples=1000;
                    defaultFitOptions.burnIn=0;
                    defaultFitOptions.progress=true;
                    defaultFitOptions.proposalDistribution=@(x)x+0.1*randn(size(x));
                    defaultFitOptions.numChains = 1;
                    defaultFitOptions.useFIMforMetHast = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.obj = [];

                    j=1;
                    while exist(['TMPmh_',num2str(j),'.mat'],'file')
                        j=j+1;
                    end
                    defaultFitOptions.saveFile = ['TMPmh_',num2str(j),'.mat'];

                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if isempty(allFitOptions.obj)
                        if allFitOptions.logForm
                            OBJmh = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        else
                            OBJmh = @(x)OBJfun(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        end
                    else
                        if allFitOptions.logForm
                            OBJmh = @(x)allFitOptions.obj(exp(x));
                        else
                            OBJmh = @(x)allFitOptions.obj(x);
                        end
                    end

                    if allFitOptions.logForm
                        x0 = log(parGuess);
                    else
                        x0 = (parGuess);
                    end

                    if allFitOptions.useFIMforMetHast
                        TMP = obj;
                        TMP.solutionScheme = 'fspSens'; % Set solutions scheme to FSP Sensitivity
                        [sensSoln] = TMP.solve;  % Solve the sensitivity problem

                        if allFitOptions.logForm
                            fimResults = TMP.computeFIM(sensSoln.sens,'log');
                        else
                            fimResults = TMP.computeFIM(sensSoln.sens);
                        end

                        % Call function to assemble full FIM from cell
                        % counts and prior covariance information.
                        if allFitOptions.logForm
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.logPriorCovariance);
                        else
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.priorCovariance);
                        end

                        FIMfree = FIM{1}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);

                        if allFitOptions.logForm&&min(eig(FIMfree))<1
                            disp('Warning -- FIM has one or more small eigenvalues.  Reducing proposal width to 10x in those directions. MH Convergence may be slow.')
                            FIMfree = FIMfree + 1*eye(length(FIMfree));
                        end

                        covFree = FIMfree^-1;
                        covFree = allFitOptions.CovFIMscale*(covFree+covFree')/2;
                        allFitOptions.proposalDistribution=@(x)mvnrnd(x,covFree);
                    end

                    if allFitOptions.suppressFSPExpansion
                        obj.fspOptions.fspTol = inf;
                    end

                    rng('shuffle')
                    if allFitOptions.numChains==1
                        [otherResults.mhSamples,otherResults.mhAcceptance,otherResults.mhValue,x0,likelihood] = ...
                            ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                            'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,...
                            'symmetric',allFitOptions.isPropDistSymmetric,...
                            'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                            'progress',allFitOptions.progress,...
                            'saveFileName',allFitOptions.saveFile);
                    else
                        try
                            parpool
                        catch
                        end
                        allFitOptions.progress=0;
                        clear tmpMH*
                        parfor iChain = 1:allFitOptions.numChains
                            [mhSamples, mhAcceptance, mhValue,xbest,fbest] = ...
                                ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                                'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,'symmetric',...
                                allFitOptions.isPropDistSymmetric,...
                                'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                                'progress',allFitOptions.progress);
                            tmpMHSamp(iChain) = {mhSamples};
                            tmpMHAcceptance(iChain) = {mhAcceptance};
                            tmpMHValue(iChain) = {mhValue};
                            tmpMHxbest(iChain) = {xbest};
                            tmpMHfbest(iChain) = fbest;
                        end
                        [~,jBest] = max(tmpMHfbest);
                        x0 = tmpMHxbest{jBest}';
                        otherResults.mhSamples = tmpMHSamp;
                        otherResults.mhAcceptance = tmpMHAcceptance;
                        otherResults.mhValue = tmpMHValue;
                        clear tmpMH*
                    end
                    % If fit was in linear space, need to convert to log
                    % space before returning parameters.
                    if ~allFitOptions.logForm
                        pars = log(x0);
                    end

            end

            pars = exp(x0);

            if strcmp(obj.solutionScheme,'FSP')&&allFitOptions.suppressFSPExpansion
                obj.fspOptions.fspTol = tmpFSPtol;
            end

            if nargout>=4
                % Update best parameters set in returned model.
                obj.parameters(obj.fittingOptions.modelVarsToFit,2) = num2cell(pars);
            end


        end

        %% Approximate Bayesian Computation
        function [pars,minimumLossFunction,Results,obj] = runABCsearch( ...
        obj, parGuess, lossFunction, logPriorLoss, fitOptions, enforceIndependence)

            % This function runs an MCMC for approximate Bayesian computing
            % (ABC) to sample an approximate posterior distribution.  
            %
            % Parameters:
            %    parGuess        -- ([]) initial guess of parameters. If empty,
            %                       the fit will start with the current model parameters.
            %    lossFunction    -- ('cdf_one_norm') choice of loss function or
            %                       function handle. Positive values are WORSE fits.
            %    logPriorLoss    -- (@(x)0) loss-style function for the prior
            %                       (e.g., quadratic in log10-space).
            %    fitOptions      -- ([]) options passed to maximizeLikelihood.
            %    enforceIndependence -- (false) downsample SSA to enforce
            %                       independence of simulated data points.
        
            arguments
                obj
                parGuess = []
                lossFunction = 'cdf_one_norm'
                logPriorLoss = @(x)0      % Loss contribution from prior
                fitOptions = []
                enforceIndependence logical = false
            end
        
            % Normalize empty inputs
            if isempty(lossFunction)
                lossFunction = 'cdf_one_norm';
            end
            if isempty(logPriorLoss)
                logPriorLoss = @(x)0;
            end
            if isempty(fitOptions)
                fitOptions = struct();
            end
        
            % Define the objective in *parameter* space (theta, not log-theta)
            %   - computeLossFunctionSSA returns a positive loss; we negate it
            %     because MetropolisHastings expects a logpdf-like quantity to maximize.
            %   - logPriorLoss should also be a loss (penalty), so we negate it too.
            fitOptions.obj = @(pars) ...
                -obj.computeLossFunctionSSA(lossFunction, pars, enforceIndependence) ...
                - logPriorLoss(pars);
        
            % Set parGuess if not provided.
            if isempty(parGuess)
                % If 'all', then change to list of indices.
                if ischar(obj.fittingOptions.modelVarsToFit)&&strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    obj.fittingOptions.modelVarsToFit = [1:size(obj.parameters,1)];
                end
                parGuess = cell2mat(obj.parameters(obj.fittingOptions.modelVarsToFit,2));
            end
            % This line will throw the error location if something is wrong:
            testVal = fitOptions.obj(parGuess);
        
            % Call MH as usual (this will internally wrap fitOptions.obj as
            % @(x) allFitOptions.obj(exp(x)), working in log-parameter space).
            [pars, minimumLossFunction, Results] = ...
                obj.maximizeLikelihood(parGuess, fitOptions, 'MetropolisHastings');
        end


        %% Model Reduction Functions
        function [obj,fspSoln] = computeModelReductionTransformMatrices(obj,fspSoln,phi)
            % This function computes linear transformation matrices (PHI
            % and PHIinv) that can be used to switch between the reduced
            % and origional FSP bases.
            arguments
                obj
                fspSoln = []
                phi = []
            end

            numConstraints = length(obj.fspOptions.bounds);

            if ~isfield(fspSoln,'stateSpace')
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                    % [~,IA] = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                    % stoich = obj.stoichiometry(IA,:);
                    % init = obj.initialCondition(IA,:);
                else
                    stoich = obj.stoichiometry;
                    init = obj.initialCondition;
                end
                fspSoln.stateSpace = ssit.FiniteStateSet(init, stoich);
                fspSoln.stateSpace = fspSoln.stateSpace.expand(obj.fspConstraints.f, obj.fspConstraints.b);

            end

            % Assemble for generator matrix for original FSP problem.
            if ~isfield(fspSoln,'A_total')
                fspSoln.Afsp = ssit.FspMatrix(obj.propensitiesGeneral, [obj.parameters{:,2}]', fspSoln.stateSpace, numConstraints);
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                else
                    fspSoln.A_total = fspSoln.Afsp.createSingleMatrix(obj.tSpan(1), [obj.parameters{:,2}]');
                end
            end

            % Remove FSP Sinks
            fspSoln.A_total = fspSoln.A_total(1:end-numConstraints,1:end-numConstraints);

            % Call function to compute transformation matrices.
            [obj.modelReductionOptions.phi,...
                obj.modelReductionOptions.phi_inv,...
                obj.modelReductionOptions.phiScale,...
                obj.modelReductionOptions.phiPlot,...
                obj.modelReductionOptions.redOutputs] = ...
                ssit.fsp_model_reduction.getTransformMatrices(...
                obj.modelReductionOptions,...
                fspSoln);

            fspSoln.tOut = obj.tSpan;
            obj.modelReductionOptions.fspSoln=fspSoln;

        end

        function redSolutions = solveReducedFSP(obj)
            arguments
                obj
            end

            numConstraints = length(obj.fspOptions.bounds);
            stateCount = obj.modelReductionOptions.fspSoln.stateSpace.getNumStates();
            % Use Approximate steady state as initial distribution if requested.
            if obj.fspOptions.initApproxSS
                jac = obj.modelReductionOptions.fspSoln.A_total;
                jac = jac(1:end-numConstraints,1:end-numConstraints);
                jac = jac+diag(sum(jac));
                try
                    warning('off')
                    [eigVec,~] = eigs(jac,1,'smallestabs');
                catch
                    try
                        [eigVec,~] = eigs(jac,0);
                    catch
                        try
                            eigVec = null(full(jac));
                        catch
                            disp('Could not find null space. Using uniform.')
                            eigVec = ones(size(jac,1),1);
                        end
                    end
                end
                obj.modelReductionOptions.fspSoln.P0 = [eigVec/sum(eigVec);zeros(numConstraints,1)];
            else % otherwise use user supplied IC.
                obj.modelReductionOptions.fspSoln.P0  = zeros(stateCount + numConstraints, 1);
                obj.modelReductionOptions.fspSoln.P0(1:size(obj.initialCondition,2)) = obj.initialProbs;
            end

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 sys = ss(fspSoln.A_total,fspSoln.P0,eye(nStates),[]);
                %                 sysred = balred(sys,n,redOutputs.info);
                %                 A_red = sysred.A;
                %                 q0 = sysred.B;
                %                 OutPutC = sysred.C;
            else
                q0 = obj.modelReductionOptions.phi_inv*obj.modelReductionOptions.fspSoln.P0;
                A_red = obj.modelReductionOptions.phi_inv*...
                    obj.modelReductionOptions.fspSoln.A_total*...
                    obj.modelReductionOptions.phi;
            end

            fspErrorCondition.tInit = obj.modelReductionOptions.fspSoln.tOut(1);
            [~, ~, ~, ~, solutionsNow] = ssit.fsp_ode_solvers.expv_modified(...
                obj.modelReductionOptions.fspSoln.tOut(end), A_red, q0,...
                1e-8, 30,...
                [],...
                obj.modelReductionOptions.fspSoln.tOut,...
                1e-3, [],...
                obj.modelReductionOptions.fspSoln.tOut(1),...
                fspErrorCondition);

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 redSolutionsNow = solutionsNow*OutPutC';
            else
                redSolutionsNow = solutionsNow*obj.modelReductionOptions.phi';
                redSolutionsNow = diag(1./sum(redSolutionsNow,2))*redSolutionsNow;
            end

            for j=size(redSolutionsNow,1):-1:1
                redSolutions.fsp{j} = struct(time=obj.modelReductionOptions.fspSoln.tOut(j),...
                    p=ssit.FspVector(obj.modelReductionOptions.fspSoln.stateSpace.states,...
                    redSolutionsNow(j,1:stateCount)),...
                    sinks=[]);
            end
            redSolutions.stateSpace = obj.modelReductionOptions.fspSoln.stateSpace.states;
        end

        %% Plotting/Visualization Functions
        function makePlot(obj,solution,plotType,indTimes,includePDO,figureNums,...
                lineProps,movieName,maxY,movieSpecies,senseVars,plotTitle)
            %% SSIT.makePlot - Tool to make plot of the FSP or SSA results.
            % Inputs:
            %    * solution - struct with SSIT solutions
            %    * plotType - string, chosen type of plot:
            %       ** FSP options:
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'marginals' - marginal distributions over time
            %            'joints' - joint distributions vs time
            %       ** sensFSP options:
            %            'marginals' - sensitivity of marginal
            %                          distributions for each parameter
            %                          and time point
            %       ** SSA options:
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'trajectories' - set of individual trajectories
            %                             vs time
            %    * indTimes -
            %    * includePDO - boolean, include calibrated PDO
            %            default: false
            %    * figureNums -
            %    * lineProps -
            %    * movieName -
            %    * maxY -
            %    * movieSpecies -
            %    * senseVars -
            %    * plotTitle - string, title for plot
            %
            % Examples:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [FSPsoln,bounds] = F.solve;  % Returns the solution and the
            %                                % bounds for the FSP projection
            %   F.makePlot(FSPsoln,'marginals')  % Make plot of FSP
            %                                    % marginal distributions
            %
            %   F.solutionScheme = 'fspSens'
            %   [sensSoln,bounds] = F.solve;  % Returns the sensitivity and the
            %                                   bounds for the FSP projection
            %   F.makePlot(sensSoln,'marginals') % Make plot of sensitivities
            %                                      of marginal distributions
            %                                      at final time
            arguments
                obj
                solution
                plotType = 'means';
                indTimes = [];
                includePDO = false;
                figureNums = [];
                lineProps = {'linewidth',2};
                movieName = 'defaultMovie.mp4'
                maxY = []
                movieSpecies = []
                senseVars = []
                plotTitle = ''
            end
            if isempty(figureNums)
                h =  findobj('type','figure');
                if isfield(h,'Number')
                    figureNums = max([h.Number])+(1:10);
                else
                    figureNums = (1:10);
                end
            end
            if obj.useHybrid
                specNames = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                specNames = obj.species;
            end

            kfig = 1;
            switch obj.solutionScheme
                case 'FSP'
                    app.FspTabOutputs.solutions = solution.fsp;
                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(app.FspTabOutputs.solutions)
                                app.FspTabOutputs.solutions{i}.p = obj.pdoOptions.PDO.computeObservationDist(app.FspTabOutputs.solutions{i}.p);
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end
                    app.FspPrintTimesField.Value = mat2str(obj.tSpan);
                    solution = exportFSPResults(app);
                    Nd = length(solution.Marginals{end});
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    Nt = length(indTimes);
                    switch plotType
                        case 'means'
                            plot(solution.T_array(indTimes),solution.Means(indTimes,:),lineProps{:});
                        case 'meansAndDevs'
                            fg = figure(figureNums(kfig)); set(0,'CurrentFigure',fg);
                            kfig=kfig+1;
                            for i = 1:Nd
                                subplot(Nd,1,i); hold on
                                errorbar(solution.T_array(indTimes),solution.Means(indTimes,i),sqrt(solution.Var(indTimes,i)),lineProps{:});
                                ylabel(specNames{i})
                            end
                            xlabel('time')
                        case 'marginals'
                            for j = 1:Nd
                                f = figure(figureNums(kfig)); kfig=kfig+1;
                                set(0,'CurrentFigure',f);
                                f.Name = ['Marginal Distributions of ',specNames{j}];
                                Nr = ceil(sqrt(Nt));
                                Nc = ceil(Nt/Nr);
                                for i = 1:Nt
                                    i2 = indTimes(i);
                                    subplot(Nr,Nc,i); hold on
                                    stairs(solution.Marginals{i2}{j},lineProps{:});
                                    set(gca,'fontsize',15)
                                    title(['t = ',num2str(solution.T_array(i2),2)])
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;
                            set(f,'Position',[ 1000         980         528         258])

                            if isempty(maxY)
                                maxY = -inf*ones(1,Nd);
                                for j = 1:Nd
                                    for i = 1:Nt
                                        maxY = max(maxY,max(solution.Marginals{i}{j}));
                                    end
                                end
                            end

                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    subplot(1,length(movieSpecies),j);
                                    bar([0:length(solution.Marginals{i}{movieSpecies(j)})-1],...
                                        solution.Marginals{i}{movieSpecies(j)},lineProps{:});
                                    set(gca,'fontsize',15,'ylim',[0,maxY(movieSpecies(j))])
                                    if isempty(plotTitle)
                                        title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    else
                                        title(sprintf('%s; t = %.0f', plotTitle, solution.T_array(i)))
                                    end

                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);

                        case 'joints'
                            if Nd<2
                                error('Joint distributions only avaialble for 2 or more species.')
                            else
                                for j1 = 1:Nd
                                    for j2 = j1+1:Nd
                                        h = figure(figureNums(kfig)); set(0,'CurrentFigure',h); kfig=kfig+1;
                                        h.Name = ['Joint Distribution of ',specNames{j1},' and ',specNames{j2}];
                                        Nr = ceil(sqrt(Nt));
                                        Nc = ceil(Nt/Nr);
                                        for i = 1:Nt
                                            i2 = indTimes(i);
                                            subplot(Nr,Nc,i);
                                            contourf(log10(max(1e-16,solution.Joints{i2}{j1,j2})));
                                            colorbar
                                            title(['t = ',num2str(solution.T_array(i2),2)])
                                            %                                             if mod(i-1,Nc)==0;
                                            ylabel(['x',num2str(j1)]);
                                            %                                             end
                                            %                                             if (i+Nc)>Nt;
                                            xlabel(['x',num2str(j2)]);
                                            %                                             end
                                            set(gca,'FontSize',15)
                                        end
                                    end
                                end
                            end
                        case 'escapeTimes'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            subplot(2,1,1)
                            z = solution.EscapeCDF(indTimes,:);
                            t = solution.T_array(indTimes);
                            plot(t,z,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape CDF')

                            subplot(2,1,2)
                            zp = (z(2:end,:)-z(1:end-1,:))./(t(2:end)-t(1:end-1))';
                            tp = (t(2:end)+t(1:end-1))/2;
                            plot(tp',zp,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape PDF')
                            xlabel('time')
                    end
                case 'SSA'
                    Nd = size(solution.trajs,1);
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    switch plotType
                        case 'trajectories'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            for i=1:Nd
                                subplot(Nd,1,i)
                                plot(solution.T_array(indTimes),squeeze(solution.trajs(i,indTimes,:)));
                            end
                        case 'means'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            plot(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),lineProps{:});
                        case 'meansAndDevs'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            vars = var(solution.trajs(:,indTimes,:),[],3);
                            errorbar(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),sqrt(vars));
                    end
                case 'fspSens'

                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(solution.sens.data)
                                for j=1:length(solution.sens.data{i}.S)

                                    % Make sure defined PDO has sufficient input range.
                                    % tensorSizeSens = size(solution.sens.data{i}.S(j).data);
                                    % for iSp = 1:length(specNames)
                                    %     if tensorSizeSens(iSp)>size(obj.pdoOptions.PDO.conditionalPmfs{iSp},2)
                                    %         obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solution.sens.data,true);
                                    %     end
                                    % end

                                    solution.sens.data{i}.S(j) = obj.pdoOptions.PDO.computeObservationDist(solution.sens.data{i}.S(j));
                                end
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end

                    app.SensFspTabOutputs.solutions = solution.sens;
                    app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = specNames;
                    solution.plotable = exportSensResults(app);

                    Np = size(solution.plotable.sensmdist,1);
                    Nd = size(solution.plotable.sensmdist,2);
                    if isempty(indTimes)
                        if strcmp(plotType,'margmovie')
                            indTimes = solution.plotable.T_array;
                        else
                            indTimes = length(solution.plotable.T_array);
                        end
                    end
                    Nt = length(indTimes);
                    Nr = ceil(sqrt(Np));
                    Nc = ceil(Np/Nr);
                    switch plotType
                        case 'marginals'
                            for it = 1:Nt
                                it2 = indTimes(it);
                                for id = 1:Nd
                                    f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                                    f.Name = ['Marg. Dist. Sensitivities of x',num2str(id),' at t=',num2str(solution.plotable.T_array(it2))];
                                    for j = 1:Np
                                        subplot(Nr,Nc,j); hold on;
                                        stairs(solution.plotable.sensmdist{j,id,it2},lineProps{:});
                                        set(gca,'fontsize',15)
                                        title(obj.parameters{j,1})
                                        %                                         if mod(j-1,Nc)==0;
                                        ylabel(['sensitivity']);
                                        %                                         end
                                        %                                         if (j+Nc)>Np;
                                        xlabel(['x',num2str(id)]);
                                        %                                         end
                                    end
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;
                            set(f,'Position',[ 1000         985         419         253])

                            if isempty(maxY)
                                maxY = [inf*ones(1,Nd);-inf*ones(1,Nd)];
                                for j = 1:Nd
                                    for i = 1:Nt
                                        for k = 1:size(solution.plotable.sensmdist,2)
                                            maxY(1,j) = min(maxY(1,j),min(solution.plotable.sensmdist{k,j,i}));
                                            maxY(2,j) = max(maxY(2,j),max(solution.plotable.sensmdist{k,j,i}));
                                        end
                                    end
                                end
                            end

                            if isempty(senseVars)
                                senseVars = [1:size(obj.parameters,1)];
                            end

                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    for k = 1:length(senseVars)
                                        jPlot = (k-1)*length(movieSpecies)+j;
                                        subplot(length(senseVars),length(movieSpecies),jPlot);
                                        bar([0:length(solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i})-1],...
                                            solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i},lineProps{:});
                                        set(gca,'fontsize',15,'ylim',[maxY(1,movieSpecies(j)),maxY(2,movieSpecies(j))])
                                        % title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    end
                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);
                    end
            end
        end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function plotODE(obj,speciesNames,timeVec,lineProps,opts)
            arguments
                obj
                speciesNames = []                  
                timeVec = []
                lineProps = {'linewidth',2};
                opts.Title (1,1) string = ""
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
                opts.Colors = []  
                % [] | n3 RGB | cell of ColorSpec/RGB | colormap name string
            end
        
            X = obj.Solutions.ode;  % [nTime  nSpecies]
            [nTime, nSpecies] = size(X);
        
            % ----- timeVec -----
            if isempty(timeVec)
                timeVec = (1:nTime).';
            else
                if numel(timeVec) ~= nTime
                    error('timeVec length (%d) must match number of ODE time points (%d).', numel(timeVec), nTime);
                end
                timeVec = timeVec(:);
            end
        
            % ----- Species selection -----
            allNames = obj.species;
            if isstring(allNames), allNames = cellstr(allNames); end
        
            if isempty(speciesNames)
                selIdx = 1:nSpecies;
                selNames = allNames;
            elseif isnumeric(speciesNames)
                selIdx = speciesNames(:).';
                if any(selIdx < 1 | selIdx > nSpecies) || numel(unique(selIdx)) ~= numel(selIdx)
                    error('Invalid or duplicate species indices. Must be unique integers in [1,%d].', nSpecies);
                end
                selNames = allNames(selIdx);
            else
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    exampleList = strjoin(allNames, ', ');
                    error('Unknown species name(s): %s. Available: %s', strjoin(bad, ', '), exampleList);
                end
                selIdx = loc(:).';
                selNames = allNames(selIdx);
            end
        
            nPlot = numel(selIdx);
        
            % ----- Colors -----
            useCellColors = false;
            C = [];          % numeric nPlot3
            cellColors = {}; % 1nPlot cell for mixed ColorSpecs
        
            if isempty(opts.Colors)
                C = lines(nPlot);
            elseif ischar(opts.Colors) || (isstring(opts.Colors) && isscalar(opts.Colors))
                cmName = char(opts.Colors);
                try
                    % Sample the colormap to exactly nPlot colors
                    bigN = max(nPlot, 64);
                    cm = feval(cmName, bigN);
                    idx = round(linspace(1, bigN, nPlot));
                    C = cm(idx, :);
                catch
                    error('opts.Colors="%s" is not a valid colormap name.', cmName);
                end
            elseif isnumeric(opts.Colors)
                C = double(opts.Colors);
                if size(C,2) ~= 3 || size(C,1) < nPlot
                    error('opts.Colors numeric must be at least %d3 RGB values.', nPlot);
                end
                if any(C(:) < 0 | C(:) > 1) || ~all(isfinite(C(:)))
                    error('opts.Colors numeric RGB values must be finite and in [0,1].');
                end
                C = C(1:nPlot, :);
            elseif iscell(opts.Colors)
                if numel(opts.Colors) < nPlot
                    error('opts.Colors cell must provide at least %d entries.', nPlot);
                end
                cellColors = cell(1,nPlot);
                for k = 1:nPlot
                    c = opts.Colors{k};
                    if ischar(c) || (isstring(c) && isscalar(c))
                        cellColors{k} = char(c);              
                    elseif isnumeric(c) && isequal(size(c), [1,3])
                        if any(c < 0 | c > 1) || ~all(isfinite(c))
                            error('opts.Colors{%d}: RGB must be finite in [0,1].', k);
                        end
                        cellColors{k} = double(c);
                    else
                        error('opts.Colors{%d} must be a ColorSpec char or a 13 RGB vector.', k);
                    end
                end
                useCellColors = true;
            else
                error('opts.Colors must be: [], an n3 RGB matrix, a cell array of colors, or a colormap name string.');
            end
        
            % ----- Plot -----
            figure; hold on;
            for k = 1:nPlot
                s = selIdx(k);
                if useCellColors
                    thisColor = cellColors{k};
                else
                    thisColor = C(k, :);
                end
                plot(timeVec, X(:, s), lineProps{:}, 'Color', thisColor);
            end
        
            ax = gca;
            ax.FontSize = opts.TickLabelSize;
        
            if ~isempty(opts.XLim), xlim(opts.XLim); end
            if ~isempty(opts.YLim), ylim(opts.YLim); end
        
            xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
            ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
        
            if ~isempty(opts.Title)
                title(opts.Title,'FontSize',opts.TitleFontSize);
            else
                title('ODE Solution Trajectories','FontSize',opts.TitleFontSize);
            end
            grid on; box on;
        
            if ~strcmpi(opts.LegendLocation,"none")
                lgd = legend(selNames, 'Location', char(opts.LegendLocation));
                if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
            end
            hold off;
        end

        % plotSSA - Plots SSA trajectories and histograms from ssaSoln struct
        function plotSSA(obj,speciesIdx,numTraj,speciesNames,lineProps,opts)
            arguments
                obj
                speciesIdx = []                     
                numTraj = []                % [] -> min(10, numTotalTraj)
                speciesNames = []             
                lineProps = {'linewidth',2};        
                opts.Title (1,1) string = ""
                opts.MeanOnly (1,1) logical = false
                opts.HistTime double = 100  % histogram time (closest used)
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
                opts.Colors = []      
                % [] | species 3 RGB | cell array | colormap name               
            end
        
            % ----- Extract SSA solution & sizes -----
            ssaSoln = obj.Solutions;
            numSpecies    = size(ssaSoln.trajs, 1);
            nTime         = size(ssaSoln.trajs, 2);
            numTotalTraj  = size(ssaSoln.trajs, 3);
        
            % ----- Number of trajectories to draw -----
            if isempty(numTraj)
                numTraj = min(10, numTotalTraj);
            else
                numTraj = min(numTraj, numTotalTraj);
            end
        
            % ----- Species master names -----
            allNames = obj.species;
            if isempty(allNames)
                allNames = arrayfun(@(s) sprintf('Species %d', s), 1:numSpecies, 'UniformOutput', false);
            end
            if isstring(allNames), allNames = cellstr(allNames); end
        
            % ----- Select species by names (priority) or indices -----
            if ~isempty(speciesNames)
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    error('Unknown species name(s): %s. Available: %s', strjoin(bad, ', '), strjoin(allNames, ', '));
                end
                spList = loc(:).';
                selNames = allNames(spList);
            else
                if ischar(speciesIdx) || (isstring(speciesIdx) && isscalar(speciesIdx))
                    if strcmpi(char(speciesIdx), 'all')
                        spList = 1:numSpecies;
                    else
                        error('speciesIdx string must be "all" or provide a numeric vector.');
                    end
                elseif isempty(speciesIdx)
                    spList = 1:numSpecies;
                elseif isnumeric(speciesIdx)
                    spList = unique(speciesIdx(:)).';
                    if any(spList < 1 | spList > numSpecies)
                        error('speciesIdx must be within 1..%d, or "all".', numSpecies);
                    end
                else
                    error('speciesIdx must be a numeric vector or "all".');
                end
                selNames = allNames(spList);
            end
            nSel = numel(spList);
        
            % ----- Time vector & valid window -----
            Tfull = ssaSoln.T_array(:);         % full time vector
            validIdx = Tfull >= 0;              % adjust as needed
            T = Tfull(validIdx);
        
            % Histogram time index (closest to opts.HistTime)
            if isempty(opts.HistTime) || ~isfinite(opts.HistTime)
                histTarget = 100;
            else
                histTarget = opts.HistTime;
            end
            [~, tHist_idx] = min(abs(Tfull - histTarget));
        
            % ----- Colors for selected species -----
            C = []; useCellColors = false; cellColors = {};
            if isempty(opts.Colors)
                C = lines(nSel);
            elseif ischar(opts.Colors) || (isstring(opts.Colors) && isscalar(opts.Colors))
                cmName = char(opts.Colors);
                bigN = max(nSel, 64);
                try
                    cm = feval(cmName, bigN);
                catch
                    error('opts.Colors="%s" is not a valid colormap name.', cmName);
                end
                idx = round(linspace(1, bigN, nSel));
                C = cm(idx, :);
            elseif isnumeric(opts.Colors)
                C = double(opts.Colors);
                if size(C,2) ~= 3 || size(C,1) < nSel
                    error('opts.Colors numeric must be at least %d3 RGB.', nSel);
                end
                if any(~isfinite(C(:)) | C(:) < 0 | C(:) > 1)
                    error('opts.Colors RGB must be finite in [0,1].');
                end
                C = C(1:nSel, :);
            elseif iscell(opts.Colors)
                if numel(opts.Colors) < nSel
                    error('opts.Colors cell must provide at least %d entries.', nSel);
                end
                cellColors = cell(1,nSel);
                for k = 1:nSel
                    c = opts.Colors{k};
                    if ischar(c) || (isstring(c) && isscalar(c))
                        cellColors{k} = char(c);
                    elseif isnumeric(c) && isequal(size(c), [1,3]) && all(isfinite(c)) && all(c>=0 & c<=1)
                        cellColors{k} = double(c);
                    else
                        error('opts.Colors{%d} must be ColorSpec char or 13 RGB.', k);
                    end
                end
                useCellColors = true;
            else
                error('opts.Colors must be: [], colormap name, n3 RGB, or cell array.');
            end
        
            % Helper: lighten color toward white (simulate transparency)
            function lc = lighten(baseRGB, alpha)
                lc = (1 - alpha)*[1 1 1] + alpha*baseRGB;
            end
        
            % ----- TRAJECTORY PLOT -----
            figure; hold on;
            legendEntries = cell(1, nSel);
            legendHandles = gobjects(1, nSel);
        
            randIdx = randperm(numTotalTraj, numTraj);
        
            for j = 1:nSel
                s = spList(j);
                        
                if useCellColors
                    baseColor = cellColors{j};
                else
                    baseColor = C(j, :);
                end
        
                if ~opts.MeanOnly
                    trajColor = baseColor;
                    if isnumeric(baseColor)
                        trajColor = lighten(baseColor, 0.25); % lighter lines for single trajectories
                    end
                    Xs = squeeze(ssaSoln.trajs(s, validIdx, :));
                    for i = 1:numTraj
                        plot(T, Xs(:, randIdx(i)), 'LineWidth', 0.75, 'Color', trajColor, ...
                             'HandleVisibility', 'off');
                    end
                end
        
                Xs_full = squeeze(ssaSoln.trajs(s, validIdx, :));
                h = plot(T, mean(Xs_full, 2), lineProps{:}, 'Color', baseColor);
                legendHandles(j) = h;
                legendEntries{j} = selNames{j};
            end
        
            % ----- Axes styling -----
            ax = gca; ax.FontSize = opts.TickLabelSize;
            xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
            ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
        
            % ----- Title -----
            if strlength(opts.Title) > 0
                title(string(opts.Title), 'FontSize', opts.TitleFontSize);
            else
                if nSel == numSpecies
                    title('SSA Trajectories (Starting at t = 0)', 'FontSize', opts.TitleFontSize);
                elseif nSel == 1
                    title(sprintf('SSA Trajectories for %s (Starting at t = 0)', selNames{1}), 'FontSize', opts.TitleFontSize);
                else
                    title('SSA Trajectories for Selected Species (Starting at t = 0)', 'FontSize', opts.TitleFontSize);
                end
            end
        
            % ----- Axes limits -----
            if ~isempty(opts.XLim), xlim(opts.XLim); end
            if ~isempty(opts.YLim), ylim(opts.YLim); end
        
            % ----- Legend -----
            if ~strcmpi(opts.LegendLocation, "none")
                lgd = legend(legendHandles, legendEntries, 'Location', char(opts.LegendLocation));
                if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
            end
            grid on; box on; hold off;
        
            % ----- HISTOGRAM PLOT(S) at t  opts.HistTime -----
            figure;
            if nSel > 1
                numPanels = nSel;
                numRows = ceil(sqrt(numPanels));
                numCols = ceil(numPanels / numRows);
                for j = 1:nSel
                    s = spList(j);
                    subplot(numRows, numCols, j);
                    X_t = squeeze(ssaSoln.trajs(s, tHist_idx, :));
                    if useCellColors
                        fc = cellColors{j};
                        if ischar(fc), fc = C(j,:); end
                    else
                        fc = C(j, :);
                    end
                    histogram(X_t, 'FaceColor', fc, 'EdgeColor', 'k');
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(sprintf('Molecule Count (%s)', selNames{j}), 'FontSize', opts.AxisLabelSize);
                    ylabel('Frequency', 'FontSize', opts.AxisLabelSize);
                    title(sprintf('Distribution at t  %.2f (%s)', Tfull(tHist_idx), selNames{j}), 'FontSize', opts.TitleFontSize);
                    grid on; box on;
                end
            else
                j = 1; s = spList(j);
                X_t = squeeze(ssaSoln.trajs(s, tHist_idx, :));
                if useCellColors
                    fc = cellColors{j};
                    if ischar(fc), fc = C(j,:); end
                else
                    fc = C(j, :);
                end
                histogram(X_t, 'FaceColor', fc, 'EdgeColor', 'k');
                ax = gca; ax.FontSize = opts.TickLabelSize;
                xlabel(sprintf('Molecule Count (%s)', selNames{j}), 'FontSize', opts.AxisLabelSize);
                ylabel('Frequency', 'FontSize', opts.AxisLabelSize);
                title(sprintf('Distribution at t  %.2f (%s)', Tfull(tHist_idx), selNames{j}), 'FontSize', opts.TitleFontSize);
                grid on; box on;
            end
        end
            
        function plotFSP(obj, solution, speciesNames, plotType, indTimes, figureNums, lineProps, opts)
            % plotFSP  Plot FSP results like plotODE/plotSSA, with species subsetting
            arguments
                obj
                solution
                speciesNames = []
                plotType (1,1) string = "means"
                indTimes = []
                figureNums = []
                lineProps = {'linewidth',2}
                opts.SpeciesIdx = []
                opts.Colors = []
                opts.Title (1,1) string = ""
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
            end
        
            % ----- Species selection -----
            nSpecies = numel(obj.species);
            allNames = obj.species;
            if isstring(allNames), allNames = cellstr(allNames); end
        
            if isempty(speciesNames) && isempty(opts.SpeciesIdx)
                selIdx = 1:nSpecies;
                selNames = allNames;
            elseif ~isempty(opts.SpeciesIdx)
                selIdx = unique(opts.SpeciesIdx(:).');
                if any(selIdx < 1 | selIdx > nSpecies)
                    error('opts.SpeciesIdx must be in 1..%d', nSpecies);
                end
                selNames = allNames(selIdx);
            elseif isnumeric(speciesNames)
                selIdx = unique(speciesNames(:).');
                if any(selIdx < 1 | selIdx > nSpecies)
                    error('speciesNames (indices) must be in 1..%d', nSpecies);
                end
                selNames = allNames(selIdx);
            else
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    error('Unknown species name(s): %s. Available: %s', ...
                          strjoin(bad, ', '), strjoin(allNames, ', '));
                end
                selIdx = loc(:).';
                selNames = allNames(selIdx);
            end
            nSel = numel(selIdx);

            % ----- Map to FSP species indices for hybrid models -----
            % For hybrid models, only non-upstream species appear in the FSP
            if isprop(obj,'useHybrid') && obj.useHybrid
                upNames = obj.hybridOptions.upstreamODEs;
                if isstring(upNames), upNames = cellstr(upNames); end
                if ischar(upNames),   upNames = {upNames};        end

                allNamesForMap = allNames;
                if isstring(allNamesForMap), allNamesForMap = cellstr(allNamesForMap); end

                isUpstream       = ismember(allNamesForMap, upNames);
                discIdxAll       = find(~isUpstream);   % indices of discrete/FSP species
                fspSelIdx        = zeros(size(selIdx));

                for j = 1:nSel
                    k = find(discIdxAll == selIdx(j), 1);
                    if isempty(k)
                        error('Selected species "%s" is an upstream ODE-only species and has no FSP distribution.', selNames{j});
                    end
                    fspSelIdx(j) = k;   % index into FSP arrays (Means, Var, Marginals, etc.)
                end
            else
                % Non-hybrid model: FSP species == all species
                fspSelIdx = selIdx;
            end
        
            % ----- Export FSP to plottable struct -----
            rawSol = solution;   % <- copy to compute escape CDF if needed
            if plotType=="sens"
                app.FspTabOutputs.solutions = solution.sens;
                app.FspPrintTimesField.Value = mat2str(obj.tSpan);
                %solution = exportFSPResults(app);
            else
                app.FspTabOutputs.solutions = solution.fsp;
                app.FspPrintTimesField.Value = mat2str(obj.tSpan);
                solution = exportFSPResults(app);
                % Time selection
                if isempty(indTimes), indTimes = 1:length(solution.T_array); 
                end
                Nt = numel(indTimes);
            end
        
            % ----- Figure numbers -----
            if isempty(figureNums)
                h = findobj('type','figure');
                if ~isempty(h)
                    figureNums = max([h.Number])+(1:10);
                else
                    figureNums = (1:10);
                end
            end
            kfig = 1;
        
            % ----- Colors for selected series -----
            C = resolveColors(opts.Colors, nSel);  % nSel3 or cell of nSel entries
        
            switch plotType
                case 'means'
                    figure(figureNums(kfig)); clf; kfig=kfig+1; hold on
                    hMean = gobjects(1, nSel);
                    tt = solution.T_array(indTimes);
                    for j = 1:nSel
                        s = fspSelIdx(j);
                        col = getC(C, j);
                        hMean(j) = plot(tt, solution.Means(indTimes, s), ...
                                        lineProps{:}, 'Color', col, ...
                                        'DisplayName', selNames{j});
                    end
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hMean, selNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title)>0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('FSP Means', 'FontSize', opts.TitleFontSize);
                    end
                    grid on; box on; hold off;
        
                case 'meansAndDevs'
                    figure(figureNums(kfig)); clf; kfig=kfig+1; hold on
                    hMean = gobjects(1, nSel);                 % handles for legend
                
                    tt = solution.T_array(indTimes);
                    for j = 1:nSel
                        s  = fspSelIdx(j);
                        mu = solution.Means(indTimes, s);
                        sd = sqrt(max(0, solution.Var(indTimes, s)));
                        col = getC(C, j);
                
                        % mean line (legend handle)
                        hMean(j) = plot(tt, mu, lineProps{:}, 'Color', col, ...
                                         'DisplayName', selNames{j});
                
                        % std bars (keep out of legend)
                        eb = errorbar(tt, mu, sd, 'LineStyle','none');
                        eb.Color = col;
                        eb.HandleVisibility = 'off';
                    end
                
                    % axes + labels
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
                
                    % legend with mean lines only (one entry per species)
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hMean, selNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title)>0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('FSP Means  SD', 'FontSize', opts.TitleFontSize);
                    end
                    grid on; box on; hold off;
        
                case 'marginals'
                    for jj = 1:nSel
                        s = fspSelIdx(jj);
                        f = figure(figureNums(kfig)); clf; kfig=kfig+1;
                        f.Name = ['Marginal Distributions of ', selNames{jj}];
                        Nr = ceil(sqrt(Nt)); Nc = ceil(Nt/Nr);
                
                        for ii = 1:Nt
                            i2 = indTimes(ii);
                            pmf = solution.Marginals{i2}{s}(:);
                            x = 0:numel(pmf)-1;
                
                            % Optional crop to XLim (for performance and cleaner view)
                            if ~isempty(opts.XLim)
                                mask = (x >= opts.XLim(1)) & (x <= opts.XLim(2));
                                xPlot = x(mask);
                                yPlot = pmf(mask);
                            else
                                xPlot = x;
                                yPlot = pmf;
                            end
                
                            subplot(Nr, Nc, ii); hold on
                            stairs(xPlot, yPlot, lineProps{:}, 'Color', getC(C,jj));
                            set(gca,'FontSize',opts.TickLabelSize)
                            title(sprintf('t = %.3g', solution.T_array(i2)), ...
                                  'FontSize', max(opts.TitleFontSize-2,8))
                            xlabel(sprintf('%s count', selNames{jj}), 'FontSize', opts.AxisLabelSize-2);
                            ylabel('Probability', 'FontSize', opts.AxisLabelSize-2);
                
                            % Apply limits if provided
                            if ~isempty(opts.XLim), xlim(opts.XLim); end
                            if ~isempty(opts.YLim), ylim(opts.YLim); end
                
                            grid on; box on;
                        end
                
                        sgtitle(sprintf('Marginal Distributions  %s', selNames{jj}), ...
                                'FontSize', opts.TitleFontSize);
                    end
        
                case 'joints'
                    if nSel < 2
                        error('Joint distributions only available when 2 or more species are selected.');
                    end
                    for a = 1:nSel
                        for b = a+1:nSel
                            s1 = fspSelIdx(a); s2 = fspSelIdx(b);
                            h = figure(figureNums(kfig)); clf; kfig=kfig+1;
                            h.Name = sprintf('Joint Distribution of %s and %s', selNames{a}, selNames{b});
                            Nr = ceil(sqrt(Nt)); Nc = ceil(Nt/Nr);
                            for ii = 1:Nt
                                i2 = indTimes(ii);
                                subplot(Nr,Nc,ii);
                                contourf(log10(max(1e-16, solution.Joints{i2}{s1,s2})));
                                colorbar
                                title(sprintf('t = %.3g', solution.T_array(i2)), 'FontSize', max(opts.TitleFontSize-2,8))
                                ylabel(selNames{a}); xlabel(selNames{b});
                                set(gca,'FontSize',opts.TickLabelSize)
                            end
                        end
                    end

                case 'escapeTimes'
                    % ---- Gather times ----
                    tt = solution.T_array(:);
                    if isempty(indTimes), indTimes = 1:numel(tt); end
                    t  = tt(indTimes);
                
                    % ---- Get names for sinks (legend labels) ----
                    sinkNames = {};
                    try
                        sinkNames = obj.fspOptions.escapeSinks.f;
                        if isstring(sinkNames), sinkNames = cellstr(sinkNames); end
                        if ~iscell(sinkNames), sinkNames = {}; end
                    catch
                        sinkNames = {};
                    end
                
                    % ---- Get Escape CDF matrix [Nt x nSinks] ----
                    if isfield(solution, 'EscapeCDF') && ~isempty(solution.EscapeCDF)
                        Z_all = solution.EscapeCDF;                 % Nt x nSinks
                        if isvector(Z_all), Z_all = Z_all(:); end   % ensure 2D
                        Z = Z_all(indTimes, :);
                    else
                        % Build per-sink CDF from raw FSP (supports multiple sinks)
                        [t_raw, Z_raw] = computeEscapeCDFFromRawMulti(rawSol);   % Nt x nSinks
                        % align to exported times if needed
                        if numel(t_raw) ~= numel(tt)
                            Z = interp1(t_raw, Z_raw, tt, 'previous', 'extrap');
                        else
                            Z = Z_raw;
                        end
                        Z = Z(indTimes, :);
                    end
                
                    % ---- Clean & clamp ----
                    Z(~isfinite(Z)) = 0;
                    Z = max(0, min(1, Z));       % keep in [0,1]
                    nSinks = size(Z,2);
                    if isempty(sinkNames) || numel(sinkNames) ~= nSinks
                        sinkNames = arrayfun(@(k) sprintf('Sink %d', k), 1:nSinks, 'UniformOutput', false);
                    end
                
                    % ---- Colors: one per sink ----
                    C = resolveColors(opts.Colors, nSinks);
                
                    % ---- Compute PDFs per sink via finite differences ----
                    if numel(t) >= 2
                        dt  = max(eps, t(2:end) - t(1:end-1));
                        tp  = (t(2:end) + t(1:end-1))/2;
                        dZ  = Z(2:end, :) - Z(1:end-1, :);
                        Zp  = dZ ./ dt;             % [Nt-1 x nSinks]
                    else
                        tp = t; Zp = zeros(numel(t), nSinks);
                    end
                
                    % ---- Plot: CDF (top) ----
                    figure(figureNums(kfig)); clf; kfig = kfig+1;
                    subplot(2,1,1); hold on
                    hC = gobjects(1, nSinks);
                    for k = 1:nSinks
                        col = getC(C, k);
                        hC(k) = plot(t, Z(:,k), lineProps{:}, 'Color', col, 'DisplayName', sinkNames{k});
                    end
                    grid on; box on;
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel('Escape CDF', 'FontSize', opts.AxisLabelSize);
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hC, sinkNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title) > 0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('Escape / First-Passage CDF', 'FontSize', opts.TitleFontSize);
                    end
                
                    % ---- Plot: PDF (bottom) ----
                    subplot(2,1,2); hold on
                    for k = 1:nSinks
                        col = getC(C, k);
                        plot(tp, Zp(:,k), lineProps{:}, 'Color', col);
                    end
                    grid on; box on;
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel('Escape PDF', 'FontSize', opts.AxisLabelSize);
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end

                    case 'sens'
                        % ---- Build plottable sensitivity results (as before) ----
                        app.SensFspTabOutputs.solutions = solution.sens;
                        app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                        if ~isempty(obj.parameters)
                            app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                        else
                            app.ReactionsTabOutputs.parameters = [];
                        end
                        app.ReactionsTabOutputs.varNames = obj.species;   % exporter expects all; we subset below
                        solution.plotable = exportSensResults(app);
                    
                        % Dimensions
                        Np = size(solution.plotable.sensmdist, 1);    % # parameters
                        % Nd_all = size(solution.plotable.sensmdist, 2);  % total species in export (unused; we use selIdx)
                    
                        % Time selection
                        if isempty(indTimes)
                            indTimes = 1:length(solution.plotable.T_array);
                        end
                        Nt = numel(indTimes);
                    
                        % Figure numbering
                        if isempty(figureNums)
                            h = findobj('type','figure');
                            if ~isempty(h), figureNums = max([h.Number])+(1:10);
                            else,            figureNums = (1:10);
                            end
                        end
                        kfig = 1;
                    
                        % Colors: one per selected species (like 'means'/'marginals')
                        C = resolveColors(opts.Colors, numel(selIdx));
                    
                        % Grid layout over parameters
                        Nr = ceil(sqrt(Np));
                        Nc = ceil(Np/Nr);
                    
                        % ---- Plot: for each selected species and selected time ----
                        for jj = 1:numel(selIdx)
                            s = selIdx(jj);                 % species index (into exporter arrays)
                            spName = selNames{jj};
                            col = getC(C, jj);
                    
                            for ii = 1:Nt
                                it2 = indTimes(ii);
                                f = figure(figureNums(kfig)); clf; kfig = kfig+1;
                                f.Name = sprintf('Marginal Sensitivities  %s @ t=%.3g', spName, solution.plotable.T_array(it2));
                    
                                for j = 1:Np
                                    % Sensitivity vector for parameter j, species s, time it2
                                    sv = solution.plotable.sensmdist{j, s, it2};
                                    if isempty(sv), sv = 0; end
                                    sv = sv(:);
                                    x = 0:numel(sv)-1;
                    
                                    % Optional crop to XLim (as in 'marginals')
                                    if ~isempty(opts.XLim)
                                        mask  = (x >= opts.XLim(1)) & (x <= opts.XLim(2));
                                        xPlot = x(mask);
                                        yPlot = sv(mask);
                                    else
                                        xPlot = x;
                                        yPlot = sv;
                                    end
                    
                                    subplot(Nr, Nc, j); hold on
                                    stairs(xPlot, yPlot, lineProps{:}, 'Color', col);
                    
                                    % Axes styling + labels (match other cases)
                                    ax = gca; ax.FontSize = opts.TickLabelSize;
                                    xlabel(sprintf('%s count', spName), 'FontSize', max(opts.AxisLabelSize-2, 8));
                                    ylabel('Sensitivity',               'FontSize', max(opts.AxisLabelSize-2, 8));
                                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                                    grid on; box on;
                    
                                    % Subplot title = parameter name
                                    try
                                        pName = obj.parameters{j,1};
                                        if isstring(pName), pName = char(pName); end
                                    catch
                                        pName = sprintf('Param %d', j);
                                    end
                                    title(pName, 'FontSize', max(opts.TitleFontSize-4, 8));
                                end
                    
                                % Figure-level title (editable, like other cases)
                                if strlength(opts.Title) > 0
                                    sgtitle(string(opts.Title), 'FontSize', opts.TitleFontSize, 'FontWeight','bold');
                                else
                                    sgtitle(sprintf('Marginal Sensitivities  %s (t = %.3g)', spName, solution.plotable.T_array(it2)), ...
                                            'FontSize', opts.TitleFontSize);
                                end
                            end
                        end
        
                otherwise
                    error('Unknown plotType "%s". Use: "means", "meansAndDevs", "marginals", or "joints".', plotType);
            end
        
            % ---------- helpers ----------
            function C = resolveColors(userC, n)
                if isempty(userC)
                    C = lines(n); 
                    return
                end
            
                % Colormap name
                if ischar(userC) || (isstring(userC) && isscalar(userC))
                    cm = feval(char(userC), max(n,64));
                    C  = cm(round(linspace(1,size(cm,1),n)),:);
                    return
                end
            
                % Numeric: RGB row(s)
                if isnumeric(userC)
                    userC = double(userC);
                    if isvector(userC) && numel(userC)==3
                        C = repmat(userC(:).', n, 1);       % replicate single RGB to n rows
                        return
                    end
                    % userC is k3
                    assert(size(userC,2)==3, 'opts.Colors numeric must be 1x3 or kx3.');
                    k = size(userC,1);
                    if k >= n
                        C = userC(1:n,:);                   % take first n
                    else
                        idx = round(linspace(1, k, n));     % resample to n rows
                        C = userC(idx, :);
                    end
                    return
                end
            
                % Cell array of colors (char ColorSpec or 1x3 RGB)
                if iscell(userC)
                    k = numel(userC);
                    if k < n
                        % repeat entries to reach n
                        userC = userC(1+mod(0:n-1, max(1,k)));
                    else
                        userC = userC(1:n);
                    end
                    C = userC;
                    return
                end
            
                error('opts.Colors must be: [], colormap name, 1x3 or kx3 RGB, or cell array.');
            end
            
            function c = getC(Cin, j)
                % Returns either 1x3 RGB or a char ColorSpec ('r','red', etc.)
                if iscell(Cin), c = Cin{j}; else, c = Cin(j,:); end
                if isstring(c), c = char(c); end
            end
            
            function styleAxesAndLegend(names, o)
                ax = gca; ax.FontSize = o.TickLabelSize;
                xlabel(o.XLabel, 'FontSize', o.AxisLabelSize);
                ylabel(o.YLabel, 'FontSize', o.AxisLabelSize);
                if ~strcmpi(o.LegendLocation, "none")
                    lgd = legend(names, 'Location', char(o.LegendLocation));
                    if ~isempty(lgd), lgd.FontSize = o.LegendFontSize; end
                end
            end
            
            function applyLimits(o)
                if ~isempty(o.XLim), xlim(o.XLim); end
                if ~isempty(o.YLim), ylim(o.YLim); end
            end
            
            function applyTitle(o, defaultTitle)
                if strlength(o.Title) > 0
                    title(string(o.Title), 'FontSize', o.TitleFontSize);
                else
                    title(defaultTitle, 'FontSize', o.TitleFontSize);
                end
            end

            function [t_out, z_cum] = computeEscapeCDFFromRaw(rawSol)
                Nt = numel(rawSol.fsp);
                t_out = zeros(Nt,1);
                flux  = zeros(Nt,1);
                for i = 1:Nt
                    S = rawSol.fsp{i};
                    if isfield(S,'time'), t_out(i) = S.time;
                    elseif isfield(S,'T'), t_out(i) = S.T;
                    elseif isfield(S,'t'), t_out(i) = S.t;
                    else, t_out(i) = i;
                    end
                    if isfield(S,'escapeProbs') && ~isempty(S.escapeProbs)
                        v = S.escapeProbs(:);
                    elseif isfield(S,'sinks') && ~isempty(S.sinks)
                        v = S.sinks(:);
                    else
                        v = 0;
                    end
                    flux(i) = nansum(v);
                end
                tol = 1e-12;
                looksCum = all(diff(max(0,min(1,flux))) >= -tol) && flux(end) <= 1+1e-6;
                if looksCum, z_cum = max(0,min(1,flux));
                else,        z_cum = max(0,min(1,cumsum(max(0,flux))));
                end
            end
            
            function col = resolveOneColor(userC)
                if isempty(userC), col = lines(1); return; end
                if ischar(userC) || (isstring(userC) && isscalar(userC))
                    cm = feval(char(userC), 64); col = cm(1,:); return
                end
                if isnumeric(userC)
                    if isvector(userC) && numel(userC)==3, col = double(userC(:)).';
                    else, col = double(userC(1,:)); end
                    return
                end
                if iscell(userC)
                    c = userC{1}; if isstring(c), c = char(c); end
                    if isnumeric(c) && numel(c)==3, col = double(c(:)).'; else, col = c; end
                    return
                end
                col = lines(1);
            end

            function [t_out, Z_cum] = computeEscapeCDFFromRawMulti(rawSol)
                % Returns:
                %   t_out : Nt x 1 time vector
                %   Z_cum : Nt x nSinks cumulative probabilities, one column per sink
                Nt = numel(rawSol.fsp);
                t_out = zeros(Nt,1);
            
                % Determine number of sinks from first timestep
                S1 = rawSol.fsp{1};
                if isfield(S1, 'escapeProbs') && ~isempty(S1.escapeProbs)
                    nSinks = numel(S1.escapeProbs);
                    modeField = 'escapeProbs';
                elseif isfield(S1, 'sinks') && ~isempty(S1.sinks)
                    nSinks = numel(S1.sinks);
                    modeField = 'sinks';
                else
                    nSinks = 1; modeField = '';   % degenerate
                end
            
                flux = zeros(Nt, nSinks);    % per-step flux into each sink
                for i = 1:Nt
                    Si = rawSol.fsp{i};
                    % time
                    if isfield(Si,'time'), t_out(i) = Si.time;
                    elseif isfield(Si,'T'), t_out(i) = Si.T;
                    elseif isfield(Si,'t'), t_out(i) = Si.t;
                    else, t_out(i) = i;
                    end
                    % per-sink increments
                    v = zeros(1, nSinks);
                    if ~isempty(modeField)
                        vv = Si.(modeField);
                        if ~isempty(vv), v = vv(:).'; end
                    end
                    % store
                    flux(i, :) = v(1, 1:nSinks);
                end
            
                % Heuristic: if looks cumulative already, use as-is; else cumsum
                Z_cum = zeros(Nt, nSinks);
                for k = 1:nSinks
                    col = flux(:,k);
                    col(~isfinite(col)) = 0;
                    col = max(0, min(1, col));
                    looksCum = all(diff(col) >= -1e-12) && col(end) <= 1 + 1e-6;
                    if looksCum
                        Z_cum(:,k) = col;
                    else
                        Z_cum(:,k) = max(0, min(1, cumsum(max(0,col))));
                    end
                end
            end            
        end

        function figHandles = plotFits(obj, fitSolution, plotType, figureNums, lineProps, opts)
            % plotFits  Compare model FSP fits to experimental data.
            %
            % figHandles = plotFits(obj, fitSolution, plotType, figureNums, lineProps, opts)
            %
            % Inputs:
            %   obj          : SSIT object (with fields like DataLoadingAndFittingTabOutputs, etc.)
            %   fitSolution  : struct returned by computeLikelihood (3rd output), or [] to recompute
            %   plotType     : "histograms" | "trajectories" | "likelihood" | "all"
            %   figureNums   : [] or vector of figure numbers to reuse
            %   lineProps    : e.g., {'linewidth',2}
            %   opts         : struct with fields:
            %       .SmoothWindow       (double, default=1)
            %       .UsePanels          (logical, default=true)
            %       .VarianceType       ("STD" or "IQR", default="STD")
            %       .IQRRange           (double, default=0.25)
            %       .SuppressFigures    (logical, default=false)
            %       .Title              (string, default="")
            %       .TitleFontSize      (double, default=18)
            %       .AxisLabelSize      (double, default=18)
            %       .TickLabelSize      (double, default=18)
            %       .LegendFontSize     (double, default=16)
            %       .LegendLocation     (string, default="best")
            %       .XLabel             (string, default="Time")
            %       .YLabel             (string, default="Response")
            %
            % Output:
            %   figHandles   : cell array of figure handles (in order of creation)
            
                arguments
                    obj
                    fitSolution = []
                    plotType (1,1) string = "histograms"
                    figureNums = []
                    lineProps = {'linewidth',2}
                    opts.SpeciesNames = []   
                    opts.SpeciesIdx   = []   
                    opts.SmoothWindow (1,1) double {mustBePositive} = 1
                    opts.UsePanels (1,1) logical = true
                    opts.VarianceType (1,1) string = "STD" % or "IQR"
                    opts.IQRRange (1,1) double {mustBePositive} = 0.25
                    opts.SuppressFigures (1,1) logical = false
                    opts.Title (1,1) string = ""
                    opts.TitleFontSize (1,1) double {mustBePositive} = 18
                    opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                    opts.TickLabelSize (1,1) double {mustBePositive} = 18
                    opts.LegendFontSize (1,1) double {mustBePositive} = 16
                    opts.LegendLocation (1,1) string = "best"
                    opts.XLabel (1,1) string = "Time"
                    opts.YLabel (1,1) string = "Response"
                    opts.XLim double = []
                    opts.YLim double = []
                    opts.ProbXLim double = []    
                    opts.ProbYLim double = []    % only used for DistType == 1 (PDF)
                end
            
                % ---- Compute fitSolution if needed ----
                if isempty(fitSolution)
                    [~,~,fitSolution] = obj.computeLikelihood;
                end
                app = fitSolution;  
            
                figHandles = {};
            
                % ---- Figure visibility ----
                if opts.SuppressFigures
                    visible = 'off';
                    set(0,'DefaultFigureVisible','off');
                    if ~isempty(figureNums) && (~iscell(figureNums) || ~ishandle(figureNums{1}))
                        disp('Creating new figures -- to reuse figures, figureNums must be a cell of figure handles');
                        figureNums = [];
                    end
                else
                    visible = 'on';
                end
            
                % ---- Dispatch by plotType ----
                switch lower(char(plotType))
                    case 'histograms'
                        figHandles = [figHandles, plotHistograms(app, figureNums, lineProps, opts, visible)];
            
                    case 'trajectories'
                        figHandles = [figHandles, plotTrajectories(app, figureNums, lineProps, opts, visible)];
            
                    case 'likelihood'
                        figHandles = [figHandles, plotLikelihood(app, figureNums, lineProps, opts, visible)];
            
                    case 'all'
                        figHandles = [figHandles, plotHistograms(app, figureNums, lineProps, opts, visible)];
                        figHandles = [figHandles, plotTrajectories(app, figureNums, lineProps, opts, visible)];
                        figHandles = [figHandles, plotLikelihood(app, figureNums, lineProps, opts, visible)];
            
                    otherwise
                        error('Unknown plotType "%s". Use "histograms", "trajectories", "likelihood", or "all".', plotType);
                end
            
                % Reset default figure visibility if we changed it
                if opts.SuppressFigures
                    set(0,'DefaultFigureVisible','on');
                end
            
                % ---------------- nested helpers ----------------
            
                function figs = plotHistograms(app, fnums, lineProps, o, visible)
                    figs = {};
                    numTimes = length(app.ParEstFitTimesList.Value);
            
                    % Full model/data dimensions
                    NdModFit = max(1, length(size(app.DataLoadingAndFittingTabOutputs.fitResults.current))-1);
                    NdDatAll = length(app.SpeciesForFitPlot.Value);
                    if NdModFit ~= NdDatAll
                        error('Model and Data size do not match in fitting routine');
                    end
            
                    % Species selection (subset of fitted species)
                    [selIdx, selNames] = getSelectedFitSpecies(app, o);
                    NdDat = numel(selIdx);
            
                    % Loop over DistType: 0 = CDF, 1 = PDF
                    for DistType = 0:1
                        % Choose figure
                        if isempty(fnums)
                            figHandle = figure('Visible',visible);
                        elseif iscell(fnums)
                            figHandle = fnums{DistType+1};
                            set(0,'CurrentFigure',figHandle);
                        else
                            figHandle = figure(fnums(DistType+1));
                        end
            
                        if DistType==0
                            set(figHandle,'Name','Cumulative Distributions versus Time');
                        else
                            set(figHandle,'Name','Probability Distributions versus Time');
                        end
            
                        % Subplot layout
                        if numTimes <= 4
                            subPlotSize = [1, numTimes];
                        else
                            subPlotSize(2) = ceil(sqrt(numTimes));
                            subPlotSize(1) = ceil(numTimes/subPlotSize(2));
                        end
            
                        % Hold legend names across all subplots
                        allLegNames = {};
            
                        % Loop over times
                        for iTime = 1:numTimes
                            if o.UsePanels
                                subplot(subPlotSize(1), subPlotSize(2), iTime);
                            end
                            ax = gca;
                            hold(ax,'on');
                            ax.FontSize = o.TickLabelSize;
            
                            LegNames = {};
                            dataTensor = double(app.DataLoadingAndFittingTabOutputs.dataTensor);
                            modelTensorAll = app.DataLoadingAndFittingTabOutputs.fitResults.current;
                            xm = 0; ym = 0;
            
                        for k = 1:NdDat
                            j = selIdx(k);              % index into fitted species
                            speciesName = selNames{k};  % correct plotted species name
                
                            % indices to sum over in model tensor (other species)
                            indsToSumOver = setdiff(1:NdModFit, j);
                
                            %% --- Data histogram for species j ---
                            dataTensor = double(app.DataLoadingAndFittingTabOutputs.dataTensor);
                            if ndims(app.DataLoadingAndFittingTabOutputs.dataTensor) == 1
                                Hdat = dataTensor;
                            else
                                Hdat = squeeze(dataTensor(iTime,:,:,:,:,:,:,:,:,:));
                            end
                            if ~isempty(indsToSumOver)
                                Hdat = sum(Hdat, indsToSumOver);
                            end
                            Hdat = Hdat(:);
                            Hdat = Hdat / max(sum(Hdat), eps);
                            xDat = 0:length(Hdat)-1;
                
                            if DistType == 1   % PDF
                                yDat = smoothBins(Hdat, o.SmoothWindow);
                            else               % CDF
                                yDat = cumsum(Hdat);
                            end
                
                            stairs(ax, xDat, yDat, lineProps{:});
                            LegNames{end+1} = [speciesName,'-data']; 
                            xm = max(xm, length(Hdat));
                            ym = max(ym, max(yDat));

                            % ----- style for this subplot -----
                            title(ax, ['t = ', app.ParEstFitTimesList.Value{iTime}], 'FontSize', o.TitleFontSize-2);
                            ylabel(ax, 'Probability', 'FontSize', o.AxisLabelSize-2);
                            set(ax,'FontSize',o.TickLabelSize);
                    
                            % NEW: apply per-plot limits only to Probability Distributions
                            if DistType == 1
                                if ~isempty(o.ProbXLim), xlim(ax, o.ProbXLim); end
                                if ~isempty(o.ProbYLim), ylim(ax, o.ProbYLim); end
                            end
                
                            %% --- Model histogram for species j ---
                            modelTensorAll = app.DataLoadingAndFittingTabOutputs.fitResults.current;
                            inds = modelTensorAll.subs;
                            inds = inds(inds(:,1) == iTime,:);
                            vals = modelTensorAll(inds);
                            modelTensor = double(sptensor(inds(:,2:end), vals));
                            if ~isempty(indsToSumOver)
                                Hmod = squeeze(sum(modelTensor, indsToSumOver));
                            else
                                Hmod = squeeze(modelTensor);
                            end
                            Hmod = Hmod(:);
                            xMod = 0:length(Hmod)-1;
                
                            if DistType == 1
                                yMod = smoothBins(Hmod, o.SmoothWindow);
                            else
                                yMod = cumsum(Hmod);
                            end
                
                            stairs(ax, xMod, yMod, lineProps{:});
                            LegNames{end+1} = [speciesName,'-mod']; 
                
                            xm = max(xm, length(Hmod));
                            ym = max(ym, max(yMod));
                                    end
            
                            title(ax, sprintf('t = %s', app.ParEstFitTimesList.Value{iTime}), ...
                                  'FontSize', max(o.TitleFontSize-2, 8), 'FontWeight','bold');
                            if mod(iTime, subPlotSize(2)) == 1
                                ylabel(ax, 'Probability', 'FontSize', o.AxisLabelSize);
                            end
                            if iTime > numTimes - subPlotSize(2)
                                xlabel(ax, 'Molecule Count', 'FontSize', o.AxisLabelSize);
                            end
                            grid(ax,'on'); box(ax,'on');
            
                            allLegNames = [allLegNames, LegNames];
                        end
            
                        if ~isempty(allLegNames)
                            lgd = legend(allLegNames, 'Location', char(o.LegendLocation));
                            if ~isempty(lgd), lgd.FontSize = o.LegendFontSize; end
                        end
            
                        if strlength(o.Title) > 0
                            sgtitle(string(o.Title), 'FontSize', o.TitleFontSize, 'FontWeight','bold');
                        else
                            if DistType==0
                                sgtitle('Cumulative Distributions versus Time', ...
                                        'FontSize', o.TitleFontSize, 'FontWeight','bold');
                            else
                                sgtitle('Probability Distributions versus Time', ...
                                        'FontSize', o.TitleFontSize, 'FontWeight','bold');
                            end
                        end
            
                        figs{end+1} = figHandle; 
                    end
                end
            
             function figs = plotTrajectories(app, fnums, lineProps, o, visible)
                figs = {};
        
                % --- pull options consistent with original code ---
                varianceType = char(o.VarianceType);   % 'STD' or 'IQR'
                IQRrange     = o.IQRRange;
        
                % --- choose / create figure as before ---
                if isempty(fnums)
                    figHandle = figure('Visible',visible);
                elseif iscell(fnums)
                    figHandle = fnums{3}; set(0,'CurrentFigure',figHandle);
                else
                    figHandle = figure(fnums(3));
                end
        
                switch upper(varianceType)
                    case 'STD'
                        set(figHandle,'Name','Mean +/- std vs. time');
                    otherwise
                        set(figHandle,'Name','Mean vs. time');
                end
        
                meanVarTrajAxis = gca;
                hold(meanVarTrajAxis,'on');
        
                % ----- core dimensions from original code -----
                numTimes = length(app.ParEstFitTimesList.Value);              % # data time points
                NdDat    = length(app.SpeciesForFitPlot.Value);               % # fitted species
        
                % ----- rebuild dataHistTime exactly as before -----
                % (so trajectories use the same data as the histogram plots)
                dataHistTime = cell(numTimes, NdDat);
                dataTensor   = double(app.DataLoadingAndFittingTabOutputs.dataTensor);
        
                NdModFit = max(1, length(size(app.DataLoadingAndFittingTabOutputs.fitResults.current)) - 1);
                if NdModFit ~= NdDat
                    error('Model and Data size do not match in fitting routine');
                end
        
                for iTime = 1:numTimes
                    if ndims(app.DataLoadingAndFittingTabOutputs.dataTensor) == 1
                        baseSlice = dataTensor;
                    else
                        baseSlice = squeeze(dataTensor(iTime,:,:,:,:,:,:,:,:,:));
                    end
        
                    for icb = 1:NdDat
                        indsToSumOver = setdiff(1:NdModFit, icb);
                        H1 = baseSlice;
                        if ~isempty(indsToSumOver)
                            H1 = sum(H1, indsToSumOver);
                        end
                        H1 = H1(:);
                        H1 = H1 / max(sum(H1), eps);      % normalize (same as original)
                        dataHistTime{iTime, icb} = H1;
                    end
                end
        
                % ----- MODEL mean / variance as in original code -----
                tArrayModel = eval(app.FspPrintTimesField.Value);
        
                mnsMod     = zeros(length(tArrayModel), NdDat);
                mns2Mod    = zeros(length(tArrayModel), NdDat);
                lowIQRmod  = zeros(length(tArrayModel), NdDat);
                highIQRmod = zeros(length(tArrayModel), NdDat);
        
                for iTime = 1:length(tArrayModel)
                    for j = 1:NdDat
                        % original "soInds" logic (by name, not simple index setdiff)
                        soInds = find(~strcmp(app.SpeciesForFitPlot.Items, app.SpeciesForFitPlot.Value{j}));
        
                        px = app.FspTabOutputs.solutions{iTime}.p;
                        if ~isempty(app.FIMTabOutputs.distortionOperator)
                            px = app.FIMTabOutputs.distortionOperator.computeObservationDist(px, soInds);
                        end
                        if isempty(soInds)
                            Z = double(px.data);
                        else
                            Z = double(px.sumOver(soInds).data);
                        end
                        Z = Z(:);
        
                        inds = 0:length(Z)-1;
                        mnsMod(iTime,j)  = inds * Z;
                        mns2Mod(iTime,j) = (inds.^2) * Z;
        
                        if strcmpi(varianceType, 'IQR')
                            sumZ = cumsum(Z);
                            [~, Iu] = unique(sumZ);
        
                            if sumZ(1) > IQRrange
                                lowIQRmod(iTime,j) = 0;
                            else
                                lowIQRmod(iTime,j) = interp1(sumZ(Iu), Iu-1, IQRrange);
                            end
                            if sumZ(1) > 1 - IQRrange
                                highIQRmod(iTime,j) = 0;
                            else
                                highIQRmod(iTime,j) = interp1(sumZ(Iu), Iu-1, 1 - IQRrange);
                            end
                        end
                    end
                end
        
                varsMod = mns2Mod - mnsMod.^2;
                cols  = ['b','r','g','m','c','k'];
                cols2 = [.90 .90 1.00; 1.00 .90 .90; .90 1.00 .90; ...
                         .60 .60 1.00; 1.00 .60 .60; .60 1.00 .60];
        
                LG = {};
        
                % ----- plot MODEL trajectories (all fitted species) -----
                for iplt = 1:NdDat
                    switch upper(varianceType)
                        case 'STD'
                            BD = [ mnsMod(:,iplt)' + sqrt(varsMod(:,iplt)'), ...
                                   mnsMod(end:-1:1,iplt)' - sqrt(varsMod(end:-1:1,iplt)') ];
                        case 'IQR'
                            BD = [ highIQRmod(:,iplt)', ...
                                   lowIQRmod(end:-1:1,iplt)' ];
                        otherwise
                            BD = [ mnsMod(:,iplt)' + sqrt(varsMod(:,iplt)'), ...
                                   mnsMod(end:-1:1,iplt)' - sqrt(varsMod(end:-1:1,iplt)') ];
                    end
                    TT    = [tArrayModel(1:end), tArrayModel(end:-1:1)];
                    ipCol = mod(iplt-1, size(cols2,1)) + 1;
        
                    fill(meanVarTrajAxis, TT, BD, cols2(ipCol,:), 'EdgeColor','none');
                    plot(meanVarTrajAxis, tArrayModel, mnsMod(:,iplt), cols(ipCol), lineProps{:});
        
                    % Legend name from fitted species
                    spName = app.SpeciesForFitPlot.Value{iplt};
                    if isstring(spName), spName = char(spName); end
        
                    LG{end+1} = sprintf('%s Model Mean \x00B1 %s', spName, varianceType); 
                    LG{end+1} = sprintf('%s Model Mean',          spName);                
                end
        
                % ----- DATA means/vars from dataHistTime (original logic) -----
                mnsDat     = zeros(numTimes, NdDat);
                mns2Dat    = zeros(numTimes, NdDat);
                lowIQRdat  = zeros(numTimes, NdDat);
                highIQRdat = zeros(numTimes, NdDat);
        
                for iTime = 1:numTimes
                    for j = 1:NdDat
                        H = dataHistTime{iTime,j};
                        H = H(:);
                        inds = 0:length(H)-1;
        
                        mnsDat(iTime,j)  = inds * H;
                        mns2Dat(iTime,j) = (inds.^2) * H;
        
                        if strcmpi(varianceType, 'IQR')
                            sumZ = cumsum(H);
                            [~, Iu] = unique(sumZ);
        
                            if sumZ(1) > IQRrange
                                lowIQRdat(iTime,j) = 0;
                            else
                                lowIQRdat(iTime,j) = interp1(sumZ(Iu), Iu-1, IQRrange);
                            end
                            if sumZ(1) > 1 - IQRrange
                                highIQRdat(iTime,j) = 0;
                            else
                                highIQRdat(iTime,j) = interp1(sumZ(Iu), Iu-1, 1 - IQRrange);
                            end
                        end
                    end
                end
        
                varDat  = mns2Dat - mnsDat.^2;
                T_array = app.DataLoadingAndFittingTabOutputs.fittingOptions.dataTimes;
        
                % ----- plot DATA errorbars (all fitted species) -----
                for j = 1:NdDat
                    ipCol  = mod(j-1, length(cols)) + 1;
                    spName = app.SpeciesForFitPlot.Value{j};
                    if isstring(spName), spName = char(spName); end
        
                    switch upper(varianceType)
                        case 'STD'
                            errorbar(meanVarTrajAxis, T_array, ...
                                mnsDat(:,j), sqrt(varDat(:,j)), ...
                                [cols(ipCol),'o'], 'MarkerSize',12, ...
                                'MarkerFaceColor', cols(ipCol), ...
                                lineProps{:});
                        case 'IQR'
                            errorbar(meanVarTrajAxis, T_array, ...
                                mnsDat(:,j), ...
                                (mnsDat(:,j) - lowIQRdat(:,j)), ...
                                (highIQRdat(:,j) - mnsDat(:,j)), ...
                                [cols(ipCol),'o'], 'MarkerSize',12, ...
                                'MarkerFaceColor', cols(ipCol), ...
                                lineProps{:});
                    end
        
                    % Legend name from fitted species
                    LG{end+1} = sprintf('%s Data Mean \x00B1 %s', spName, varianceType); 
                end
        
                % ----- axes labels, title, legend & styling using opts -----
                ax = meanVarTrajAxis;
                ax.FontSize = o.TickLabelSize;
        
                xlabel(ax, o.XLabel, 'FontSize', o.AxisLabelSize);
                ylabel(ax, o.YLabel, 'FontSize', o.AxisLabelSize);
        
                if max(T_array) > 0
                    xlim(ax, [0, max(T_array)]);
                end
                if ~isempty(o.XLim), xlim(ax, o.XLim); end
                if ~isempty(o.YLim), ylim(ax, o.YLim); end
        
                if strlength(o.Title) > 0
                    title(ax, string(o.Title), ...
                        'FontSize', o.TitleFontSize, 'FontWeight','bold');
                else
                    title(ax, 'Trajectory of means and standard deviations', ...
                        'FontSize', o.TitleFontSize, 'FontWeight','bold');
                end
        
                grid(ax,'on'); box(ax,'on');
        
                if ~isempty(LG) && ~strcmpi(o.LegendLocation,"none")
                    lgd = legend(ax, LG, 'Location', char(o.LegendLocation));
                    if ~isempty(lgd), lgd.FontSize = o.LegendFontSize; end
                end
        
                figs{end+1} = figHandle;
            end

            
                function figs = plotLikelihood(app, fnums, lineProps, o, visible)
                    figs = {};
            
                    if isempty(fnums)
                        figHandle = figure('Visible',visible);
                    elseif iscell(fnums)
                        figHandle = fnums{4}; set(0, 'CurrentFigure', figHandle);
                    else
                        figHandle = figure(fnums(4));
                    end
                    set(figHandle,'Name','Likelihood vs Time');
            
                    tData = app.DataLoadingAndFittingTabOutputs.fittingOptions.dataTimes;
                    V_LogLk    = app.DataLoadingAndFittingTabOutputs.V_LogLk;
                    perfectMod = app.DataLoadingAndFittingTabOutputs.perfectMod;
                    numCells   = app.DataLoadingAndFittingTabOutputs.numCells;
            
                    % 1) Log-likelihoods
                    subplot(3,1,1);
                    plot(tData, V_LogLk, lineProps{:}); hold on
                    plot(tData, perfectMod, lineProps{:});
                    ylabel('log-likelihood', 'FontSize', o.AxisLabelSize);
                    legend({'log(L) - best fit for model', 'log(L) - theoretical limit'}, ...
                           'Location','best', 'FontSize', o.LegendFontSize);
                    set(gca,'FontSize', o.TickLabelSize);
            
                    % 2) Number of cells
                    subplot(3,1,2);
                    plot(tData, numCells, lineProps{:});
                    ylabel('# Cells', 'FontSize', o.AxisLabelSize);
                    set(gca,'FontSize', o.TickLabelSize);
            
                    % 3) Per-cell delta log-likelihood
                    subplot(3,1,3);
                    plot(tData, (V_LogLk - perfectMod)./max(numCells,eps), lineProps{:});
                    ylabel('\Delta log(L) / Cell', 'FontSize', o.AxisLabelSize);
                    xlabel('Time', 'FontSize', o.AxisLabelSize);
                    set(gca,'FontSize', o.TickLabelSize);
            
                    if strlength(o.Title) > 0
                        sgtitle(string(o.Title), 'FontSize', o.TitleFontSize, 'FontWeight','bold');
                    else
                        sgtitle('Log-Likelihood Diagnostics vs Time', ...
                                'FontSize', o.TitleFontSize, 'FontWeight','bold');
                    end
            
                    figs{end+1} = figHandle;
                end
            
                function sb = smoothBins(x,bnsz)
                    sb = zeros(size(x));
                    for i = 1:length(x)
                        j = bnsz * floor((i-1)/bnsz);
                        idx = j+1:min(j+bnsz, length(x));
                        sb(idx) = sb(idx) + x(i);
                    end
                end

                function [selIdx, selNames] = getSelectedFitSpecies(app, o)
                    % Base list = fitted species (the ones in the fitting tab)
                    allNames = app.SpeciesForFitPlot.Value;
                    if isstring(allNames), allNames = cellstr(allNames); end
                    nFit = numel(allNames);
            
                    % User-specified by name
                    if ~isempty(o.SpeciesNames)
                        names = o.SpeciesNames;
                        if isstring(names), names = cellstr(names); end
                        if ischar(names),   names = {names};       end
            
                        [tf, loc] = ismember(names, allNames);
                        if any(~tf)
                            bad = names(~tf);
                            error('Unknown species name(s) in opts.SpeciesNames: %s. Available: %s', ...
                                strjoin(bad, ', '), strjoin(allNames, ', '));
                        end
                        selIdx   = loc(:).';
                        selNames = allNames(selIdx);
                        return;
                    end
            
                    % User-specified by index
                    if ~isempty(o.SpeciesIdx)
                        idx = unique(o.SpeciesIdx(:).');
                        if any(idx < 1 | idx > nFit)
                            error('opts.SpeciesIdx must be in 1..%d (number of fitted species).', nFit);
                        end
                        selIdx   = idx;
                        selNames = allNames(selIdx);
                        return;
                    end
            
                    % Default = all fitted species
                    selIdx   = 1:nFit;
                    selNames = allNames;
                end
            end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        function figHandles = makeFitPlot(obj,fitSolution,smoothWindow,fignums,usePanels, ...
                varianceType,IQRrange,suppressFigures)
            % Produces plots to compare model to experimental data.
            arguments
                obj
                fitSolution =[];
                smoothWindow = 1;
                fignums = [];
                usePanels=true;
                varianceType = 'STD';  % Plot type standard deviation ('STD') or interquartile range ('IQR'). {'STD', 'IQR'}
                IQRrange = 0.25        % Interquartile range for plotting (will draw lines at [IQRrange,1-IQRrange]).
                suppressFigures = false % Hide figures.  Will need to manually make them visible again for viewing.
            end
            if isempty(fitSolution)
                [~,~,fitSolution] = obj.computeLikelihood;
            end
            figHandles = makeSeparatePlotOfData(fitSolution,smoothWindow,fignums,usePanels, ...
                varianceType,IQRrange,suppressFigures);
        end

        function makeMleFimPlot(obj,MLE,FIM,indPars,CI,figNum,par0)
            arguments
                obj
                MLE = []
                FIM = []
                indPars = [1,2];
                CI = 0.95
                figNum=[]
                par0 = []
            end
            if isempty(figNum)
                f = gcf; set(0,'CurrentFigure',f);
            else
                f = figure(figNum); set(0,'CurrentFigure',f);
            end

            CIp = round(CI*100);

            legs = {};

            if ~isempty(MLE)
                scatter(MLE(indPars(1),:),MLE(indPars(2),:),100*ones(size(MLE(indPars(1),:))),'filled');
                covMLE = cov(MLE');
                muMLE = mean(MLE,2);
                hold on
                ssit.parest.ellipse(muMLE(indPars),icdf('chi2',CI,2)*covMLE(indPars,indPars),'linewidth',3)
                legs(end+1:end+2) = {['MLE, N=',num2str(length(MLE))],[num2str(CIp),'% CI (MLE)']};
                if isempty(par0)
                    par0 = muMLE;
                end
            end

            if ~isempty(FIM)
                covFIM = FIM^(-1);
                ssit.parest.ellipse(par0(indPars),icdf('chi2',CI,2)*covFIM(indPars,indPars),'--','linewidth',3)
                legs(end+1) = {[num2str(CIp),'% CI (FIM)']};
            end
            set(gca,'fontsize',15)
            legend(legs)

        end


       function plotFIMResults(obj, fimInput, paramNames, theta0, opts)
            % plotFIMResults  Visualize a Fisher Information Matrix (FIM) and
            %                 FIM-based parameter uncertainty ellipses.
            %
            %   obj.plotFIMResults(fimInput)
            %   obj.plotFIMResults(fimInput, paramNames)
            %   obj.plotFIMResults(fimInput, paramNames, theta0)
            %   obj.plotFIMResults(fimInput, paramNames, theta0, opts)
            %
            %   fimInput   : either an n x n numeric FIM, or a 1x1 cell containing it
            %                e.g., Model_fimTotal = {4x4 double}
            %
            %   paramNames : cell array of parameter names, e.g.,
            %                  {'k_{on}','k_{off}','k_r','k_d'}
            %                If empty or omitted, defaults to {'\theta_1', ..., '\theta_n'}.
            %
            %   theta0     : 1 x n vector of nominal parameter values
            %                (center of ellipses; e.g., log10-parameters).
            %                If empty or omitted, defaults to zeros(1,n).
            %
            %   opts (name-value via arguments block):
            %       .UseLog10        (logical, default true)
            %       .FigureHandle    (default: new figure)
            %       .PlotEllipses    (logical, default true)
            %       .EllipseLevel    (double, default 0.9)  confidence level
            %       .EllipseFigure   (default: new figure)
            %       .EllipsePairs    (default: [])  subset of parameter index pairs
            %                        to plot as ellipses; numeric Kx2 matrix:
            %                        [i1 j1; i2 j2; ...], 1 <= i < j <= nParams
            %
            %       .Colors          (struct or [], default [])
            %           Optional fields:
            %               .HeatmapColormap  colormap handle or name (e.g. parula, 'hot')
            %               .DiagBars         color for diag(FIM) bars
            %               .EigBars          color for eigenvalue bars
            %               .Ellipse          line spec for ellipses (e.g. 'r--')
            %
            %       .Title           (string, default "")
            %       .TitleFontSize   (double, default 14)
            %       .AxisLabelSize   (double, default 14)
            %       .TickLabelSize   (double, default 12)
            %       .LegendFontSize  (double, default 14)   
            %       .LegendLocation  (string, default "best")
            
                arguments
                    obj
                    fimInput
                    paramNames = []
                    theta0 = []
                    opts.UseLog10 (1,1) logical = true
                    opts.FigureHandle = []
                    opts.PlotEllipses (1,1) logical = true
                    opts.EllipseLevel (1,1) double {mustBePositive} = 0.9
                    opts.EllipseFigure = []
                    opts.EllipsePairs = []
            
                    opts.Colors = []   
                    opts.Title (1,1) string = ""
                    opts.TitleFontSize (1,1) double {mustBePositive} = 14
                    opts.AxisLabelSize (1,1) double {mustBePositive} = 14
                    opts.TickLabelSize (1,1) double {mustBePositive} = 12
                    opts.LegendFontSize (1,1) double {mustBePositive} = 14
                    opts.LegendLocation (1,1) string = "best"
                end
            
                % -------- Extract numeric FIM --------
                if iscell(fimInput)
                    fim = fimInput{1};
                else
                    fim = fimInput;
                end
            
                if ~ismatrix(fim) || size(fim,1) ~= size(fim,2)
                    error('FIM must be a square matrix or a 1x1 cell containing a square matrix.');
                end
            
                nParams = size(fim,1);
            
                % Default parameter names if not provided
                if isempty(paramNames)
                    paramNames = arrayfun(@(i) sprintf('\\theta_{%d}', i), ...
                                          1:nParams, 'UniformOutput', false);
                end
            
                % Default theta0 (ellipse centers)
                if isempty(theta0)
                    theta0 = zeros(1, nParams);
                end
                if numel(theta0) ~= nParams
                    error('theta0 must be a vector of length %d (number of parameters).', nParams);
                end
            
                % Convenience alias
                C = opts.Colors;
            
                % -------- Basic spectral info --------
                % Make sure FIM is symmetric (numerical noise)
                fimSym = 0.5 * (fim + fim.');
            
                [eigVec, eigValMat] = eig(fimSym);
                eigVals = diag(eigValMat);
            
                % Condition number using positive eigenvalues only
                posEig = eigVals(eigVals > 0);
                if isempty(posEig)
                    condInfo = NaN;
                else
                    condInfo = max(posEig) / min(posEig);
                end
            
                % -------- Prepare plotting values --------
                if opts.UseLog10
                    % Avoid taking log10 of non-positive values
                    epsVal   = 1e-16;
                    fimDisp  = log10(max(fimSym, epsVal));
                    eigDisp  = log10(max(eigVals, epsVal));
                    fimLabel = 'log_{10} FIM';
                    eigLabel = 'log_{10} eigenvalues';
                else
                    fimDisp  = fimSym;
                    eigDisp  = eigVals;
                    fimLabel = 'FIM';
                    eigLabel = 'Eigenvalues';
                end
            
                diagInfo = diag(fimSym);
            
                % -------- Figure for FIM matrix/diag/eigs --------
                if ~isempty(opts.FigureHandle) && ishghandle(opts.FigureHandle)
                    fig = opts.FigureHandle;
                    figure(fig); clf;
                else
                    fig = figure;
                end
                set(fig, 'Name', 'FIM Results', 'NumberTitle', 'off');
            
                % Optional global title
                if opts.Title ~= ""
                    sgtitle(opts.Title, 'FontSize', opts.TitleFontSize, 'FontWeight', 'bold');
                end
            
                % Layout: 2x2 grid
                % (1) Heatmap of FIM
                subplot(2,2,[1 3]); % big panel on left
                imagesc(fimDisp);
                axis square;
                cb = colorbar;
                if ~isempty(C) && isstruct(C) && isfield(C,'HeatmapColormap')
                    colormap(C.HeatmapColormap);
                else
                    colormap(parula);
                end
                set(gca, 'XTick', 1:nParams, 'XTickLabel', paramNames, ...
                         'YTick', 1:nParams, 'YTickLabel', paramNames, ...
                         'TickLabelInterpreter', 'tex', ...
                         'FontSize', opts.TickLabelSize);
                xlabel('Parameter', 'FontSize', opts.AxisLabelSize);
                ylabel('Parameter', 'FontSize', opts.AxisLabelSize);
                title(fimLabel, 'FontSize', opts.AxisLabelSize, 'FontWeight', 'bold');
                cb.Label.String = fimLabel;
                cb.Label.FontSize = opts.AxisLabelSize;
            
                % (2) Bar plot of diagonal (per-parameter information)
                subplot(2,2,2);
                hBarDiag = bar(diagInfo);
                if ~isempty(C) && isstruct(C) && isfield(C,'DiagBars')
                    set(hBarDiag, 'FaceColor', C.DiagBars);
                end
                set(gca, 'XTick', 1:nParams, 'XTickLabel', paramNames, ...
                         'TickLabelInterpreter', 'tex', ...
                         'FontSize', opts.TickLabelSize);
                xlabel('Parameter', 'FontSize', opts.AxisLabelSize);
                ylabel('Diagonal entry of FIM', 'FontSize', opts.AxisLabelSize);
                title('Per-parameter information (diag(FIM))', ...
                      'FontSize', opts.AxisLabelSize, 'FontWeight', 'bold');
            
                % (3) Bar plot of eigenvalues
                subplot(2,2,4);
                hBarEig = bar(eigDisp);
                if ~isempty(C) && isstruct(C) && isfield(C,'EigBars')
                    set(hBarEig, 'FaceColor', C.EigBars);
                end
                set(gca, 'FontSize', opts.TickLabelSize);
                xlabel('Eigenvalue index', 'FontSize', opts.AxisLabelSize);
                ylabel(eigLabel, 'FontSize', opts.AxisLabelSize);
                title(sprintf('FIM spectrum (cond. ~ %.2e)', condInfo), ...
                      'FontSize', opts.AxisLabelSize, 'FontWeight', 'bold');
            
                % -------- Optional: ellipse plots --------
                if opts.PlotEllipses
                    % FIM-based covariance (sanitized inverse using eigen-decomposition)
                    epsShift = 1e-12;
                    [V,D] = eig(fimSym);
                    lam   = diag(D);
                    lamSafe = max(lam, epsShift);
                    covFIM = V * diag(1 ./ lamSafe) * V.';
                    covFIM = 0.5 * (covFIM + covFIM.');   % symmetrize inverse
            
                    % Make or reuse ellipse figure
                    if ~isempty(opts.EllipseFigure) && ishghandle(opts.EllipseFigure)
                        figEll = opts.EllipseFigure;
                        figure(figEll); clf;
                    else
                        figEll = figure;
                    end
                    set(figEll, 'Name', 'FIM-based covariance ellipses', 'NumberTitle', 'off');
            
                    if opts.Title ~= ""
                        sgtitle(opts.Title, 'FontSize', opts.TitleFontSize, 'FontWeight', 'bold');
                    end
            
                    % chi^2 quantile for given confidence level, df=2
                    chi2val = icdf('chi2', opts.EllipseLevel, 2);
            
                    ellipsePairs = opts.EllipsePairs;
            
                    % Choose line style for ellipses
                    if ~isempty(C) && isstruct(C) && isfield(C,'Ellipse')
                        ellipseSpec = C.Ellipse;
                    else
                        ellipseSpec = 'k-';
                    end
            
                    if isempty(ellipsePairs)
                        % --- Default: plot all upper-triangular pairs in an (n-1)x(n-1) grid ---
                        for iParam = 1:nParams-1
                            for jParam = iParam+1:nParams
                                subplot(nParams-1, nParams-1, (iParam-1)*(nParams-1) + jParam-1);
            
                                % 2x2 sub-covariance and center (order [theta_j, theta_i])
                                subCov = covFIM([jParam iParam],[jParam iParam]);
                                mu     = theta0([jParam iParam]);
            
                                ssit.parest.ellipse(mu, chi2val * subCov, ellipseSpec, 'LineWidth', 2); hold on;
                                plot(mu(1), mu(2), 'ks', 'MarkerSize', 8, 'MarkerFaceColor', 'w');
            
                                xlabel(sprintf('%s', paramNames{jParam}), 'Interpreter', 'tex', ...
                                       'FontSize', opts.AxisLabelSize);
                                ylabel(sprintf('%s', paramNames{iParam}), 'Interpreter', 'tex', ...
                                       'FontSize', opts.AxisLabelSize);
                                set(gca, 'FontSize', opts.TickLabelSize);
                                axis equal; grid on;
                            end
                        end
                    else
                        % --- Subset mode: ellipsePairs is Kx2 matrix of [i j] index pairs ---
                        if ~ismatrix(ellipsePairs) || size(ellipsePairs,2) ~= 2
                            error('EllipsePairs must be a Kx2 numeric matrix of parameter index pairs [i j].');
                        end
                        K = size(ellipsePairs,1);
                        % Layout: as square as possible
                        nRows = ceil(sqrt(K));
                        nCols = ceil(K / nRows);
            
                        for k = 1:K
                            iParam = ellipsePairs(k,1);
                            jParam = ellipsePairs(k,2);
            
                            if ~isscalar(iParam) || ~isscalar(jParam) || ...
                                    iParam < 1 || jParam < 1 || ...
                                    iParam > nParams || jParam > nParams || iParam == jParam
                                error('Invalid EllipsePairs entry at row %d: [%d %d].', k, iParam, jParam);
                            end
            
                            subplot(nRows, nCols, k);
            
                            % 2x2 sub-covariance and center (order [theta_j, theta_i])
                            subCov = covFIM([jParam iParam],[jParam iParam]);
                            mu     = theta0([jParam iParam]);
            
                            ssit.parest.ellipse(mu, chi2val * subCov, ellipseSpec, 'LineWidth', 2); hold on;
                            plot(mu(1), mu(2), 'ks', 'MarkerSize', 8, 'MarkerFaceColor', 'w');
            
                            xlabel(sprintf('%s', paramNames{jParam}), 'Interpreter', 'tex', ...
                                   'FontSize', opts.AxisLabelSize);
                            ylabel(sprintf('%s', paramNames{iParam}), 'Interpreter', 'tex', ...
                                   'FontSize', opts.AxisLabelSize);
                            set(gca, 'FontSize', opts.TickLabelSize);
                            axis equal; grid on;
                        end
                    end
                end
            end

            
            % --------- Helper: numerically safe inverse of symmetric matrix ----------
            function Ainv = safeInverseSym(A, epsShift)
                % Symmetrize
                A = 0.5 * (A + A.');
                [V,D] = eig(A);
                lam = diag(D);
                % Shift tiny/negative eigenvalues
                lamSafe = max(lam, epsShift);
                Ainv = V * diag(1./lamSafe) * V.';
                % Symmetrize the inverse too
                Ainv = 0.5 * (Ainv + Ainv.');
            end
            
            % --------- Helper: draw ellipse given mean + covariance ------------------
            function h = plotEllipse(mu, Sigma, varargin)
                % Ensures Sigma is symmetric positive semidefinite and plots the ellipse
                Sigma = 0.5 * (Sigma + Sigma.');
                [V,D] = eig(Sigma);
                lam   = diag(D);
                lam(lam < 0) = 0;  % clamp negatives (should be small numerical errors)
                Dpsd  = diag(sqrt(lam));
                % Parametric circle
                t  = linspace(0, 2*pi, 200);
                xy = [cos(t); sin(t)];
                % Transform
                R  = V * Dpsd;
                pts = R * xy + mu(:);
                h = plot(pts(1,:), pts(2,:), varargin{:});
            end


        function plotMHResults(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true
            end

            obj.plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig)
        end
    end
    methods (Static)
        function plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence,plotColors)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true;
                plotColors = struct() % Optional: fields like scatter, ellipseFIM, ellipseMH, etc.
            end

            if isfield(plotColors, 'scatter')
                scatterColor = plotColors.scatter;
            else
                scatterColor = [];
            end

            if isfield(plotColors, 'ellipseFIM')
                ellipseFIMColor = plotColors.ellipseFIM;
            else
                ellipseFIMColor = [];
            end

            if isfield(plotColors, 'ellipseMH')
                ellipseMHColor = plotColors.ellipseMH;
            else
                ellipseMHColor = 'm--';
            end

            if isfield(plotColors, 'marker')
                markerColor = plotColors.marker;
            else
                markerColor = 'k';
            end

            if isempty(obj)
                obj.fittingOptions.modelVarsToFit = 'all';
                obj.parameters(:,2) = num2cell(mean(exp(mhResults.mhSamples)));
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = ones(1,size(obj.parameters,1),'logical');
            end
            parNames = obj.parameters(obj.fittingOptions.modelVarsToFit,1);
            Np = length(parNames);

            if ~isempty(FIM)
                pars = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];

                if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                    parsScaled = log10(pars);
                elseif strcmp(mhPlotScale,'log')
                    parsScaled = log(pars);
                elseif strcmp(mhPlotScale,'lin')
                    parsScaled = pars;
                end

                if ~iscell(FIM)
                    FIM = {FIM};
                end
                %     FIM = diag(pars)*...
                %         FIM(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                %         diag(pars);
                %     covFIM{1} = FIM^(-1)/log(10)^2;
                % else
                for i=1:length(FIM)
                    if isempty(fimScale)||strcmp(fimScale,'lin')
                        FIMi = diag(pars)*...
                            FIM{i}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                            diag(pars);
                    else
                        FIMi = FIM{i};
                    end
                    FIMi = FIMi(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);
                    if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                        covFIM{i} = FIMi^(-1)/log(10)^2;
                    elseif min(eig(FIMi))<1
                        disp('Warning -- FIM has one or more small eigenvalues.  Sanitize negative eigenvalues (numerical instability) for ellipse:')
                        FIMi = (1/2)*(FIMi + FIMi');
                        %covFree{i} = FIMi^(-1);
                        covFIM{i} = FIMi;
                    else
                        covFIM{i} = FIMi^(-1);
                    end
                end
                % end
            end

            if ~isempty(mhResults)
                % Make figures for MH convergence
                if showConvergence
                    fg = figure; set(0,'CurrentFigure',fg)
                    plot(mhResults.mhValue);
                    xlabel('Iteration number');
                    ylabel('log-likelihood')
                    title('MH Convergence')

                    fg = figure; set(0,'CurrentFigure',fg)
                    ac = xcorr(mhResults.mhValue-mean(mhResults.mhValue),'normalized');
                    ac = ac(size(mhResults.mhValue,1):end);
                    plot(ac,'LineWidth',3); hold on
                    N = size(mhResults.mhValue,1);
                    tau = 1+2*sum((ac(2:N/100)));
                    Neff = N/tau;
                    xlabel('Lag');
                    ylabel('Auto-correlation')
                    title('MH Convergence')
                end

                if isempty(scatterFig)
                    fg = figure; set(0,'CurrentFigure',fg);
                else
                    fg = figure(scatterFig); set(0,'CurrentFigure',fg)
                end


                % Select second half of MH chain.
                mhResultsSecondHalf = mhResults;
                mhResultsSecondHalf.mhValue = mhResultsSecondHalf.mhValue(floor(end/2):end);
                mhResultsSecondHalf.mhSamples = mhResultsSecondHalf.mhSamples(floor(end/2):end,:);
                [valDoneSorted,J] = sort(mhResultsSecondHalf.mhValue);
                smplDone = mhResultsSecondHalf.mhSamples(J,:);

                % Compute and display parameter means and standard deviations
                mhMeans = mean(smplDone) / log(10);   % log10 scale
                mhStds  = std(smplDone) / log(10);

                fprintf('\nMH sample means and standard deviations (log10 scale):\n');
                for p = 1:Np
                    fprintf('%15s: mean = % .4f, std = %.4f\n', parNames{p}, mhMeans(p), mhStds(p));
                end

            end

            fimCols = {'k','c','b','g','r'};

            for i=1:Np-1
                for j = i+1:Np
                    subplot(Np-1,Np-1,(i-1)*(Np-1)+j-1);

                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        scatter(smplDone(:,j)/log(10),smplDone(:,i)/log(10),20,valDoneSorted,'filled'); hold on;
                        par0 = mean(smplDone(:,[j,i])/log(10));
                        cov12 = cov(smplDone(:,j)/log(10),smplDone(:,i)/log(10));
                    end
                    if ~isempty(FIM)
                        for iFIM = 1:length(covFIM)
                            ssit.parest.ellipse(parsScaled([j,i]),icdf('chi2',0.9,2)*covFIM{iFIM}([j,i],[j,i]),fimCols{mod(iFIM,5)+1},'linewidth',2); hold on;
                            plot(parsScaled(j),parsScaled(i),'ks','MarkerSize',15)
                            % plot(smplDone(end,j)/log(10),smplDone(end,i)/log(10),'cs','MarkerSize',15)
                        end
                    end
                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        ssit.parest.ellipse(par0,icdf('chi2',0.9,2)*cov12,'m--','linewidth',2);  hold on;
                        % Draw crosshairs at MH mean  std
                        % plot([mhMeans(j)-mhStds(j), mhMeans(j)+mhStds(j)], [mhMeans(i), mhMeans(i)], 'm-', 'LineWidth', 1.5);
                        % plot([mhMeans(j), mhMeans(j)], [mhMeans(i)-mhStds(i), mhMeans(i)+mhStds(i)], 'm-', 'LineWidth', 1.5);
                        %
                        % % Annotate mean location
                        % text(mhMeans(j), mhMeans(i), sprintf('\\leftarrow Mean'), 'Color', 'm', 'FontSize', 8, 'HorizontalAlignment', 'left');

                    end
                    xlabel(['log_{10}(',parNames{j},')']);
                    ylabel(['log_{10}(',parNames{i},')']);
                end
            end
        end
        function FIM = totalFim(fims,Nc,covPrior)
            arguments
                fims
                Nc
                covPrior = [];
            end
            if isempty(covPrior)
                fimPrior = zeros(size(fims{1}));
            else
                fimPrior = inv(covPrior);
            end
            Nt = size(fims,1);
            Ns = size(fims,2);
            FIM = cell(1,Ns);
            for is = 1:Ns
                FIM{is} = fimPrior;
                for it = 1:Nt
                    FIM{is} = FIM{is}+Nc(it)*fims{it,is};
                end
            end
        end
        function k = findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd)
            arguments
                fims
                Ncp
                met
                NcMax = []
                statistic='mean'
                covPrior=[]
                incrementAdd=1
            end
            if isempty(statistic)
                statistic='mean';
            end
            Nt = size(fims,1);
            if isempty(NcMax)
                NcMax = inf*ones(1,Nt);
            end
            Ns = size(fims,2);
            objFun = zeros(Nt,Ns);
            FIM0 = SSIT.totalFim(fims,Ncp,covPrior);
            for is = 1:Ns
                for it = 1:Nt
                    if Ncp(it)+incrementAdd<=NcMax(it)
                        % If one can do that experiment.
                        FIM = FIM0{is}+incrementAdd*fims{it,is};
                    else
                        % If there are no more cells avalable for that time
                        % point.
                        FIM = FIM0{is};
                    end
                    objFun(it,is) = met(FIM);
                end
            end
            switch statistic
                case 'median'
                    [~,k] = min(median(objFun,2));
                case 'mean'
                    [~,k] = min(mean(objFun,2));
                otherwise
                    [~,k] = min(median(objFun,2));
            end
        end
        function propensities = parameterizePropensities(GenProps,Parset)
            propensities = GenProps;
            for i=1:length(GenProps)
                if ~isempty(propensities{i}.stateDependentFactor)
                    propensities{i}.stateDependentFactor = @(x)GenProps{i}.stateDependentFactor(x,Parset);
                end
                if ~isempty(propensities{i}.hybridFactor)
                    propensities{i}.hybridFactor = @(t,v)GenProps{i}.hybridFactor(t,Parset,v');
                end
                if ~isempty(propensities{i}.hybridFactorVector)
                    propensities{i}.hybridFactorVector = @(t,v)GenProps{i}.hybridFactorVector(t,Parset,v');
                end
                if ~isempty(propensities{i}.timeDependentFactor)
                    propensities{i}.timeDependentFactor = @(t)GenProps{i}.timeDependentFactor(t,Parset);
                end
                if ~isempty(propensities{i}.hybridJointFactor)
                    propensities{i}.hybridJointFactor = @(t,x,v)GenProps{i}.hybridJointFactor(t,x,Parset,v');
                end
            end
        end
        function str = replaceSpeciesNames(str,species)
            % Check if species are named 'x1','x2', etc, and if not, find
            % order of species names longest to shortest.
            namedXi = true;
            Len = NaN*ones(length(species));
            for i = 1:length(species)
                Len(i) = length(species{i});
                if ~strcmp(species{i},['x',num2str(i)])
                    namedXi = false;
                end
            end
            if namedXi % No need to change string.
                return
            end

            for i = 1:length(species)
                str = regexprep(str,['\<',species{i},'\>'],['x',num2str(i)]);
            end
            

        end
        function cmd = generateCommandLinePipeline(saveFileIn,modelName,dummy, ...
                Pipeline,pipelineArgs,saveFileOut,logFile,runNow,runOnCluster,clusterPrefix)
            arguments
                saveFileIn
                modelName
                dummy
                Pipeline
                pipelineArgs
                saveFileOut
                logFile
                runNow = false
                runOnCluster = false
                clusterPrefix = 'sbatch --cpus-per-task=1 --output=#LOG --error=#ERR --wrap="module load matlab-2022b; srun matlab -nodisplay -nosplash -nodesktop -r'
            end

            % TODO - code currently works only for Mac and linux.  Need to
            % use 'batch' for Windows.

            % Parse inputs into format needed for command line call.
            str1 = append('(''',saveFileIn,''',''',modelName,''',[],''',Pipeline,''',');
            str2 = 'struct(';
            fieldNames = fields(pipelineArgs);
            for iField = 1:length(fieldNames)
                field = fieldNames{iField};
                if isnumeric(pipelineArgs.(field))||islogical(pipelineArgs.(field))
                    value = num2str(pipelineArgs.(field));
                else
                    value = append('''',pipelineArgs.(field),'''');
                end
                str2 = append(str2,'''',field,''',',value,',');
            end
            str2 = append(str1,str2(1:end-1),'),''',saveFileOut,'''');

            % Add path to SSIT.
            pth = which('SSIT');
            pth = append('addpath(genpath(''',pth(1:end-19),'''));addpath(''tmpPropensityFunctions'');');

            % Add path to matlab executable
            matlabpath = fullfile(matlabroot, 'bin', 'matlab');

            % Build command
            if ~runOnCluster
                cmd = append(matlabpath,' -nodisplay -nosplash -nodesktop -r "',pth,'SSIT',str2,')',...
                    '; exit;" > ',logFile,' 2>&1 < /dev/null &');
            else
                % clusterPrefix = strrep(clusterPrefix,'#LOG',logFile);
                % clusterPrefix = strrep(clusterPrefix,'#ERR',append('err_',logFile));
                clusterPrefix = regexprep(clusterPrefix,'\<#LOG\>',logFile);
                clusterPrefix = regexprep(clusterPrefix,'\<#ERR\>',append('err_',logFile));

                % pth = strrep(pth,"'","''");
                % str2 = strrep(str2,"'","''");

                cmd = append(clusterPrefix,' \"',pth,'SSIT',str2,')',...
                    '; exit;\""');
            end

            % Run command if requested.
            if runNow
                system(cmd);
            end

        end
        function runCrossValidation(Model,DataFileName, ...
                LinkedSpecies,ConditionsGlobal,ConditionsReplicas, ...
                modelLibrary, pipeline, pipelineArgs, stateSpace, useCluster)
            % This method will create and launch background jobs (or
            % cluster jobs) to conduct fits (or other specified pipelines)
            % of the same model but on different data sets as specified in
            % 'ConditionsReplicas.
            arguments
                Model
                DataFileName
                LinkedSpecies
                ConditionsGlobal
                ConditionsReplicas
                modelLibrary
                pipeline = 'fittingPipelineExample';
                pipelineArgs = struct('maxIter',1000,'display','iter','makePlot',0);
                stateSpace  = [];
                useCluster = false;
            end

            nPars = size(Model.parameters,1);
            SMM = SSITMultiModel.createCrossValMultiModel(Model,DataFileName, ...
                LinkedSpecies,ConditionsGlobal,ConditionsReplicas, ...
                zeros(1,nPars), stateSpace);

            nRepSets = length(ConditionsReplicas);

            % Split Up and Save Models
            for i = 1:nRepSets
                eval(['Model_',num2str(i),'=SMM.SSITModels{i};'])
            end
            save(modelLibrary,'Model_*');

            % Launch background jobs to fit each model.
            for i = 1:nRepSets
                modelName = ['Model_',num2str(i)];
                saveFile2 = [modelLibrary,'_',num2str(i)];
                logfile = ['logFile',num2str(i),'.txt'];
                SSIT.generateCommandLinePipeline(modelLibrary,modelName,[],pipeline,pipelineArgs,saveFile2,logfile,1,useCluster);
            end
        end
    end
end
