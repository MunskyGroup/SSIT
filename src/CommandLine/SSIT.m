classdef SSIT
    %% Create an instance of the SSIT class, example:  Model = SSIT;
    %
    % The SSIT allows users to specify and efficiently solve the chemical
    % master equation for discrete stochastic models.  SSIT is especially
    % useful for the analysis of single-cell gene regulaton. Functionality
    % includes:
    %   * Build, save, and load models defined by their species, parameters,
    %     propensity functions, stoichiometries, and initial conditions
    %       ** Models can be non-linear and have time-varying propensity
    %          functions (e.g., inputs), including logical statements
    %   * Load from / export to SimBiology
    %   * Load from / export to SBML
    %   * Solve models using:
    %       ** ODE analyses and basic moment closure analyses
    %       ** Stochastic trajectories generated by Gillepsie's
    %          Stochastic Simulation Algorithm (SSA)
    %       ** Finite State Projection (FSP)
    %       ** Hybrid solutions (deterministically + stochastically treated
    %          species population changes through time)
    %       ** Reduced order models (Model Reduction) by:
    %           *** Reduce models using Quasi-Steady State Approximations
    %               (QSSA) on fast species
    %           *** Reduce models using eigenvalue decomposition
    %           *** Reduce models using coarse meshes
    %           *** Reduce models using principle orthogonal decomposition
    %       ** SSITMultiModel to create multiple models associated with
    %          different data sets with shared parameter sets
    %   * Generate synthetic data from models using SSA
    %   * Compute sensitivity of solutions to parameter variations
    %   * Compute the Fisher Information Matrix to determine the amount of
    %     parameter information available from the chosen experiment
    %   * Compute first passage or escape time distributions for complex
    %     trajectories
    %   * Load and fit experimental data (e.g., spot counts or total
    %     intensity measurements from smFISH images or flow cytometry)
    %   * Compute the likelihood of the data given model
    %   * Maximize the likelihood using gradient and non-gradient based
    %     searches
    %   * Sample parameter uncertainty using the Metropolis-Hastings
    %     algorithm (with custom proposal distributions or
    %     proposal distributions based on Fisher Information)
    %   * Include custom priors on parameter distributions for Bayesian
    %     analysis
    %   * Model and account for experimental, measurement, and data
    %     processing noise
    %       ** Explore effects of extrinsic noise in parameters
    %       ** Calibrate empirical probability distortion operators (PDO)
    %          to quantify effects of data distortion
    %       ** Include data distortion corrections in parameter estimation
    %   * Inform and improve upon iterative experiment designs by searching
    %     an experiment design space for optimally informative experiments
    %       ** Utilize the FSP-FIM approach to compare the amount of
    %          information gainable by each potential next experiment
    %       ** Analyze possible next experiments using Bayesian sequential
    %          experiment design
    %       ** Automatically adjust designs to account for data distortion
    %          effects (allowing for informative cheaper, faster
    %          experiments)
    %   * Identify parameters that change with
    %     genetic / environmental / experimental conditions

    properties
        % List of parameters and their values, default: {'k',10; 'g',0.2};
        parameters = {'k',10; 'g',0.2};
        % List of species to be used in model, default: {'x1'};
        species = {'x1'};
        % Matrix of stoichiometric updates applied to each species given
        % each reaction, with species as rows and reactions as columns
        %   default: [1,-1];
        %   example: Model.stoichiometry = [-1,1,0,0;...
        %                                    1,-1,0,0;...
        %                                    0,0,1,-1];
        stoichiometry = [1,-1];
        % List of propensity functions, default: {'k'; 'g*x1'}
        propensityFunctions = {'k'; 'g*x1'}
        % List of time-varying input signals
        %   default: {};
        %   example:  Model.inputExpressions = ...
        %             {'Drug','(a0+a1*exp(-r1*t)*(1-exp(-r2*t))*(t>0))'};
        inputExpressions = {};
        % Struct containing user-supplied constraint functions for FSP
        %   default: {};
        %   example: Model.customConstraintFuns = {'offGene+onGene'};
        customConstraintFuns = {};
        % Options for FSP solver
        %    defaults:
        %       'fspTol',0.001
        %       'fspIntegratorRelTol',1e-2
        %       'fspIntegratorAbsTol',1e-4
        %       'odeSolver','auto'
        %       'verbose',false
        %       'bounds',[]
        %       'usePiecewiseFSP',false
        %       'initApproxSS',false
        %       'escapeSinks',[]
        %       'constantJacobian',false
        %       'constantJacobianTime',1.1
        fspOptions = struct('fspTol',0.001,'fspIntegratorRelTol',1e-2,...
            'fspIntegratorAbsTol',1e-4, 'odeSolver','auto',...
            'verbose',false,'bounds',[],'usePiecewiseFSP',false,...
            'initApproxSS',false,'escapeSinks',[],...
            'constantJacobian',false,'constantJacobianTime',1.1,'stateSpace',[]);
        % Options for FSP-Sensitivity solver
        %   defaults:
        %       'solutionMethod','forward'
        %       'useParallel',true
        %   example: Model.sensOptions.solutionMethod = 'finiteDifference';
        sensOptions = struct('solutionMethod','forward',...
            'useParallel',true);
        % Options for SSA solver
        %   defaults:
        %       'Nexp',1
        %       'nSimsPerExpt',100
        %       'useTimeVar',false
        %       'signalUpdateRate',[]
        %       'llel',false
        %       'verbose',false
        ssaOptions = struct('Nexp',1,'nSimsPerExpt',100,...
            'useTimeVar',false,'signalUpdateRate',[],...
            'useParallel',false,'verbose',false,...
            'useGPU',false);
        % Options for PDO
        %   defaults:
        %       'unobservedSpecies',[]
        %       'PDO',[]
        pdoOptions = struct('unobservedSpecies',[],'PDO',[]);
        % Options for FIM analyses
        %   defaults:
        %       'modelVarsToFit','all'
        %       'pdoVarsToFit',[]
        %       'timesToFit','all'
        %       'logPrior',[]
        %       'logPriorCovariance',[]
        %       'priorCovariance',[]
        fittingOptions = struct('modelVarsToFit','all',...
            'pdoVarsToFit',[],'timesToFit','all','logPrior',[],...
            'logPriorCovariance',[],'priorCovariance',[])
        % Initial population size of each species, default: [0];
        initialCondition = [0];
        % Probability mass of states given in initialCondition, default: 1
        initialProbs = 1;
        % Initial time, default: 0;
        initialTime = 0;
        % Times at which to find solutions, default: linspace(0,10,21);
        tSpan = linspace(0,10,21);
        % Chosen solution scheme ('FSP','SSA','ode'), default: 'FSP'
        solutionScheme = 'FSP'
        % Chosen sets of solution schemes to get and store (choose members
        % from ('FSP','SSA','ode').  Default is empty.
        odeIntegrator = 'ode23s'
        % Chosen integrator for ODEs {'ode23s' (default), 'ode15s', 'ode45'}.
        solutionSchemes = {};
        % Settings for model reduction tools
        %   defaults:
        %       'useModReduction',false
        %       'reductionType','None'
        modelReductionOptions = struct('useModReduction',false,...
            'reductionType','None')
        % Set data, default: [];
        dataSet = [];
        % Option to use hybrid model (deterministic + stochastic species)
        %   default: false
        useHybrid = false
        % Struct to define which species of the hybrid model will be
        % modelled using ODEs
        %   default: struct('upstreamODEs',[]);
        %   example: Model.hybridOptions.upstreamODEs = {'offGene','onGene'};
        hybridOptions = struct('upstreamODEs',[]);
        % Processed propensity functions for use in SSIt/FSP solvers,
        % default: [];
        propensitiesGeneral = [];
        % Processed propensity functions for use in ODE solver,
        % default: [];
        propensitiesGeneralODE = [];

        % Solutions
        Solutions = []; % Field holding solutions for current model and
        %                 parameter combinations

        % Model description
        description = {'Add model description here'};
        GUIProps = [];  % Structure to hold GUI information for faster loading and saving.
    end

    properties (Dependent)
        fspConstraints % FSP Constraint Functions
        pars_container % Container for parameters
    end

    methods
        function [obj,MultiModelObj] = SSIT(modelFile,modelName,dataSettings,pipeline,pipelineArgs,saveName)
            %% SSIT - Create an instance of the SSIT class.
            %
            % The SSIT purpose is to allow users to specify and efficiently
            % solve the chemical master equation for discrete stochastic
            % models.
            %
            % SSIT models can be generated through several options
            % depending on content of input 'modelFile'.
            %
            %% Inputs:
            %%   modelFile (string, optional) -- Create from saved file or
            %      from specified template.
            %      {'[NAME].mat',   % Load SSIT Model from file [NAME].mat
            %       'BirthDeath',    % 1 species pre-formatted example (default)
            %       'CentralDogma',  % 2 species pre-formatted example
            %       'ToggleSwitch',  % 2 species pre-formatted example
            %       'Repressilator', % 3 species pre-formatted example
            %       'BurstingSpatialCentralDogma'}  % 4 species pre-formatted example
            %
            %%   modelName (string, optional) -- Name of model within
            %       modelFile. This is needed in cases where the modelFile
            %       .mat contains multiple variables.
            %
            %%   dataSettings (Cell array, optional) -- Settings for loading data
            %       This is a cell array. For SSIT models, this will should
            %       be a {1x3} cell with the structure:
            %       dataSettings = {dataFileName,linkedSpecies,conditions}.
            %       See method 'SSIT.loadData' for interpretation of these
            %       inputs.
            %       For MultiModels, there should be one row of these
            %       variables for each of the sub-models.
            %
            %%   pipeline (string, optional) -- Name of an executable matlab
            %       function that will be run to analyse the created model.
            %       The arguments of the function are (Model, ARGS), where
            %       ARGS is a cell structure containing all remaining
            %       arguments expected by the function.
            %
            %%   pipelineArgs (Struct, optional) --
            %       Structure containing any optional arguments needed for
            %       the pipeline to run.
            %
            %%   saveName - (String, optional) -- name of file to save results
            %       of pipeline.
            %
            %% Example Usage:
            %% Example 1 - Pre-formatted model for central dogma:
            %   Mod = SSIT('CentralDogma'); % Load preset model for
            %                               % transcription and translation
            %
            %% Example 2 - Load existing model 'ExampleSSITModel.mat':
            %   Mod = SSIT('preGeneratedModels/savedRepressilatorModel');
            %      % Load saved model.
            %
            %% Example 3 - Load Model and Add Data
            %   Mod = SSIT('BirthDeath',[],{'data/STL1.csv',{'mRNA','rna'}})
            %      % Load preset model 'CentralDogma' and associate the
            %
            %% Example 4 - Load Model, Add Data and Run Pipeline Routine
            %   DataSettings = {'data/STL1.csv',{'mRNA','rna'}};
            %   Pipeline = 'fittingPipelineExample';
            %   pipelineArgs.maxIter = 20;
            %   pipelineArgs.display = 'iter';
            %   saveFile = 'exampleResults.mat';
            %
            %   % Create model from preset, associate with data, run
            %   % 'fittingPipeline', and save result.
            %   SSIT('BirthDeath','Model',DataSettings,Pipeline,pipelineArgs,saveFile);
            %
            %   % Load model from file, run 'fittingPipeline', and save result.
            %   SSIT(saveFile,'Model',[],Pipeline,pipelineArgs,saveFile);

            arguments
                modelFile = []   % Name of file where SSIT Model/MultiModel has been saved. Must be a '.mat'.
                modelName = []   % Name of the SSIT Model/MultiModel within the above file.
                dataSettings = {}% Data Settings to load into Model/MultiModel.
                pipeline = []    % Pipeline (matlab script) to run on model.
                pipelineArgs = []% Pipeline arguments (matlab structure).
                saveName = []    % File name to save model after it has been generated.
            end

            % SSIT Construct an instance of the SSIT class
            addpath(genpath('../src'));
            if ~isempty(modelFile)
                if length(modelFile)>4 && (strcmp(modelFile(end-3:end),'.mat')||exist([modelFile,'.mat'],"file"))
                    % Load existing model from .mat file.
                    try
                        if ~isempty(modelName)
                            TMP = load(modelFile,modelName);
                            if isa(TMP.(modelName),'SSIT')
                                obj = TMP.(modelName);
                                disp(['Successfully loaded SSIT Model ',modelName])
                            elseif isa(TMP.(modelName),'SSITMultiModel')
                                MultiModelObj = TMP.(modelName);
                                obj = MultiModelObj.SSITModels{1};
                                disp(['Successfully loaded a CombinedModel ',modelName, ' and extracted first model.'])
                            end
                        else
                            TMP = load(modelFile);
                            fnames = fieldnames(TMP);
                            for i=1:length(fnames)
                                if isa(TMP.(fnames{i}),'SSIT')
                                    obj = TMP.(fnames{i});
                                    disp(['Successfully loaded SSIT Model named "',fnames{i},'" from "',modelFile,'"'])
                                    modelName = fnames{i};
                                    break
                                elseif isa(TMP.(fnames(i)),'SSITMultiModel')
                                    MultiModelObj = TMP.(fnames{i});
                                    obj = MultiModelObj.SSITModels{1};
                                    disp(['Successfully loaded a CombinedModel  named "',fnames{i},'" and extracted first model.'])
                                    modelName = fnames{i};
                                    break
                                end
                            end
                        end
                    catch
                        disp(['Could not load model from ',modelFile])
                        disp('Check that file exists and that it contains only the SSIT model of interest')
                        disp('Use the optional argument "modelName" to specify which model to load.')
                    end

                    % Test to see if propensity functions are available. If
                    % not, create them.
                    if ~isempty(obj.propensitiesGeneral)
                        try
                            fieldsPropens2Test = {'timeDependentFactor','stateDependentFactor','jointDependentFactor','hybridFactor'};
                            for field = fieldsPropens2Test
                                if ~isempty(obj.propensitiesGeneral{1}.(field{1}))
                                    if ~isa(obj.propensitiesGeneral{1}.(field{1}),'function_handle')
                                        error('Missing Function')
                                    end
                                end
                                %
                                %     if nargin(obj.propensitiesGeneral{1}.(field{1}))==1
                                %         obj.propensitiesGeneral{1}.(field{1})(0);
                                %     elseif nargin(obj.propensitiesGeneral{1}.(field{1}))==2
                                %         obj.propensitiesGeneral{1}.(field{1})(0,0);
                                %     end
                                % end
                            end
                        catch
                            disp(['Propensity functions are missing -- regenerating now with name: ',modelName])
                            obj = obj.formPropensitiesGeneral(modelName);
                        end
                    end
                else
                    % Create model from template
                    obj = pregenModel(obj,modelFile);
                    if ~strcmp(modelFile,'Empty')
                        obj = obj.formPropensitiesGeneral(modelFile);
                    end
                end
            end

            % Load Data if provided
            if ~isempty(dataSettings)
                if size(dataSettings,2)<3
                    dataSettings{1,3} = {};
                end
                if exist('MultiModelObj','var')
                    nModels = length(MultiModelObj.SSITModels);
                    for iModel = 1:nModels
                        MultiModelObj.SSITModels{iModel} =  MultiModelObj.SSITModels{iModel}.loadData( ...
                            dataSettings{iModel,1},dataSettings{iModel,2},dataSettings{iModel,3});
                    end
                else
                    obj = obj.loadData(dataSettings{1,1},dataSettings{1,2},dataSettings{1,3});
                end

            end

            if ~isempty(pipeline)
                if strcmp(pipeline(end-1:end),'.m')
                    pipeline=pipeline(1:end-2);
                end
                fun = str2func(pipeline);
                if exist('MultiModelObj','var')
                    [outputs,MultiModelObj] = fun(MultiModelObj,pipelineArgs);
                    obj = MultiModelObj.SSITModels{1};
                else
                    [outputs,obj] = fun(obj,pipelineArgs);
                end
                disp(['Pipeline "',pipeline,'" run successfully.'])
            end

            if ~isempty(saveName)
                if exist('MultiModelObj','var')
                    if ~isempty(modelName)
                        eval([modelName,'=MultiModelObj;']);
                        save(saveName,"outputs",modelName)
                    else
                        save(saveName,"outputs",'MultiModelObj')
                    end
                    obj = MultiModelObj.SSITModels{1};
                else

                    if ~isempty(modelName)
                        eval([modelName,'=obj;']);
                        save(saveName,"outputs",modelName)
                    else
                        ModelObj = obj;
                        save(saveName,'outputs','ModelObj')
                    end
                end

                % if exist("combinedModel","var")
                %     outputs = executeRoutine(ModelObj);
                %     ModelObj=outputs.model;
                % eval([modelName,'=outputs.model.SSITModels{1};']);
                % /save(saveName,"outputs",modelName,'ModelObj')
                % else
                %     outputs = executeRoutine(obj);
                % eval([modelName,'=ModelObj;']);
                % save(saveName,"outputs",modelName)
                % end
            end

        end

        function Pars_container = get.pars_container(obj)
            if ~isempty(obj.parameters)
                Pars_container = containers.Map(obj.parameters(:,1), obj.parameters(:,2));
            else
                Pars_container =[];
            end
        end

        function obj = formPropensitiesGeneral(obj,prefixName,computeSens)
            %% SSIT.formPropensitiesGeneral - Create callable functions
            %% for all propensity functions.
            %
            % This function compiles and stores the given reaction
            % propensities into symbolic expression functions that use
            % sparse matrices to operate on the system based on the current
            % state. The functions are stored with the given prefix, e.g.,
            % 'Model_1'
            %
            % Inputs:
            %    * obj - SELF
            %    * prefixName - (string) the prefix name used to name the
            %                   saved propensity functions
            %                   default: 'default'
            %    * computeSens - (logical) indicates whether derivatives
            %                    are calculated for use in sensitivity
            %                    analysis
            %                    default: true
            %
            % Outputs: Model, callable symbolic expression functions
            %
            % Example: Model = Model.formPropensitiesGeneral('Model_1')
            arguments
                obj
                prefixName = 'default';
                computeSens = true;
            end
            % This function starts the process to write m-file for each
            % propensity function.

            n_reactions = length(obj.propensityFunctions);
            % Propensity for hybrid models will include
            % solutions from the upstream ODEs.
            sm = cell(1,n_reactions);
            logicTerms = cell(1,n_reactions);
            logCounter = 0;
            for i = 1:n_reactions
                st = obj.propensityFunctions{i};
                for jI = 1:size(obj.inputExpressions,1)
                    st = regexprep(st,['\<',obj.inputExpressions{jI,1},'\>'],['(',obj.inputExpressions{jI,2},')']);
                end
                [st,logicTerms{i},logCounter] = ssit.Propensity.stripLogicals(st,obj.species,logCounter);
                sm{i} = str2sym(st);
            end

            % if ~strcmp(obj.solutionScheme,'ode')||~ismember('ode',obj.solutionSchemes)
            if obj.useHybrid
                PropensitiesGeneral = ...
                    ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                    obj.parameters, obj.species, obj.hybridOptions.upstreamODEs,...
                    logicTerms, prefixName, computeSens);
            else
                PropensitiesGeneral = ...
                    ssit.Propensity.createAsHybridVec(sm, obj.stoichiometry,...
                    obj.parameters, obj.species, [], logicTerms, prefixName, computeSens);
            end
            % else
            %     PropensitiesGeneral = [];
            % end

            try
                objODE = obj;
                objODE.solutionScheme='ode';
                objODE.solutionSchemes = {};
                objODE.useHybrid = true;
                objODE.hybridOptions.upstreamODEs = obj.species;
                obj.propensitiesGeneralODE = ...
                    ssit.Propensity.createAsHybridVec(sm, objODE.stoichiometry,...
                    objODE.parameters, objODE.species, objODE.hybridOptions.upstreamODEs,...
                    logicTerms, [prefixName,'_ODE'], computeSens);
            catch
                disp('ODE propensities could not be formed, potentially due to logical values')
            end

            obj.propensitiesGeneral = PropensitiesGeneral;
        end
        %%
        function constraints = get.fspConstraints(obj)
            % Makes a list of FSP constraints that can be used by the FSP
            % solver.
            if obj.useHybrid
                stochasticSpecies = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                stochasticSpecies = obj.species;
            end

            nSpecies = length(stochasticSpecies);
            Data = cell(nSpecies*2,3);
            for i = 1:nSpecies
                Data(i,:) = {['-x',num2str(i)],'<',0};
                Data(nSpecies+i,:) = {['x',num2str(i)],'<',1};
            end

            % Add custom constraints into the FSP state space
            % determination.
            if ~isempty(obj.customConstraintFuns)
                [~,J] = sort(cellfun('length',stochasticSpecies),'descend');
                for i = 1:length(obj.customConstraintFuns)
                    constraintStr = SSIT.replaceSpeciesNames(obj.customConstraintFuns{i},stochasticSpecies);
                    Data(2*nSpecies+i,:) = {constraintStr,'<',1};
                end
            end
            constraints.f = readConstraintsForAdaptiveFsp([], stochasticSpecies, Data);
            if isempty(obj.fspOptions.bounds)||size(Data,1)~=length(obj.fspOptions.bounds)
                constraints.b = [Data{:,3}]';
                obj.fspOptions.bounds = constraints.b;
            else
                constraints.b = obj.fspOptions.bounds;
            end

            % Define polynomial constraints for first passage time sinks
            % (i.e., states corresponding to boundaries that we are trying
            % to calculate the escape times toward).
            if ~isempty(obj.fspOptions.escapeSinks)
                nEscape = length(obj.fspOptions.escapeSinks.f);
                escapeData = cell(nEscape,3);
                for i = 1:nEscape
                    constraintStr = SSIT.replaceSpeciesNames(obj.fspOptions.escapeSinks.f{i},obj.species);
                    escapeData(i,:) = {constraintStr,'<',1};
                end
                constraints.fEscape = readConstraintsForAdaptiveFsp([], stochasticSpecies, escapeData);
                constraints.bEscape = obj.fspOptions.escapeSinks.b;
            else
                constraints.fEscape = [];
                constraints.bEscape = [];
            end
        end

        function plotStatespace(obj,showPoints,showLines,pointMarker)
            % This function makes a plot of the FSP state space based on
            % the supplied constatint functions and the current bounds.
            % Plots are only made for 2D and 3D problems.
            %
            % Inputs:
            %   showPoints (true) -- show states as points in plots.
            %   showLines (true) -- show constraints as lines/surfaces in plots.
            %   pointMarker ('o') -- marker type ('o','+','x','s',etc) for
            %                       state points
            %
            % 3D Example:
            %   Model = SSIT('Repressilator');  % Load pre-made model.
            %   [~,~,Model] = Model.solve;      % Solve to get FSP projection
            %   RepGenes_Model.plotStatespace(true,true,'s'); % Make plot of FSP projection statespace.
            %
            % 2D Example:
            %   Model = SSIT('ToggleSwitch');  % Load pre-made model.
            %   [~,~,Model] = Model.solve;     % Solve to get FSP projection
            %   RepGenes_Model.plotStatespace(true,true,'s'); % Make plot of FSP projection statespace.

            arguments
                obj
                showPoints = true;
                showLines = true;
                pointMarker = 'o'
            end

            map = colormap(jet(length(obj.fspOptions.bounds)+1));

            switch length(obj.species)
                case 2
                    figure;
                    legs = {};
                    if isfield(obj.fspOptions,'stateSpace')&&showPoints
                        scatter(obj.fspOptions.stateSpace.states(1,:)',...
                            obj.fspOptions.stateSpace.states(2,:)',pointMarker);
                        hold on;
                        legs = {'FSP states'};
                    end
                    if showLines
                        fimplicit(@(x,y)(-x-obj.fspOptions.bounds(1)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(-y-obj.fspOptions.bounds(2)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(x-obj.fspOptions.bounds(3)),'linewidth',2);hold on;
                        fimplicit(@(x,y)(y-obj.fspOptions.bounds(4)),'linewidth',2);hold on;
                        legs = [legs,{[obj.species{1},'>=',num2str(-obj.fspOptions.bounds(1))]}];
                        legs = [legs,{[obj.species{2},'>=',num2str(-obj.fspOptions.bounds(2))]}];
                        legs = [legs,{[obj.species{1},'<=',num2str(obj.fspOptions.bounds(3))]}];
                        legs = [legs,{[obj.species{2},'<=',num2str(obj.fspOptions.bounds(4))]}];
                        for i = 1:length(obj.customConstraintFuns)
                            str = ['@(',obj.species{1},',',obj.species{2},')',obj.customConstraintFuns{i},'-',num2str(obj.fspOptions.bounds(4+i))];
                            fun = eval(str);
                            fimplicit(fun,'linewidth',2);hold on;
                            legs = [legs,{[obj.customConstraintFuns{i},'<=',num2str(obj.fspOptions.bounds(i+4))]}];
                        end
                    end
                    set(gca,'xlim',[obj.fspOptions.bounds(1)-1,obj.fspOptions.bounds(3)*1.1]);
                    set(gca,'ylim',[obj.fspOptions.bounds(2)-1,obj.fspOptions.bounds(4)*1.1]);
                    xlabel(obj.species{1});
                    ylabel(obj.species{2});
                    set(gca,'FontSize',16)
                    legend(legs)


                case 3
                    figure;
                    legs = {};
                    if isfield(obj.fspOptions,'stateSpace')&&showPoints
                        scatter3(obj.fspOptions.stateSpace.states(1,:)',...
                            obj.fspOptions.stateSpace.states(2,:)',...
                            obj.fspOptions.stateSpace.states(3,:)',pointMarker);
                        hold on;
                        legs = {'FSP states'};
                    end

                    if showLines
                        fimplicit3(@(x,y,z)(-x-obj.fspOptions.bounds(1)),'EdgeColor','none','FaceColor',map(2,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(-y-obj.fspOptions.bounds(2)),'EdgeColor','none','FaceColor',map(3,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(-z-obj.fspOptions.bounds(3)),'EdgeColor','none','FaceColor',map(4,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(x-obj.fspOptions.bounds(4)),'EdgeColor','none','FaceColor',map(5,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(y-obj.fspOptions.bounds(5)),'EdgeColor','none','FaceColor',map(6,:),'FaceAlpha',0.1);hold on;
                        fimplicit3(@(x,y,z)(z-obj.fspOptions.bounds(6)),'EdgeColor','none','FaceColor',map(7,:),'FaceAlpha',0.1);hold on;
                        legs = [legs,{[obj.species{1},'>=',num2str(-obj.fspOptions.bounds(1))]}];
                        legs = [legs,{[obj.species{2},'>=',num2str(-obj.fspOptions.bounds(2))]}];
                        legs = [legs,{[obj.species{3},'>=',num2str(-obj.fspOptions.bounds(3))]}];
                        legs = [legs,{[obj.species{1},'<=',num2str(obj.fspOptions.bounds(4))]}];
                        legs = [legs,{[obj.species{2},'<=',num2str(obj.fspOptions.bounds(5))]}];
                        legs = [legs,{[obj.species{3},'<=',num2str(obj.fspOptions.bounds(6))]}];
                        for i = 1:length(obj.customConstraintFuns)
                            str = ['@(',obj.species{1},',',obj.species{2},',',obj.species{3},')',obj.customConstraintFuns{i},'-',num2str(obj.fspOptions.bounds(6+i))];
                            fun = eval(str);
                            fimplicit3(fun,'EdgeColor','none','FaceColor',map(7+1,:),'FaceAlpha',0.1);hold on;
                            legs = [legs,{[obj.customConstraintFuns{i},'<=',num2str(obj.fspOptions.bounds(i+6))]}];
                        end
                    end
                    set(gca,'xlim',[obj.fspOptions.bounds(1),obj.fspOptions.bounds(4)*1.1]);
                    set(gca,'ylim',[obj.fspOptions.bounds(2),obj.fspOptions.bounds(5)*1.1]);
                    set(gca,'zlim',[obj.fspOptions.bounds(3),obj.fspOptions.bounds(6)*1.1]);
                    xlabel(obj.species{1});
                    ylabel(obj.species{2});
                    ylabel(obj.species{3});
                    set(gca,'FontSize',16)
                    legend(legs)

                otherwise
                    error('visualization of FSP StateSpace only supported 2D and 3D models.')
            end
        end
        %% Model Building Functions
        function [obj] = pregenModel(obj,modelFile)
            % pregenModel - creates a pregenerated model from a template:
            % Possible Templates include:
            %   Empty -- nothing
            %   BirthDeath -- one species 'mRNA' with birth rate 'k' and
            %       death rate 'g'
            %   CentralDogma -- Time varying 2-species model with:
            %       mRNA species 'rna' with birth rate 'kr*I(t)' and
            %       degradation rate 'gr'. Protein species 'protein' with
            %       translation rate 'kr' and degradation rate 'gp'.
            %   ToggleSwitch -- two proteins that prepress one another with
            %       non-linear functions.
            switch modelFile
                case 'Empty'
                    obj.parameters = {};
                    obj.species = {};
                    obj.stoichiometry = [];
                    obj.propensityFunctions = {};
                    obj.initialCondition = [];
                case 'BirthDeath'
                    obj.parameters = {'k',10;'g',0.2};
                    obj.species = {'mRNA'};
                    obj.stoichiometry = [1,-1];
                    obj.propensityFunctions = {'k';'g*mRNA'};
                    obj.initialCondition = [0];
                case 'CentralDogma'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1};
                    obj.species = {'rna';'protein'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*rna';'kp*rna';'gp*protein'};
                    obj.initialCondition = [0;0];
                case 'BurstingGene'
                    obj.parameters = {'kon',1;'koff',1;'kr',1;'gr',0.1};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kon*(1-geneState)';'koff*geneState';'kr*geneState';'gr*rna'};
                    obj.initialCondition = [0;0];
                case 'CentralDogmaTV'
                    obj.parameters = {'kr',10;'gr',1;'kp',1;'gp',0.1;'omega',2*pi/5};
                    obj.species = {'geneState';'rna'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kr';'gr*I1*geneState';'kp*geneState';'gp*rna'};
                    obj.initialCondition = [0;0];
                    obj.inputExpressions = {'I1','1+cos(omega*t)'};
                case 'ToggleSwitch'
                    obj.parameters = {'kb',10;'ka',80;'M',20;'g',1};
                    obj.species = {'LacI';'LamCI'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'kb+ka*M^3/(M^3+LamCI^3)';...
                        'g*LacI';...
                        'kb+ka*M^3/(M^3+LacI^3)';...
                        'g*LamCI'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(LacI-3).^2.*(LamCI-3).^2'};
                case 'ToggleSwitch2'
                    obj.parameters = {'ka1',4;'kb1',80;'kd1',1;'k1',20;...
                        'ka2',4;'kb2',80;'kd2',1;'k2',20;...
                        'ket',0.1;'ks',1;'kg',1};
                    obj.species = {'x1';'x2'};
                    obj.stoichiometry = [1,-1,0, 0;...
                        0, 0,1,-1];
                    obj.propensityFunctions = {'ket*(ka1+((kb1*(k1^3))/((k1^3)+(x2)^3)))';...
                        '(kd1+((ks*kg)/(1+ks)))*(x1)';...
                        'ket*(ka2+((kb2*(k2^3))/((k2^3)+(x1)^3)))';...
                        'kd2*(x2)'};
                    obj.initialCondition = [0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2'};
                case 'Repressilator'
                    obj.parameters = {'kn0',0;'kn1',25;'a',5;'n',6;'g',1};
                    obj.species = {'x1';'x2';'x3'};
                    obj.stoichiometry = [1,0,0,-1,0,0;...
                        0,1,0,0,-1,0;...
                        0,0,1,0,0,-1];
                    obj.propensityFunctions = {'kn0+kn1*(1/(1+a*(x2^n)))';...
                        'kn0+kn1*(1/(1+a*(x3^n)))';...
                        'kn0+kn1*(1/(1+a*(x1^n)))';...
                        'g*x1';...
                        'g*x2';...
                        'g*x3'};
                    obj.initialCondition = [30;0;0];
                    obj.customConstraintFuns = {'(x1-3).^2.*(x2-3).^2*(x3-3).^2'};

                case 'RepressilatorGenes'
                    obj.parameters = {'kn0',0;'kn1',25;'kb',2000;'ku',10;'g',1};
                    obj.species = {'x1';'x2';'x3';'x4';'x5';'x6';'x7';'x8';'x9'};
                    obj.stoichiometry = zeros(9,12);
                    obj.stoichiometry(1,1:2) = [-1 1];
                    obj.stoichiometry(2,1:2) = [1 -1];
                    obj.stoichiometry(6,1:2) = [-3 3];
                    obj.stoichiometry(3,3) =  1;
                    obj.stoichiometry(3,4) = -1;
                    obj.propensityFunctions(1:4) = {'kb*x1*x6*(x6-1)/2*(x6-2)/6';'ku*x2';'kn0*x2+kn1*x1';'g*x3'};
                    obj.stoichiometry(4,5:6) = [-1 1];
                    obj.stoichiometry(5,5:6) = [1 -1];
                    obj.stoichiometry(9,5:6) = [-3 3];
                    obj.stoichiometry(6,7) =  1;
                    obj.stoichiometry(6,8) = -1;
                    obj.propensityFunctions(5:8) = {'kb*x4*x9*(x9-1)/2*(x9-2)/6';'ku*x5';'kn0*x5+kn1*x4';'g*x6'};
                    obj.stoichiometry(7,9:10) = [-1 1];
                    obj.stoichiometry(8,9:10) = [1 -1];
                    obj.stoichiometry(3,9:10) = [-3 3];
                    obj.stoichiometry(9,11) =  1;
                    obj.stoichiometry(9,12) = -1;
                    obj.propensityFunctions(9:12) = {'kb*x7*x3*(x3-1)/2*(x3-2)/6';'ku*x8';'kn0*x8+kn1*x7';'g*x9'};
                    obj.initialCondition = [1;0;30;0;1;0;0;1;0];
                    obj.customConstraintFuns = {'(x3-3).^3.*(x6-3).^3.*(x9-3).^3'};

                case 'BurstingSpatialCentralDogma'
                    obj.parameters = {'kon',1;'koff',2;...
                        'kr',5;'grn',0.1;'kt',0.5;...
                        'grc',0.1;...
                        'kp',1;'gp',0.1};
                    obj.species = {'x1';'x2';'x3';'x4'};
                    obj.stoichiometry = [1,-1,0,0,0,0,0,0;...
                        0,0,1,-1,-1,0,0,0;...
                        0,0,0,0,1,-1,0,0;...
                        0,0,0,0,0,0,1,-1];
                    obj.propensityFunctions = {'kon*(1-x1)';'koff*x1';...
                        'kr*x1';'grn*x2';'kt*x2';...
                        'grc*x3';...
                        'kp*x3';'gp*x4'};
                    obj.initialCondition = [0;0;0;0];
                    obj.customConstraintFuns = {};

            end
            obj.propensitiesGeneral = [];
        end

        function [obj] = createModelFromSBML(obj,sbmlFile,scaleVolume)
            arguments
                obj
                sbmlFile
                scaleVolume = false
            end
            % This function allows one to create a model directly from an
            % SBML file.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSBML('../SBML_test_cases/00010/00010-sbml-l1v2.xml');
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            sbmlobj = sbmlimport(sbmlFile);
            [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume);
            obj.propensitiesGeneral = [];

        end

        function [obj] = createModelFromSimBiol(obj,sbmlobj,scaleVolume)
            % This function allows one to create a model directly from an
            % simBiology object.
            % Example:
            %      Model = SSIT();
            %      Model = Model.createModelFromSimBiol(sbmlobj);
            %      [fspSoln] = Model.solve;
            %      Model.makePlot(fspSoln,'meansAndDevs')
            arguments
                obj
                sbmlobj
                scaleVolume = false
            end
            nR = length(sbmlobj.Reactions);
            nS = length(sbmlobj.Species);

            % Extract species names and stoichiometry
            [obj.stoichiometry, obj.species] = getstoichmatrix(sbmlobj);

            % Extract parameter names
            nP = length(sbmlobj.Parameter);
            obj.parameters = {};
            for i = 1:nP
                obj.parameters{i,1} = sbmlobj.Parameter(i).Name;
                obj.parameters{i,2} = sbmlobj.Parameter(i).Value;
            end

            if length(sbmlobj.Compartments)>1
                error('SSIT Tools not yet set up to support multi-compartment models.')
            end

            obj.propensityFunctions={};
            for i = 1:nR
                reactRate = sbmlobj.Reactions(i).ReactionRate;
                reactRate = strrep(reactRate,'compartment*','');
                if contains(reactRate,'time')
                    % obj.propensityFunctions{i,1} = strrep(reactRate,'time','Ig');
                    obj.propensityFunctions{i,1} = regexprep(reactRate,'\<time\>','Ig');
                    obj.inputExpressions = {'Ig','t'};
                else
                    obj.propensityFunctions{i,1} = reactRate;
                end

            end

            if scaleVolume
                % Replace species numbers (Xi) with concentrations (Xi/Volume).
                for i = 1:nR
                    for j = 1:nS
                        % obj.propensityFunctions{i,1} = strrep(obj.propensityFunctions{i,1},...
                        %     obj.species{j},['(',obj.species{j},'/Volume)']);
                        obj.propensityFunctions{i,1} = regexprep(obj.propensityFunctions{i,1},...
                            ['\<',obj.species{j},'\>'],['(',obj.species{j},'/Volume)']);

                    end
                    obj.propensityFunctions{i,1} = [obj.propensityFunctions{i,1},'*Volume'];
                end

                % Scale Initial Condition and Volume to remove fractional
                % concentrations.
                frac = false;
                scl = 0;
                for i = 1:nS
                    if rem(sbmlobj.Species(i).Value,1)~=0
                        frac = true;
                    end
                    scl = max(scl,sbmlobj.Species(i).Value);
                end
                if frac
                    scl = round(100/scl);
                    disp(['Fractional species values detected.  Scaling by Vol=',num2str(scl),' and rounding.'])
                    disp(' ')
                    IC(1:nS,1) = round(scl*[sbmlobj.Species.Value]);
                end
                obj.parameters(end+1,:) = {'Volume',scl};
            else
                IC(1:nS,1) = [sbmlobj.Species.Value];
            end
            obj.initialCondition = IC;
            obj.summarizeModel;
            obj.propensitiesGeneral = [];

        end

        function exportToSBML(obj,modelName)
            % This function exports the model to an SBML file called
            % <modelName>.
            arguments
                obj
                modelName
            end
            sbModel = exportSimBiol(obj);
            sbmlexport(sbModel, modelName)
        end

        function sbModel = exportSimBiol(obj,verifyAndPlot)
            % This function converts the model to a simple simbiology model
            % and returns that simbiology object.
            % Arguments:
            %   verifyAndPlot (true/false0) -- option to verify the model
            %       and run simBiology to make a plot of its results.
            %
            % Outputs:
            %   smModel -- the resulting simBiology model.
            arguments
                obj
                verifyAndPlot = false;
            end

            sbModel = sbiomodel('simpleModel');

            s = cell(1,length(obj.species));
            for is = 1:size(obj.stoichiometry,1)
                s{is} = addspecies(sbModel,obj.species{is},obj.initialCondition(is));
            end

            for is = 1:size(obj.parameters,1)
                p{is} = addparameter(sbModel,obj.parameters{is,1},obj.parameters{is,2});
            end

            % Parse time varying components in the reaction rate equations.
            props = obj.propensityFunctions;
            for is = 1:size(obj.inputExpressions,1)
                % tvComp = strrep(obj.inputExpressions{is,2},'t','time');
                tvComp = regexprep(obj.inputExpressions{is,2},'\<t\>','time');
                for ir = 1:length(props)
                    % props{ir} = strrep(props{ir},obj.inputExpressions{is,1},['(',tvComp,')']);
                    props{ir} = regexprep(props{ir},['\<',obj.inputExpressions{is,1},'\>'],['(',tvComp,')']);
                end
            end

            for ir=1:size(obj.stoichiometry,2)
                strReactants = [];
                strProducts =  [];
                for is = 1:size(obj.stoichiometry,1)
                    if obj.stoichiometry(is,ir)<0
                        strReactants =[strReactants,'+ ',[num2str(-obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    elseif obj.stoichiometry(is,ir)>0
                        strProducts =[strProducts,'+ ',[num2str(obj.stoichiometry(is,ir))],' ',obj.species{is}];
                    end
                end
                if isempty(strProducts); strProducts = '  null '; end
                if isempty(strReactants); strReactants = '  null '; end
                rxn = [strReactants(3:end),' -> ',strProducts(3:end)];
                RXN{is} = addreaction(sbModel,rxn,'ReactionRate',props{ir});
            end

            if verifyAndPlot
                verify(sbModel)
                csObj = getconfigset(sbModel,'active');
                set(csObj,'Stoptime',max(obj.tSpan));
                [t,x,names] = sbiosimulate(sbModel);
                plot(t,x);
                xlabel('Time');
                ylabel('Amount');
                legend(names);
            end
        end

        function [obj] = addSpecies(obj,newSpecies,initialCond)
            % addSpecies - add new species to reaction model.
            % example:
            %     F = SSIT;
            %     F = F.addSpecies('x2');
            arguments
                obj
                newSpecies
                initialCond = [];
            end
            obj.species =  [obj.species;newSpecies];
            obj.stoichiometry(end+1,:) = 0;
            if isempty(initialCond)
                initialCond = zeros(size(newSpecies,1),1);
            end
            obj.initialCondition = [obj.initialCondition;initialCond];
            obj.propensitiesGeneral = [];

        end

        function [obj] = addParameter(obj,newParameters)
            % addParameter - add new parameter to reaction model
            % example:
            %     F = SSIT;
            %     F = F.addParameter({'kr',0.1})
            obj.parameters =  [obj.parameters;newParameters];
        end

        function [obj] = addReaction(obj,newRxn,confirm)
            arguments
                obj
                newRxn
                confirm = false
            end

            % addParameter - add new reaction to reaction model
            % example:
            % F = SSIT('Empty')
            % newRxn(1).propensity = 'kr + kr1*x1';
            % newRxn(1).stoichiometry = {'x1',1};
            % newRxn(1).parameters = {'kr',2;'kr1',0.01};
            % newRxn(2).propensity = 'g*x1';
            % newRxn(2).stoichiometry = {'x1',-1};
            % newRxn(2).parameters = {'g',0.1};
            % F = F.addReaction(newRxn);
            for iRxn = 1:length(newRxn)
                obj.propensityFunctions =  [obj.propensityFunctions;newRxn(iRxn).propensity];
                rxnNum = size(obj.stoichiometry,2)+1;
                for iSpe = 1:size(newRxn(iRxn).stoichiometry,1)
                    specName = newRxn(iRxn).stoichiometry{iSpe,1};
                    specChange = newRxn(iRxn).stoichiometry{iSpe,2};
                    specNum = find(strcmp(obj.species,specName));
                    if isempty(specNum)
                        disp(['Adding species ',specName,' with initial condition 0.'])
                        obj = obj.addSpecies(specName,0);
                        specNum = length(obj.species);
                    end
                    obj.stoichiometry(specNum,rxnNum) = specChange;
                end
                for iPar = 1:size(newRxn(iRxn).parameters,1)
                    parName = newRxn(iRxn).parameters{iPar,1};
                    parValue = newRxn(iRxn).parameters{iPar,2};
                    if ~isempty(obj.parameters)
                        parNum = find(strcmp(obj.parameters(:,1),parName));
                    else
                        parNum=[];
                    end
                    if isempty(parNum)
                        disp(['Adding parameter ',parName,' with value ',num2str(parValue)]);
                        obj = obj.addParameter({parName,parValue});
                    else
                        disp(['Updating parameter ',parName,' to new value ',num2str(parValue)]);
                        obj.parameters{parNum,2} = parValue;
                    end
                end
            end
            obj.propensitiesGeneral = [];
        end

        function [obj] = removeReaction(obj,numRxn,confirm)
            % Removes a reaction from propensity functions and
            % stoichiometry matrix.
            arguments
                obj
                numRxn
                confirm = false
            end
            inds = ones(1,length(obj.propensityFunctions),'logical');
            inds(numRxn) = false;
            obj.stoichiometry = obj.stoichiometry(:,inds);
            obj.propensityFunctions = obj.propensityFunctions(inds);
        end
        function [obj] = calibratePDO(obj,dataFileName,measuredSpecies,...
                trueColumns,measuredColumns,pdoType,showPlot,parGuess)
            %% SSIT.calibratePDO - This function calibrates a probabilistic
            %% distortion operator (PDO) to match 'true' and 'observed'
            %% (distorted) spot numbers.  Note: it also calls generatePDO()
            %
            % Calibrate the PDO from empirical data, for example, the
            % number of spots that have been measured using different
            % assays in data columns 'nTotal' for the 'true' data set and
            % in the columns 'nSpots0' for a different label, or in columns
            % 'intens1' for the integrated fluorescent intensity.
            %
            % Inputs:
            %   * obj
            %   * dataFileName - (string), name of the data file
            %   * measuredSpecies - (string), name of the model species
            %   * trueColumns - (string), name of the 'true' data for the
            %                    model species
            %   * measuredColumns - (string), name of the 'observed', or
            %                        distorted, data for the model species
            %   * pdoType - (string), the type of distribution that
            %                represents the type
            %       default: 'AffinePoiss'
            %   * showPlot - (logical), default: false
            %   * parGuess - (double), guesses for the hyperparameter
            %                 values, i.e., the parameters that define the
            %                 PDO distribution (not to be confused with the
            %                 model parameters)
            %       default: [];
            %
            % Outputs:
            %
            % Example:
            % Model_PDO = Model.calibratePDO('/data/pdoData.csv',...
            % {'rna'},{'nTotal'},{'nSpots0'},'AffinePoiss',true);
            %
            % The 'AffinePoiss' PDO models the obervation probability with
            % a Poisson distribution, where the mean value is affine
            % linearly related to the true value: P(y|x) = Poiss(a0 + a1*x);
            arguments
                obj
                dataFileName
                measuredSpecies
                trueColumns
                measuredColumns
                pdoType = 'AffinePoiss'
                showPlot = false
                parGuess=[];
            end

            obj.pdoOptions.type = pdoType;
            % app.DistortionTypeDropDown.Value = obj.pdoOptions.type;
            % app.FIMTabOutputs.PDOProperties.props = obj.pdoOptions.props;

            Tab = readtable(dataFileName);

            % Convert float values in trueColumns and measuredColumns
            Tab.(trueColumns{1}) = double(int64(Tab.(trueColumns{1})));
            Tab.(measuredColumns{1}) = double(int64(Tab.(measuredColumns{1})));

            dataNames = Tab.Properties.VariableNames;

            % Check that the data column being asked for actually exists in the file and throw an error if not.
            % TODO - make this type of check accessible to all of SSIT, not just calibratePDO
            present = any(cellfun(@(y) strcmp(y, measuredColumns{1}),dataNames));
            if ~present
                error(measuredColumns + " does not exist in the data file.");
            end

            DATA = table2cell(Tab);

            if isempty(parGuess)
                lambdaTemplate = obj.findPdoError(pdoType);
            else
                lambdaTemplate=parGuess;
            end

            lambda = [];

            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end

            maxSize = zeros(1,length(speciesStochastic));
            options = optimset('display','none');
            for i=1:length(speciesStochastic)
                if sum(strcmp(measuredSpecies,speciesStochastic{i}))==1
                    k = find(strcmp(measuredSpecies,speciesStochastic{i}));
                    jTrue = find(strcmp(dataNames,trueColumns{k}));
                    jObsv = find(strcmp(dataNames,measuredColumns{k}));
                    xTrue = [DATA{:,jTrue}]';
                    xObsv = [DATA{:,jObsv}]';
                    maxSize(i)=max(xTrue);
                    objPDO = @(x)-obj.findPdoError(pdoType,x,xTrue,xObsv);
                    lambdaNew = fminsearch(objPDO,lambdaTemplate,options);
                    if showPlot
                        [~,PDO] = obj.findPdoError(pdoType,lambdaNew,xTrue,xObsv);
                        Z = max(-25,log10(PDO));
                        fg = figure; set(0,'CurrentFigure',fg);
                        contourf([0:size(PDO,2)-1],[0:size(PDO,1)-1],Z);
                        colorbar
                        hold on
                        scatter(xTrue,xObsv,100,'sk','filled')
                        set(gca,'fontsize',15)
                        legend('PDO','Data')
                    end
                else
                    maxSize(i)=0;
                    lambdaNew = 0*lambdaTemplate;
                end
                lambda = [lambda,lambdaNew];
            end
            obj.pdoOptions.props.PDOpars = lambda;
            obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,lambda,[],[],maxSize);
        end

        function obj = setICfromFspVector(obj,stateSpace,fspVector)
            % This function converts an FSP vector to initial states
            % and initial probabilities.
            nSpecies = length(obj.species);
            nStates = size(fspVector.p.data.subs,1);
            if obj.useHybrid
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
                nUpstream = length(obj.hybridOptions.upstreamODEs);
                upStreamInit = [fspVector.upstreamODEs,zeros(nUpstream,nStates-1)];
            elseif ~isempty(fspVector.upstreamODEs)
                upStreamInit = repmat(fspVector.upstreamODEs,1,nStates);
                jStochastic = find(~contains(obj.species,obj.hybridOptions.upstreamODEs));
                jUpstreamODE = find(contains(obj.species,obj.hybridOptions.upstreamODEs));
            else
                upStreamInit = [];
                jStochastic = [1:nSpecies];
                jUpstreamODE = [];
            end

            obj.initialCondition = zeros(nSpecies,nStates);
            obj.initialCondition(jStochastic,:) = fspVector.p.data.subs'-1;
            obj.initialCondition(jUpstreamODE,:) = upStreamInit;
            obj.initialProbs = zeros(nStates,1);
            obj.initialProbs = max(0,real(fspVector.p.data.vals));

        end

        function [pdo] = generatePDO(obj,pdoOptions,paramsPDO,fspSoln,variablePDO,maxSize)
            %% SSIT.generatePDO - This function generates the Probabilistic
            %% Distortion Operator (PDO) according to user choice.
            %
            % Inputs:
            %   * app
            %   * paramsPDO - ()
            %   * FSPoutputs - ()
            %   * indsObserved - ()
            %   * variablePDO - (logical), default: false
            %   * maxSize - ()
            %
            % Output:
            %
            % Example:
            arguments
                obj
                pdoOptions
                paramsPDO = []
                fspSoln = []
                variablePDO =[]
                maxSize=[];
            end
            app.DistortionTypeDropDown.Value = pdoOptions.type;
            app.FIMTabOutputs.PDOProperties.props = pdoOptions.props;

            % Separate into observed and unobserved species.
            if isfield(obj.hybridOptions,'upstreamODEs')
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end
            Nd = length(speciesStochastic);

            indsUnobserved=[];
            indsObserved=[];
            for i=1:Nd
                if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                    indsUnobserved=[indsUnobserved,i];
                else
                    indsObserved=[indsObserved,i];
                end
            end
            [~,pdo] = ssit.pdo.generatePDO(app,paramsPDO,fspSoln,indsObserved,variablePDO,maxSize);
        end

        function [logL,P] = findPdoError(obj,pdoType,lambda,True,Distorted)
            % This function calculates the likelihood of observed data
            % given true data and an assumed PDO model.
            arguments
                obj
                pdoType = 'AffinePoiss';
                lambda = [];
                True = [];
                Distorted =[];
            end

            if nargin<=2
                switch pdoType
                    case 'LinPoiss'
                        logL = [0.1, 1];
                    case 'AffinePoiss'
                        logL = [1 5 0.5];
                    case 'QuadPoiss'
                        logL = [1 5 0.5];
                end
                return
            end

            % Computes likelihood of observed data given the model of affine poisson
            % extra spot counting and probability of measurmeent failure.
            NmaxTrue = max(True);
            NmaxObs = max(Distorted);

            switch pdoType
                case 'LinPoiss'
                    Np = ceil(max(NmaxObs,lambda(1)+lambda(2)*NmaxTrue));
                case 'AffinePoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue));
                case 'QuadPoiss'
                    Np = ceil(max(NmaxObs,lambda(2)+lambda(3)*NmaxTrue+lambda(4)*NmaxTrue^2));
            end
            P = zeros(Np+1,NmaxTrue+1);

            for xi = 0:NmaxTrue
                switch pdoType
                    case 'LinPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)*xi));
                    case 'AffinePoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi));
                    case 'QuadPoiss'
                        P(1:Np+1,xi+1) = pdf('poiss',[0:Np]',max(lambda(1),lambda(2)+lambda(3)*xi+lambda(4)*xi^2));
                end
            end

            % compute likelihood of observed given true
            logP = max(log(P),-100);
            logL = 0;
            for i = 1:length(True)
                logL = logL + logP(Distorted(i)+1,True(i)+1);
            end

            % apply constraints
            switch pdoType
                case 'LinPoiss'
                    logL = logL-1e4*(lambda(1)<0);
                case 'AffinePoiss'
                    logL = logL-1e4*(lambda(1)<0);
            end
        end

        function summarizeModel(obj)
            %% SSIT.summarizeModel - Prints a summary of an SSIT model:
            %% Species, Reactions (with Stoichiometric updates),
            %% Model Parameters
            %
            % Input:  SSIT model
            %
            % Output:  Summary text to screen
            %
            % Example:  Model.summarizeModel
            arguments
                obj;
            end
            % Show the model species
            nS = size(obj.stoichiometry,1);
            disp('Species:')
            for i = 1:nS
                if ~isempty(obj.hybridOptions.upstreamODEs)&&max(contains(obj.hybridOptions.upstreamODEs,obj.species{i}))
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  upstream ODE']);
                else
                    disp(['     ',obj.species{i},'; IC = ',num2str(obj.initialCondition(i)),';  discrete stochastic']);
                end
            end
            disp(' ')

            % Show the model stoichiometries and propensity functions
            disp('Reactions:')
            nR = size(obj.stoichiometry,2);
            for iR = 1:nR
                s = obj.stoichiometry(:,iR);
                disp(['  Reaction ',num2str(iR),':'])
                jReactant = find(s<0);
                jProd = find(s>0);
                if isempty(jReactant)
                    reactTxt = 'NULL';
                else
                    reactTxt = [num2str(-s(jReactant(1))),'*',obj.species{jReactant(1)}];
                    for i = 2:length(jReactant)
                        reactTxt = [reactTxt,' + ',num2str(-s(jReactant(i))),'*',obj.species{jReactant(i)}];
                    end
                end
                if isempty(jProd)
                    prodTxt = 'NULL';
                else
                    prodTxt = [num2str(s(jProd(1))),'*',obj.species{jProd(1)}];
                    for i = 2:length(jProd)
                        prodTxt = [prodTxt,' + ',num2str(s(jProd(i))),'*',obj.species{jProd(i)}];
                    end
                end
                disp(['     s',num2str(iR),': ',reactTxt, ' --> ', prodTxt])

                disp(['     w',num2str(iR),': ',obj.propensityFunctions{iR}])

            end

            if ~isempty(obj.inputExpressions)
                disp(' ')
                disp('Input Signals:')
                nI = size(obj.inputExpressions,1);
                for i = 1:nI
                    disp(['     ',obj.inputExpressions{i,1},'(t) = ',obj.inputExpressions{i,2}])
                end
            end

            disp(' ')
            disp('Model Parameters:')
            disp(obj.parameters)

        end

        %% Model Analysis Functions
        function obj = fspSolve(obj)
            obj.solutionScheme='FSP';
            [~,~,obj] = obj.solve;
        end
        function [Solution, bConstraints, obj] = solve(obj,stateSpace,saveFile,fspSoln)
            arguments
                obj
                stateSpace = [];
                saveFile=[];
                fspSoln=[];
            end
            % Solve the model using the specified method in
            %    obj.solutionScheme (default: 'FSP')
            % Inputs:
            %   obj
            %   stateSpace = [];
            %   saveFile = [];
            %   fspSoln = [];
            % Example:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [soln,bounds] = F.solve;  % Returns the solution and the
            %                             % bounds for the FSP projection
            %   F.solutionScheme = 'fspSens'
            %   [soln,bounds] = F.solve;  % Returns the sensitivity and the
            %                             % bounds for the FSP projection
            % See also: SSIT.makePlot for information on how to visualize
            % the solution data.
            if obj.initialTime>obj.tSpan(1)
                error('First time in tspan cannot be earlier than the initial time.')
            elseif obj.initialTime~=obj.tSpan(1)
                %                 warning('First time in tspan is not the same as initial time.')
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);
            end

            if isempty(stateSpace)&&~isempty(obj.fspOptions.stateSpace)
                stateSpace = obj.fspOptions.stateSpace;
            end

            if strcmp(obj.solutionScheme,'ode')
                propensityGeneral = obj.propensitiesGeneralODE;
            else
                propensityGeneral = obj.propensitiesGeneral;
            end

            if isempty(propensityGeneral)
                disp('Forming Propensity Functions.')
                obj = formPropensitiesGeneral(obj);
            elseif ~isempty(obj.hybridOptions)&&~strcmp(obj.solutionScheme,'ode')&&length(obj.hybridOptions.upstreamODEs)~=length(propensityGeneral{1}.ODEstoichVector)
                disp('(Re)Forming Propensity Functions Due to Detected Change in Hybrid Model Dimension.')
                obj = formPropensitiesGeneral(obj,'hybrid',true);
            end

            if obj.modelReductionOptions.useModReduction
                if ~isfield(obj.modelReductionOptions,'phi')
                    error('Model Reduction Matrices have not yet been Defined.')
                end
                useReducedModel = true;
                modRedTransformMatrices.phi = obj.modelReductionOptions.phi;
                modRedTransformMatrices.phi_inv = obj.modelReductionOptions.phi_inv;
                modRedTransformMatrices.phiScale = obj.modelReductionOptions.phiScale;
                modRedTransformMatrices.phiPlot = obj.modelReductionOptions.phiPlot;
            else
                useReducedModel = false;
                modRedTransformMatrices = [];
            end

            switch lower(obj.solutionScheme)
                case 'fsp'
                    if ~isempty(stateSpace)&&size(stateSpace.states,2)~=length(stateSpace.state2indMap.keys)
                        error('Mismatch in statespace definition.')
                    end

                    % specificPropensities = SSIT.parameterizePropensities(obj.propensitiesGeneral,[obj.parameters{:,2}]');

                    [Solution.fsp, bConstraints,Solution.stateSpace] = ssit.fsp.adaptiveFspSolve(obj.tSpan,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.propensitiesGeneral, ...
                        [obj.parameters{:,2}]', ...
                        obj.fspOptions.fspTol, ...
                        obj.fspConstraints.f, ...
                        obj.fspConstraints.b,...
                        obj.fspOptions.verbose, ...
                        obj.fspOptions.fspIntegratorRelTol, ...
                        obj.fspOptions.fspIntegratorAbsTol, ...
                        obj.fspOptions.odeSolver, ...
                        stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape, ...
                        obj.fspOptions.constantJacobian,...
                        obj.fspOptions.constantJacobianTime,...
                        obj.odeIntegrator);
                    obj.fspOptions.stateSpace = Solution.stateSpace;
                    obj.fspOptions.bounds = bConstraints;

                case 'ssa'
                    Solution.T_array = obj.tSpan;
                    Nt = length(Solution.T_array);
                    nSims = obj.ssaOptions.Nexp*obj.ssaOptions.nSimsPerExpt*Nt;

                    % Write callable SSA code for better efficiency.
                    % W = obj.propensitiesGeneral;
                    % if obj.ssaOptions.useGPU
                    % Write a GPU Friendly Code and then Execute.
                    k = [obj.parameters{:,2}];
                    % Parameters for the model.

                    w = obj.propensityFunctions;
                    % Replace input signals with their actual functions.
                    for i = 1:size(obj.inputExpressions,1)
                        w = regexprep(w,['\<',obj.inputExpressions{i,1},'\>'],['(',obj.inputExpressions{i,2},')']);
                    end
                    % Replace species with vector
                    for i = 1:length(obj.species)
                        w = regexprep(w,['\<',obj.species{i},'\>'],['x',num2str(i)]);
                    end
                    % Replace parameters with $i
                    for i = 1:size(obj.parameters,1)
                        w = regexprep(w,['\<',obj.parameters{i,1},'\>'],['$',num2str(i)]);
                    end
                    % Replace $ with k
                    w = strrep(w,'$','k');

                    S = obj.stoichiometry;  % Stoichiometry matrix.

                    x0 = obj.initialCondition;
                    % initial condition.

                    % Call code to write a GPU friendly SSA code.
                    fun_name = 'TmpGPUSSACode';
                    clear TmpGPUSSACode % Clear function from cache just in case.
                    ssit.ssa.WriteGPUSSA(k,w,S,obj.tSpan,fun_name);

                    fun = str2func(fun_name);
                    % Convert the function name string to a function handle.

                    % Run SSA on GPU, in parallel, or in series as
                    % requested.
                    if obj.ssaOptions.useGPU
                        Solution.trajs=fun(x0,nSims,'GPU');
                    elseif obj.ssaOptions.useParallel
                        Solution.trajs=fun(x0,nSims,'Parallel');
                    else
                        Solution.trajs=fun(x0,nSims,'Series');
                    end
                    disp([num2str(nSims),' SSA Runs Completed'])

                    % Apply PDO, if applicable
                    if ~isempty(obj.pdoOptions.PDO)
                        Solution.trajsDistorted = zeros(length(obj.species),...
                            length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                        for iS = 1:length(obj.species)
                            PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                            nDpossible = size(PDO,1);
                            Q = Solution.trajs(iS,:,:);
                            for iD = 1:length(Q(:))
                                Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                            end
                            Solution.trajsDistorted(iS,:,:) = Q;
                        end
                        disp('PDO applied to SSA results')
                    end

                    % Save results if requested.
                    if ~isempty(saveFile)
                        A = table;
                        for j=1:Nt
                            A.time((j-1)*obj.ssaOptions.nSimsPerExpt+1:j*obj.ssaOptions.nSimsPerExpt) = obj.tSpan(j);
                            for i = 1:obj.ssaOptions.Nexp
                                for k=1:obj.ssaOptions.nSimsPerExpt
                                    for s = 1:size(Solution.trajs,1)
                                        warning('off')
                                        A.(['exp',num2str(i),'_s',num2str(s)])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                            Solution.trajs(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                        if ~isempty(obj.pdoOptions.PDO)
                                            A.(['exp',num2str(i),'_s',num2str(s),'_Distorted'])((j-1)*obj.ssaOptions.nSimsPerExpt+k) = ...
                                                Solution.trajsDistorted(s,j,(i-1)*Nt*obj.ssaOptions.nSimsPerExpt+(j-1)*obj.ssaOptions.nSimsPerExpt+k);
                                        end
                                    end
                                end
                            end
                        end
                        writetable(A,saveFile)
                        disp(['SSA Results saved to ',saveFile])
                    end

                    bConstraints = max(obj.fspConstraints.f((reshape(Solution.trajs,[size(Solution.trajs,1),size(Solution.trajs,2)*size(Solution.trajs,3)]))),[],2);
                    bConstraints = max(bConstraints,obj.fspConstraints.b);

                case 'fspsens'
                    if strcmp(obj.sensOptions.solutionMethod,'forward')&&isempty(obj.propensitiesGeneral{1}.sensTimeFactorVec)
                        obj = formPropensitiesGeneral(obj,'Sensitivities',true);
                    end
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = obj.species;

                    [Solution.sens, bConstraints] = ...
                        ssit.sensitivity.computeSensitivity(...
                        obj.parameters,...
                        obj.propensitiesGeneral,...
                        obj.tSpan,...
                        obj.fspOptions.fspTol,...
                        obj.initialCondition,...
                        obj.initialProbs,...
                        obj.stoichiometry, ...
                        obj.fspConstraints.f,...
                        obj.fspConstraints.b,...
                        [], obj.fspOptions.verbose, 0,...
                        obj.sensOptions.solutionMethod,...
                        app,stateSpace,...
                        obj.fspOptions.usePiecewiseFSP,...
                        obj.fspOptions.initApproxSS,...
                        obj.species,...
                        obj.sensOptions.useParallel,...
                        fspSoln,...
                        useReducedModel,modRedTransformMatrices, ...
                        obj.useHybrid,obj.hybridOptions,...
                        obj.fspConstraints.fEscape,obj.fspConstraints.bEscape,...
                        obj.fspOptions.constantJacobian,obj.fspOptions.constantJacobianTime,...
                        obj.odeIntegrator);
                    %                     app.SensFspTabOutputs.solutions = Solution.sens;
                    %                     app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    %                     Solution.plotable = exportSensResults(app);

                case 'ode'
                    [~,Solution.ode] = ssit.moments.solveOde2(obj.initialCondition, obj.tSpan, ...
                        obj.stoichiometry, obj.propensitiesGeneralODE,  [obj.parameters{:,2}]', ...
                        obj.fspOptions.initApproxSS, obj.odeIntegrator);
            end

            if nargout>=3
                % Save all new solution fields WITHOUT overwriting existing
                % solutions.
                newFields = fieldnames(Solution);
                for ifield = 1:length(newFields)
                    obj.Solutions.(newFields{ifield}) = Solution.(newFields{ifield});
                end
            end

        end

        function A = sampleDataFromFSP(obj,fspSoln,saveFile)
            % Function to create simulated single-cell snapshot data by
            % sampling from the FSP solution.
            % Arguments:
            %       fspSoln -- solution of current model using FSP.
            %       saveFile -- filename (.csv) to save data.
            Solution.T_array = obj.tSpan;
            Nt = length(Solution.T_array);
            nSims = obj.ssaOptions.nSimsPerExpt*obj.ssaOptions.Nexp;
            Solution.trajs = zeros(length(obj.species),...
                length(obj.tSpan),nSims);% Creates an empty Trajectories matrix
            % from the size of the time array and number of simulations
            for it = 1:length(obj.tSpan)
                clear PP
                PP = double(fspSoln.fsp{it}.p.data);
                clear w
                w(:) = PP(:); w(w<0)=0;
                % TODO - there has to be another way of doing this.
                [I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11] =  ind2sub(size(PP),randsample(length(w), nSims, true, w ));
                for iSp = 1:length(obj.species)
                    eval(['Solution.trajs(iSp,it,:) = I',num2str(iSp),'-1;']);
                end
            end
            if ~isempty(obj.pdoOptions.PDO)
                Solution.trajsDistorted = zeros(length(obj.species),...
                    length(obj.tSpan),nSims);% Creates an empty Trajectories matrix from the size of the time array and number of simulations
                for iS = 1:length(obj.species)
                    PDO = obj.pdoOptions.PDO.conditionalPmfs{iS};
                    nDpossible = size(PDO,1);
                    Q = Solution.trajs(iS,:,:);
                    for iD = 1:length(Q(:))
                        Q(iD) = randsample([0:nDpossible-1],1,true,PDO(:,Q(iD)+1));
                    end
                    Solution.trajsDistorted(iS,:,:) = Q;
                end
                disp('PDO applied to FSP Samples')
            end
            if ~isempty(saveFile)
                A = table;
                for it=1:Nt
                    A.time((it-1)*obj.ssaOptions.nSimsPerExpt+1:it*obj.ssaOptions.nSimsPerExpt) = obj.tSpan(it);
                    for ie = 1:obj.ssaOptions.Nexp
                        for s = 1:size(Solution.trajs,1)
                            warning('off')
                            A.(['exp',num2str(ie),'_s',num2str(s)])((it-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt)) = ...
                                Solution.trajs(s,it,(ie-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt));
                            if ~isempty(obj.pdoOptions.PDO)
                                A.(['exp',num2str(ie),'_s',num2str(s),'_Distorted'])((it-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt)) = ...
                                    Solution.trajsDistorted(s,it,(ie-1)*obj.ssaOptions.nSimsPerExpt+(1:obj.ssaOptions.nSimsPerExpt));
                            end
                        end
                    end
                end
                writetable(A,saveFile)
                disp(['FSP Samples saved to ',saveFile])
            end
        end

        function [fimResults,sensSoln] = computeFIM(obj,sensSoln,scale,MHSamples)
            %% computeFIM - Computes the Fisher Information Matrix (FIM)
            %%              at all time points.
            % Inputs:
            %   * sensSoln (optional) - previously computed FSP
            %                           sensitivity, automatically
            %                           computed by computeFIM if not
            %                           provided
            %   * scale - choice of FIM based on linear parameters or
            %             their natural logarithm ('lin' or 'log'),
            %             default: 'lin'
            %   * MHSamples (optional) - set of parameter sets at which
            %                            to calculate the FIM
            %
            % Outputs:
            %   * fimResults - FIM at each time point in obj.tSpan
            %   * sensSoln - FSP sensitivity solutions
            arguments
                obj
                sensSoln = [];
                scale = 'lin';
                MHSamples = [];
            end

            if ~isempty(MHSamples)
                % For FIM calculation
                nSamples = size(MHSamples,1);
                Nt = length(obj.tSpan);
                fimResults = cell(Nt,nSamples);
                if isempty(sensSoln)||length(sensSoln)~=nSamples
                    sensSoln = cell(1,nSamples);
                end
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    obj.fittingOptions.modelVarsToFit = 1:size(obj.parameters,1);
                end
                if nargout == 2
                    saveSens = true;
                else
                    saveSens = false;
                end

                for i=1:nSamples
                    objTMP = obj;
                    objTMP.parameters(objTMP.fittingOptions.modelVarsToFit,2) = ...
                        num2cell(MHSamples(i,:));
                    if saveSens
                        [fimResults(:,i),sensSoln{i}] = computeFIM(obj,sensSoln{i},scale);
                    else
                        fimResults(:,i) = objTMP.computeFIM(sensSoln{i},scale);
                    end
                end
            else

                if isempty(sensSoln)
                    % disp({'Running Sensitivity Calculation';'You can skip this step by providing sensSoln.'})
                    obj.solutionScheme = 'fspSens';
                    [sensSoln] = obj.solve;
                    sensSoln = sensSoln.sens;
                end

                % Separate into observed and unobserved species.
                if isfield(obj.hybridOptions,'upstreamODEs')
                    speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                else
                    speciesStochastic = obj.species;
                end
                Nd = length(speciesStochastic);
                indsUnobserved=[];
                indsObserved=[];
                for i=1:Nd
                    if ~isempty(obj.pdoOptions.unobservedSpecies)&&max(contains(obj.pdoOptions.unobservedSpecies,speciesStochastic{i}))
                        indsUnobserved=[indsUnobserved,i];
                    else
                        indsObserved=[indsObserved,i];
                    end
                end

                % compute FIM for each time point
                fimResults = {};
                for it=length(sensSoln.data):-1:1
                    if isempty(indsUnobserved)
                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p, sensSoln.data{it}.S, obj.pdoOptions.PDO);
                    else
                        % Remove unobservable species.
                        redS = sensSoln.data{it}.S;
                        for ir = 1:length(redS)
                            redS(ir) = sensSoln.data{it}.S(ir).sumOver(indsUnobserved);
                        end

                        % Truncate to remove PDOs for unobserved species.
                        PDO = obj.pdoOptions.PDO;
                        if ~isempty(PDO)&&(length(PDO.conditionalPmfs)>length(obj.species)-length(indsUnobserved))
                            if length(PDO.conditionalPmfs)==length(obj.species)
                                PDO.conditionalPmfs = PDO.conditionalPmfs(indsObserved);
                                if ~isempty(PDO.dCdLam)
                                    PDO.dCdLam = PDO.dCdLam(indsObserved,indsObserved);
                                end
                            else
                                error('Not clear how to specify PDO for observed species')
                            end
                        end

                        % Update conditionalPmfs input size for calibrated PDO
                        if ~isempty(PDO)
                            if size(PDO.conditionalPmfs{1},2) <= size(redS(1).data)
                                max_xTrue = size(PDO.conditionalPmfs{1},2);
                                PDO_input = size(redS(1).data);
                                if PDO_input > max_xTrue
                                    % Padding
                                    disp("Padding conditionalPmfs input to increase size for PDO: " + max_xTrue + " to " + PDO_input)
                                    padding = zeros(size(PDO.conditionalPmfs{1}, 1), PDO_input - max_xTrue);
                                    PDO.conditionalPmfs{1} = [PDO.conditionalPmfs{1}, padding];
                                elseif PDO_input < max_xTrue
                                    % Cropping
                                    disp("Warning! Cropping conditionalPmfs input size ? " + max_xTrue + " to " + PDO_input)
                                    PDO.conditionalPmfs{1} = PDO.conditionalPmfs{1}(:, 1:PDO_input);
                                end
                            end
                        end

                        F = ssit.fim.computeSingleCellFim(sensSoln.data{it}.p.sumOver(indsUnobserved), redS, PDO);
                    end
                    fimResults{it,1} = F;
                end

                % TODO -- We need to add capability for the PDO parameters
                % to be included in the FIM calculation in log space.
                % Right now, the following will give an error because the
                % dimensions will not match when PDO parameters are
                % included.  Also, the current code does not allow for some
                % PDO parameters to be free while others are fixed.

                if strcmp(scale,'log')
                    for it=length(sensSoln.data):-1:1
                        fimResults{it,1} = diag([obj.parameters{:,2}])*...
                            fimResults{it,1}*...
                            diag([obj.parameters{:,2}]);
                    end
                end

            end
        end

        function [fimTotal,mleCovEstimate,fimMetrics] = evaluateExperiment(obj,...
                fimResults,cellCounts,priorCoVariance)
            % This function evaluates the provided experiment design (in
            % "cellCounts" and produces an array of FIMs (one for each
            % parameter set.
            arguments
                obj
                fimResults
                cellCounts
                priorCoVariance = []
            end

            Ns = size(fimResults,2);
            Nt = size(fimResults,1);
            Np = size(fimResults{1,1},1);
            fimTotal = cell(1,Ns);
            mleCovEstimate = cell(1,Ns);

            % Add the prior covariance into the FIM calculation if
            % provided. The prior covariance should be in the same scale as
            % the parameters (e.g.m linear, log, or log10).
            if isempty(priorCoVariance)
                PriorFIM = zeros(Np);
            else
                PriorFIM = inv(priorCoVariance);
            end

            for is=1:Ns
                fimTotal{is} = PriorFIM; %0*fimResults{1,is};

                for it=1:Nt
                    fimTotal{is} = fimTotal{is} + cellCounts(it)*fimResults{it,is};
                end

                if nargout>=2
                    % Estimate MLE covariance
                    if rank(fimTotal{is})<Np
                        disp(['FIM has rank ',num2str(rank(fimTotal{is})),' and is not invertable for this experiment design'])
                        mleCovEstimate{1,is} = NaN*ones(Np);
                    else
                        mleCovEstimate{1,is} = fimTotal{is}^-1;
                    end
                end
            end

            if nargout>=3
                for is = Ns:-1:1
                    % Compute FIM metrics.
                    fimMetrics.det(1,is) = det(fimTotal{is});
                    fimMetrics.trace(1,is) = trace(fimTotal{is});
                    fimMetrics.minEigVal(1,is) = min(eig(fimTotal{is}));
                end
            end
        end

        function [NcDNewDesign] = optimizeCellCounts(obj,fims,nCellsTotalNew,FIMMetric,...
                NcGuess,NcFixed,NcMax,statistic,covPrior,incrementAdd)
            %% SSIT.optimizeCellCounts - This function optimizes the number
            %% of cells per time point according to the user-provide metric.
            %
            % Inputs:
            %   * 'fims' - either an [Nt x 1] cell array containing the FIM
            %      matrices for each of the Nt time points, or an [Nt x Ns]
            %      cellarray containing the FIM for each combination of Nt
            %      time points and Ns different parameter sets
            %   * 'nCellsTotalNew' - the total number of cells to be
            %       measured, spread out among the Nt time points
            %   * 'FIMmetric' - type of optimization, allowable metrics are:
            %       'Determinant' - maximize the expected determinant of
            %                       the FIM
            %       'DetCovariance' - minimize the expected determinant of
            %                         MLE covariance
            %       'Smallest Eigenvalue' - maximize the smallest e.val of
            %                               the FIM
            %       'Trace' - maximize the trace of the FIM
            %       '[<i1>,<i2>,...]' - minimize the determinant of the
            %                           inverse FIM for the specified
            %                           indices, (all other parameters are
            %                           assumed to be free)
            %       'TR[<i1>,<i2>,...]' - maximize the determinant of the
            %                             FIM for the specified indices,
            %                             (only the parameters in
            %                             obj.fittingOptions.modelVarsToFit
            %                             are assumed to be free)
            %   * 'Nc' - an optimal guess for the optimal experiment
            %            design
            %   * 'NcFixed' - a minimal number of cells to measure at each
            %      time point; this is useful for subsequent experiment
            %      design, having already obtained measured cells from a
            %      previous experiment
            %   * 'NcMax' - maximum total number of cells allowed for each
            %      time point; this is useful in simulated experiment design,
            %      where there are only so many cells available in the real
            %      data
            %
            % Outputs:
            %   * 'Nc' is the optimized experiment design (number of cells
            %      to measure at each point in time)
            %
            % Example: Model.optimizeCellCounts(fimResults,nCellsTotal,...
            %           'Determinant',[],[],[],[],diag(log10.^2));
            arguments
                obj
                fims
                nCellsTotalNew
                FIMMetric = 'Smallest Eigenvalue'
                NcGuess = []
                NcFixed = []
                NcMax = []
                statistic = 'mean'
                covPrior = []
                incrementAdd = 1
            end
            if mod(nCellsTotalNew,incrementAdd)~=0
                error('Number of cells must be evenly divisible by incrementAdd.')
            end
            switch FIMMetric
                case 'Determinant'
                    met = @(A)-max(0,det(A));
                case 'DetCovariance'
                    met = @(A)max(0,det(inv(A)));
                case 'Smallest Eigenvalue'
                    met = @(A)-min(eig(A));
                case 'Trace'
                    met = @(A)-trace(A);
                otherwise
                    if strcmp(FIMMetric(1:2),'TR')
                        k = eval(FIMMetric(3:end));
                        met = @(A)max(0,det(inv(A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'tr')
                        k = eval(FIMMetric(3:end));
                        met = @(A)-max(0,det((A(k,k))));
                    elseif strcmp(FIMMetric(1:2),'GR')
                        k = eval(FIMMetric(3:end));
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    else  % all parameters are free.
                        k = eval(FIMMetric);
                        ek = zeros(length(k),length(fims{1}));
                        ek(1:length(k),k) = eye(length(k));
                        met = @(A)max(0,det(ek*inv(A)*ek'));
                    end
            end
            NT = size(fims,1);
            NS = size(fims,2);

            if isempty(NcFixed)
                NcFixed = zeros(1,NT);
            end

            if isempty(NcMax)
                NcMax = inf*ones(1,NT);
            end

            if isempty(NcGuess)
                % Distributed avaliable cells among experiments.
                NcGuess = NcFixed;
                iExpt = 1;
                while nCellsTotalNew>0&&iExpt<=length(NcGuess)
                    avblSlots = NcMax(iExpt) - NcFixed(iExpt);
                    if avblSlots>=nCellsTotalNew
                        NcGuess(iExpt) = NcGuess(iExpt) + nCellsTotalNew;
                        iExpt = inf;
                    else
                        while avblSlots >= incrementAdd
                            NcGuess(iExpt) = NcGuess(iExpt) + incrementAdd;
                            nCellsTotalNew = nCellsTotalNew - incrementAdd;
                            avblSlots = avblSlots - incrementAdd;
                        end
                        iExpt = iExpt + 1;
                        if iExpt>length(NcGuess)&&nCellsTotalNew>=0
                            NcDNewDesign = NcGuess - NcFixed;
                            warning('All cells have been distributed.')
                            return
                        end
                    end
                end
            else
                NcGuess = NcFixed+NcGuess;
            end

            % Process to search for optimal experiment
            Converged = 0;
            while Converged==0
                Converged = 1;
                % Iterate through the time points
                for i = 1:NT
                    % If
                    while NcGuess(i)-incrementAdd>=NcFixed(i)
                        Ncp = NcGuess;
                        Ncp(i) = Ncp(i)-incrementAdd;
                        k = SSIT.findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd);
                        if k==i
                            break
                        end
                        NcGuess = Ncp;
                        NcGuess(k)=NcGuess(k)+incrementAdd;
                        Converged = 0;
                    end
                end
            end
            NcDNewDesign = NcGuess - NcFixed;
        end

        %% Data Loading and Fitting
        function [obj] = loadData(obj,dataFileName,linkedSpecies,conditions)
            % SSIT.loadData - Reads data from given file and associates
            % it with specified model species and experimental conditions.
            %
            % Inputs:
            %   * obj
            %   * dataFileName - name of data file, e.g., "dataFile.csv"
            %   * linkedSpecies - takes two strings: first, the names of
            %   the species given to the SSIT model using the 'species'
            %   property (e.g., Model.species = {'RNA','Protein'}); and
            %   second, the names of the species in the data file (e.g.,
            %   {'RNA','x1';'Protein','x2'})
            %   * conditions - data conditions that can be used to filter
            %                out data that do not meet specifications,
            %                e.g., conditions = {'Rep_num','1'}  : only
            %                the data in the 'Rep_num' column that is
            %                exactly equal to '1' will be kept in the
            %                data set
            %
            % Example:
            %   Model = Model.loadData("/data/dataFile.csv",...
            %    {'RNA','x1';'Protein','x2'},...
            %    {'Drug_Conc',100});
            arguments
                obj
                dataFileName
                linkedSpecies
                conditions = {};
            end
            obj.dataSet =[];
            if ischar(dataFileName)||isstring(dataFileName)
                TAB = readtable(dataFileName);
            elseif iscell(dataFileName)
                TAB = table;
                for iCell = 1:length(dataFileName)
                    iTAB = readtable(dataFileName{iCell});
                    TAB = [TAB;iTAB];
                end
            end

            % Find time column
            timeField = TAB.Properties.VariableNames(contains(lower(TAB.Properties.VariableNames),'time'));
            if isempty(timeField)
                error('Data sheet does not have an entry with keyword "time"');
            elseif length(timeField)>2
                error('Data sheet has more than one entry with keyword "time"');
            end

            % Apply conditions
            for i = 1:size(conditions,1)
                if size(conditions,2)==2
                    if isnumeric(conditions{i,2})&&isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB(TAB.(conditions{i,1})==conditions{i,2},:);
                    elseif ischar(conditions{i,2})&&iscell(TAB.(conditions{i,1})(1))&&ischar(TAB.(conditions{i,1}){1})
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif ischar(conditions{i,2})&&ischar(TAB.(conditions{i,1})(1))
                        TAB = TAB(strcmp(TAB.(conditions{i,1}),conditions{i,2}),:);
                    elseif isnumeric(TAB.(conditions{i,1})(1))
                        TAB = TAB((TAB.(conditions{i,1}))==eval(conditions{i,2}),:);
                    end
                else
                    try
                        eval(['TAB = TAB(TAB.(conditions{i,1})',conditions{i,3},'conditions{i,2},:);'])
                    catch
                        eval(['TAB = TAB(',conditions{i,3},',:);'])
                    end
                end
            end
            obj.dataSet.DATA = table2cell(TAB);

            % Link Species
            % First, make sure that all linked species are in the order of
            % species.
            iSpe = [];
            for i = 1:length(obj.species)
                if max(contains(linkedSpecies(:,1),obj.species(i)))
                    j = find(strcmp(linkedSpecies(:,1),obj.species(i)));
                    iSpe = [iSpe,j];
                end
            end
            linkedSpecies = linkedSpecies(iSpe,:);

            TAB2 = table;
            TAB2.time = TAB.(timeField{1});
            for i = 1:size(linkedSpecies,1)
                if ~isempty(linkedSpecies{i,2})
                    TAB2.(linkedSpecies{i,1}) = TAB.(linkedSpecies{i,2});
                elseif ~isempty(linkedSpecies{i,3})
                    % This section allows for manipulation of data columns.
                    % Example: linkedSpecies = {'rna',[],'TAB.nuc+TAB.cyt'}
                    % results in TAB2.rna = TAB.nuc+TAB.cyt
                    eval(['TAB2.',linkedSpecies{i,1},' = ',linkedSpecies{i,3},';']);
                end

            end

            % Reorder table in order of species list
            [~,iA] = intersect(linkedSpecies(:,1),obj.species,'stable');
            TAB2 = TAB2(:,[1,iA'+1]);

            % dataTensor = sptensor(
            times = unique(TAB2.time);
            numTimes = length(times);
            timeAr = TAB2.time;
            for i = 1:numTimes
                timeAr(TAB2.time==times(i)) = i-1;
            end
            TAB2.time = timeAr;

            % Construct sparse tensor to hold data.
            TAB2.Variables = max(0,TAB2.Variables);
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor = sptensor(TAB2.Variables+1,ones(size(TAB2,1),1));

            % Define other properties needed in other functions.
            obj.dataSet.linkedSpecies = linkedSpecies;
            obj.dataSet.times = times';

            obj.dataSet.app.SpeciesForFitPlot.Items = obj.species;
            obj.dataSet.app.SpeciesForFitPlot.Items = linkedSpecies(:,1);
            obj.dataSet.app.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = times';
            for i=1:numTimes
                obj.dataSet.app.ParEstFitTimesList.Items{i} = num2str(times(i));
            end
            obj.dataSet.app.ParEstFitTimesList.Value = obj.dataSet.app.ParEstFitTimesList.Items;


            %%
            sz = size(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor);
            obj.dataSet.nCells=zeros(sz(1),1);
            for i=1:sz(1)
                if length(sz)==2
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:)),'all');
                elseif length(sz)==3
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:)),'all');
                elseif length(sz)==4
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:)),'all');
                elseif length(sz)==5
                    obj.dataSet.nCells(i) = sum(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,:,:,:,:)),'all');
                end
            end

            obj.tSpan = unique([obj.initialTime,obj.dataSet.times]);

            % Calculate the means and variances
            obj.dataSet.mean = zeros(sz(1),length(sz)-1);
            obj.dataSet.var = zeros(sz(1),length(sz)-1);
            for i=1:sz(1)
                for j=2:length(sz)
                    tmpInt{j-1} = [1:sz(j)];
                end
                TMP = squeeze(double(obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor(i,tmpInt{:})));
                for j = 1:length(sz)-1
                    if length(sz)>2
                        H = sum(TMP,[1:j-1,j+1:length(sz)-1]);
                    else
                        H = TMP;
                    end
                    obj.dataSet.mean(i,j) = sum([0:length(H)-1]'.*H(:))/sum(H);
                    x2 = sum(([0:length(H)-1].^2)'.*H(:))/sum(H);
                    obj.dataSet.var(i,j) = x2 - obj.dataSet.mean(i,j)^2;
                end
            end

            %% Automatically set unobserved species based on loaded data.
            obj.pdoOptions.unobservedSpecies = setdiff(obj.species,linkedSpecies(:,1),'stable')';

        end

        function [logL,gradient] = minusLogL(obj,pars,stateSpace,computeSensitivity)
            [logL,gradient] = computeLikelihood(obj,exp(pars),stateSpace,computeSensitivity);
            logL = -logL;
            gradient = -gradient.*exp(pars);
        end

        function [logLode] = computeLikelihoodODE(obj,pars,SIG)
            arguments
                obj
                pars = [];
                SIG = [];
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                logTimesToFit = ones(1,length(obj.dataSet.times),'logical');
            else
                logTimesToFit = obj.fittingOptions.timesToFit;
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                indsParsToFit = [1:length(obj.parameters)];
            else
                indsParsToFit = obj.fittingOptions.modelVarsToFit;
            end
            nModelPars = length(indsParsToFit);

            if isempty(pars)
                pars = [obj.parameters{indsParsToFit,2}];
            end

            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            originalPars = obj.parameters;
            obj.tSpan = unique([obj.initialTime,obj.tSpan,obj.dataSet.times]);
            [~,IA,~] = intersect(obj.tSpan,obj.dataSet.times(logTimesToFit));

            % Update Model and PDO parameters using supplied guess
            obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

            obj.solutionScheme = 'ode'; % Chosen solutuon scheme
            for i=1:size(obj.parameters,1)
                obj.parameters{i,2} = round(obj.parameters{i,2},12);
            end
            solutions = obj.solve;  % Solve the ODE analysis

            obj.parameters =  originalPars;

            % Need to add likelihood calculation here.
            nt = length(IA);
            %             ns = length(obj.species);

            for i = 1:size(obj.dataSet.linkedSpecies,1)
                J(i) = find(strcmp(obj.species,obj.dataSet.linkedSpecies{i,1}));
            end
            nds = length(J);

            nc = repmat(obj.dataSet.nCells(logTimesToFit),nds,1);

            vm = zeros(nt*nds,1);
            tmp = solutions.ode(IA,J);
            vm(:) = tmp(:);

            vd = zeros(nt*nds,1);
            vd(:) = obj.dataSet.mean(logTimesToFit,:);

            vm = real(vm);

            if isempty(SIG)
                % SIG = eye(nt*nds);
                vec = zeros(numel(obj.dataSet.var(logTimesToFit,:)),1);
                vec(:) = obj.dataSet.var(logTimesToFit,:);
                SIG = diag(vec);
            end

            logLode = -1/2*(sqrt(nc)'.*(vd-vm)')*SIG^(-1)*((vd-vm).*sqrt(nc));
            logLode = logLode+logPrior;
        end

        function [logL,gradient,fitSolutions] = computeLikelihood(obj,pars, ...
                stateSpace,computeSensitivity,reuseExistingSolution)
            % This function computes the log likelihood of the data given
            % the model.
            % obj -- (SSIT class)
            % pars -- parameters of model in linear space.  Matches the
            %   order in obj.parameters, and downselected to the free
            %   parameters in obj.fittingOptions.modelVarsToFit.
            % stateSpace -- (optional) statespace for FSP solution.
            %   providing increases efficiency.
            % computeSensitivity -- (false) flag to request
            %   sensitivity of loglkelihood functon wrt parameters as a
            %   returned variable.
            % reuseExistingSolution -- (false) flag to reuse existing SSIT
            %   solutions already in memory.
            arguments
                obj
                pars = [];
                stateSpace =[];
                computeSensitivity = false;
                reuseExistingSolution = false
            end

            if reuseExistingSolution
                solutions = obj.Solutions;  % Solve the FSP analysis

            else
                % Reset state space if it has inconsistencies
                if ~isempty(stateSpace)&&size(stateSpace.states,2)~=length(stateSpace.state2indMap.keys)
                    stateSpace =[];
                end

                % select which parameters to consider in likelihood function
                % first for the model parameters
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    indsParsToFit = [1:length(obj.parameters)];
                else
                    indsParsToFit = obj.fittingOptions.modelVarsToFit;
                end
                nModelPars = length(indsParsToFit);

                % then for PDO parameters
                if strcmp(obj.fittingOptions.pdoVarsToFit,'all')
                    indsPdoParsToFit = [1:length(obj.pdoOptions.props.ParameterGuess)];
                else
                    indsPdoParsToFit = obj.fittingOptions.pdoVarsToFit;
                end
                nPdoPars = length(indsPdoParsToFit);

                % if parameters are not provided, use the ones stored in the
                % SSIT object.
                if isempty(pars)
                    pars = [obj.parameters{indsParsToFit,2}];
                end

                % save original parameters
                originalPars = obj.parameters;

                % remove duplicates from time span
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);

                % Update Model and PDO parameters using supplied guess
                obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));


                % TODO - it would be nice to be able to reuse existing
                % solutions, but for this to work robustly, we need to have
                % some means to check that the old solutions is for the exact
                % same conditions and paramters as the new one.
                % if max(abs([originalPars{:,2}]-[obj.parameters{:,2}]))==0&&~isempty(obj.Solutions)&&...
                %         (strcmpi(obj.solutionScheme,'fsp')&&~isempty(obj.Solutions.fsp))||...
                %         (strcmpi(obj.solutionScheme,'fspsens')&&~isempty(obj.Solutions.sens))
                %
                %     solutions = obj.Solutions;
                % else
                % Call routines to find the FSP solution with or without
                % sensitivity.
                if computeSensitivity&&nargout>=2
                    obj.solutionScheme = 'fspSens'; % Chosen solution scheme
                    [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
                else
                    obj.solutionScheme = 'FSP'; % Chosen solution scheme
                    [solutions] = obj.solve(stateSpace);  % Solve the FSP analysis
                end
                obj.parameters =  originalPars; % Reset back to the original parameters.
                % end
            end

            % if there is no logprior, use zero.
            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            % Formulate PDO if one is used and it has adjustable
            % parameters.
            if ~isempty(pars)&&nPdoPars>0
                obj.pdoOptions.props.ParameterGuess(indsPdoParsToFit) = pars(nModelPars+1:end);
                obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
            end

            % Separate out stochastic species if using a hybrid ode/fsp
            % model.
            if obj.useHybrid
                speciesStochastic = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                speciesStochastic = obj.species;
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            else
                fitSolutions.ParEstFitTimesList = obj.dataSet.app.ParEstFitTimesList;
                fitSolutions.ParEstFitTimesList.Value = fitSolutions.ParEstFitTimesList.Items(obj.fittingOptions.timesToFit);
                timesToFit = zeros(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
                timesToFit(obj.fittingOptions.timesToFit) = true;
                obj.fittingOptions.timesToFit = timesToFit;

            end

            dataTensor = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            timesData = dataTensor.subs(:,1);
            timesUnique = unique(timesData);

            % Map measurement times to the solution times.
            J = zeros(1,length(obj.dataSet.times(obj.fittingOptions.timesToFit)));
            for it = 1:length(J)
                [~,J(it)] = min(abs(obj.tSpan-obj.dataSet.times(it)));
            end
            if ~computeSensitivity||nargout<2
                fsp = solutions.fsp(J);
            elseif computeSensitivity&&nargout>=2
                sens = solutions.sens.data(J);
            end
            numTimes = length(J);

            Nd = length(speciesStochastic);
            for i=Nd:-1:1
                indsPlots(i) = max(contains(obj.dataSet.linkedSpecies(:,1),speciesStochastic(i)));
            end
            indsIgnore = setdiff([1:Nd],find(indsPlots),'stable');

            LogLk = zeros(1,numTimes);

            % Set up storage for outputs if requested.
            if nargout>=3
                perfectMod = zeros(1,numTimes);
                numCells = obj.dataSet.nCells(obj.fittingOptions.timesToFit)';
                sz = [numTimes,max(solutions.stateSpace.states,[],2)'];
                sz = sz([true,indsPlots]);
                fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = sptensor(sz);
            end

            for it = 1:numTimes
                if ~computeSensitivity||nargout<2
                    % get FSP solution for current time.
                    px = fsp{it}.p;
                elseif computeSensitivity&&nargout>=2
                    px = sens{it}.p;
                    Sx = sens{it}.S;
                    parCount = length(Sx);
                    % Add effect of PDO.
                    if ~isempty(obj.pdoOptions.PDO)
                        for iPar = 1:parCount
                            Sx(iPar) = obj.pdoOptions.PDO.computeObservationDistDiff(px, Sx(iPar), iPar);
                        end
                    end
                    % Remove ignored species
                    for iPar = parCount:-1:1
                        if ~isempty(indsIgnore)
                            S{iPar} = Sx(iPar).sumOver(indsIgnore);
                        else
                            S{iPar} = Sx(iPar);
                        end
                        % S{iPar}(it,d~=0) = d(d~=0);
                    end
                end
                % Add effect of PDO.
                if ~isempty(obj.pdoOptions.PDO)
                    try
                        px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                    catch
                        obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
                        px = obj.pdoOptions.PDO.computeObservationDist(px,indsIgnore);
                    end
                end
                % Sum over the marginalization indices (if any). The return
                % result as a double vector.
                if ~isempty(indsIgnore)
                    px = px.sumOver(indsIgnore);
                end

                % Get indices and number of all observed data.
                inds = dataTensor.subs(timesData==timesUnique(it),2:end);
                vals = dataTensor.vals(timesData==timesUnique(it));
                szData = max(inds);

                % Pad Probability Distribution if support does not cover
                % all data.
                Pvals = px.data;
                szModel = size(Pvals);
                if max(szData-szModel)>0
                    Pvals(szData)=0;
                end

                Pvals = real(max(1e-10,double(Pvals)));
                Pvals = Pvals/max(1,sum(Pvals,'all'));
                logP = sptensor(log(Pvals));

                LogLk(it) = vals'*logP(inds);

                if nargout>=3
                    perfectMod(it) = vals'*log(vals/sum(vals));
                    Pvt = sptensor(Pvals);
                    if length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs(:,1:end-1)]) = Pvt.vals;
                    elseif length(size(Pvals))==length(size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current))-1
                        fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current([it*ones(size(Pvt.subs,1),1),Pvt.subs]) = Pvt.vals;
                    end
                end

                if computeSensitivity&&nargout>=2
                    for iPar = parCount:-1:1
                        St = S{iPar};
                        Svals = double(St.data);
                        dlogL_dPar(iPar,it) = sum(vals'*(Svals(inds)./Pvals(inds)));
                    end
                end
            end
            % P =
            % solnTensor = sptensor([length(solutions.fsp),max(solutions.stateSpace.states,[],2)'+1]);
            % solnT


            %%

            % Store data and model information for use in other routines.
            % The format used here is chosen to match an existing object in
            % the SSIT GUI.
            if nargout>=3
                % Make Full Tensor for Plotting
                for it = 1:numTimes


                end


                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current = zeros([numTimes,sz(2:end)]);
                % fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData = zeros([numTimes,sz(2:end)]);
                fitSolutions.NameTable.Data = [speciesStochastic,speciesStochastic];
                fitSolutions.SpeciesForFitPlot.Value = speciesStochastic(indsPlots);
                fitSolutions.SpeciesForFitPlot.Items = speciesStochastic;
                fitSolutions.DataLoadingAndFittingTabOutputs.dataTensor = dataTensor;
                fitSolutions.FspPrintTimesField.Value = ['[',num2str(obj.tSpan),']'];
                if ~computeSensitivity
                    fitSolutions.FspTabOutputs.solutions = solutions.fsp;
                else
                    fitSolutions.FspTabOutputs.solutions = solutions;
                end
                fitSolutions.FIMTabOutputs.distortionOperator = obj.pdoOptions.PDO;
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.dataTimes = obj.dataSet.times(obj.fittingOptions.timesToFit);
                fitSolutions.DataLoadingAndFittingTabOutputs.fittingOptions.fit_times = timesUnique;
            end

            % % Initialize sensitivity derivative if needed.
            % if computeSensitivity&&nargout>=2
            %     dlogL_dPar = zeros(parCount,numTimes);
            % end
            %
            % % Initialize log likelihood at zero for all times.
            % % LogLk = zeros(1,numTimes);
            % KS = zeros(1,numTimes);
            % numCells = zeros(1,numTimes);
            %
            % % LogL for idealized models
            % perfectMod = zeros(1,numTimes);
            % perfectModSmoothed = zeros(1,numTimes);
            %
            % for i=1:numTimes
            %     % Find the closes time index
            %     [diffTime,j] = min(abs(obj.tSpan-obj.dataSet.times(i)));
            %     if diffTime~=0
            %         warning('Exact match not found for time. Inaccuracies possible.')
            %     end
            %
            %     Jind = PD.subs(:,1) == i;
            %     SpInds = PD.subs(Jind,:);
            %
            %     SpVals = PD.vals(Jind);
            %     H = sptensor([ones(length(SpVals),1),SpInds(:,2:end)],SpVals,[1,NDat(2:end)]);
            %     H = double(H);
            %     Pt = P(j,:,:,:,:,:,:,:,:,:);
            %     Pt = Pt/max(1,sum(Pt,'all'));
            %     % LogLk(i) = sum(H(:).*log(Pt(:)));
            %     numCells(i) = sum(H(:));
            %     if computeSensitivity&&nargout>=2
            %         for iPar = parCount:-1:1
            %             St = S{iPar}(j,:,:,:,:,:,:);
            %             dlogL_dPar(iPar,i) = sum(H(:).*St(:)./Pt(:));
            %         end
            %     end
            %     if nargout>=3
            %         Q = H(:)/sum(H(:));
            %         KS(i) = max(abs(cumsum(Q(:))-cumsum(Pt(:))));
            %         smQ = smooth(Q); smQ=smQ/sum(smQ);
            %         logQ = log(Q); logQ(H==0)=1;
            %         logSmQ = log(smQ); logSmQ(H==0)=1;
            %         perfectMod(i) = sum(H(:).*logQ);
            %         perfectModSmoothed(i) = sum(H(:).*logSmQ);
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.current(i,:,:,:,:,:,:) = Pt;
            %         fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:,:,:,:) = ...
            %             reshape(Q,size(fitSolutions.DataLoadingAndFittingTabOutputs.fitResults.currentData(i,:,:,:)));
            %     end
            % end
            logL = sum(LogLk) + logPrior;

            if imag(logL)~=0
                disp('Imaginary likelihood set to -inf.')
                logL = -inf;
            end
            if nargout>=3
                fitSolutions.DataLoadingAndFittingTabOutputs.V_LogLk = LogLk;
                fitSolutions.DataLoadingAndFittingTabOutputs.numCells = numCells;
                fitSolutions.DataLoadingAndFittingTabOutputs.perfectMod = perfectMod;
                % fitSolutions.DataLoadingAndFittingTabOutputs.perfectModSmoothed = perfectModSmoothed;
                % fitSolutions.DataLoadingAndFittingTabOutputs.V_KS = KS;
            end
            if computeSensitivity&&nargout>=2
                gradient = sum(dlogL_dPar,2); % need to also add gradient wrt prior!!
            else
                gradient = [];
            end
        end


        function [lossFunction] = computeLossFunctionSSA(obj,lossFun,pars, ...
                enforceIndependence, reuseExistingSolution)
            % This function computes general loss functions forthe data given
            % the model.
            % obj -- (SSIT class)
            % lossFun -- ('cdf_one_norm') Name of predefined loss function
            % or handle to user-defined loss function. If using a
            % userdefined loss function, it should take as inputs the
            % histograms Hdata and Hmodel which will be evaluated for every
            % time point and every species and the results will be summed
            % together. Example:
            %       customLossMeans = @(Hmod,Hdata)([0:length(Hmod)-1]*Hmod-[0:length(Hdata)-1]*Hdata).^2;
            % pars -- parameters of model in linear space.  Matches the
            %   order in obj.parameters, and downselected to the free
            %   parameters in obj.fittingOptions.modelVarsToFit.
            % enforceIndependence -- (false) flag to decide if SSA runs are
            % split up to ensure each time point has independent data
            % points.
            % reuseExistingSolution -- (false) flag to reuse existing SSIT
            %   solutions already in memory.
            arguments
                obj
                lossFun = 'KS'
                pars = [];
                enforceIndependence = true
                reuseExistingSolution = false
            end

            if ~strcmpi(obj.solutionScheme,'ssa')
                error('computeLossFunctionSSA only meant for models using SSA solution scheme. Please change solutionScheme and try again.')
            end

            if reuseExistingSolution
                solutions = obj.Solutions;  % Load previous model solutions.

            else

                % Select which parameters to consider in loss function
                % first for the model parameters
                if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                    indsParsToFit = [1:length(obj.parameters)];
                else
                    indsParsToFit = obj.fittingOptions.modelVarsToFit;
                end
                nModelPars = length(indsParsToFit);

                % then for PDO parameters
                if strcmp(obj.fittingOptions.pdoVarsToFit,'all')
                    indsPdoParsToFit = [1:length(obj.pdoOptions.props.ParameterGuess)];
                else
                    indsPdoParsToFit = obj.fittingOptions.pdoVarsToFit;
                end
                nPdoPars = length(indsPdoParsToFit);

                % Formulate PDO if one is used and it has adjustable
                % parameters.
                if ~isempty(pars)&&nPdoPars>0
                    obj.pdoOptions.props.ParameterGuess(indsPdoParsToFit) = pars(nModelPars+1:end);
                    obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solutions.fsp); % call method to generate the PDO.
                end

                % If parameters are not provided, use the ones stored in the
                % SSIT object.
                if isempty(pars)
                    pars = [obj.parameters{indsParsToFit,2}];
                end

                % save original parameters for later recovery
                originalPars = obj.parameters;

                % remove duplicates from time span
                obj.tSpan = unique([obj.initialTime,obj.tSpan]);

                % Update Model and PDO parameters using supplied guess
                obj.parameters(indsParsToFit,2) =  num2cell(pars(1:nModelPars));

                % Solve model
                [solutions] = obj.solve;  % Solve the SSA analysis

                obj.parameters =  originalPars; % Reset back to the original parameters.
            end

            % If there is no logprior, use zero.
            if ~isempty(obj.fittingOptions.logPrior)
                logPrior = sum(obj.fittingOptions.logPrior(pars));
            else
                logPrior = 0;
            end

            if strcmp(obj.fittingOptions.timesToFit,'all')
                obj.fittingOptions.timesToFit = ones(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
            else
                timesToFit = zeros(1,length(obj.dataSet.app.ParEstFitTimesList.Value),'logical');
                timesToFit(obj.fittingOptions.timesToFit) = true;
                obj.fittingOptions.timesToFit = timesToFit;
            end


            dataTensor = obj.dataSet.app.DataLoadingAndFittingTabOutputs.dataTensor;
            timesData = dataTensor.subs(:,1);
            timesUnique = unique(timesData);

            % Map measurement times to the solution times.
            Jtime = zeros(1,length(obj.dataSet.times(obj.fittingOptions.timesToFit)));
            for it = 1:length(Jtime)
                [~,Jtime(it)] = min(abs(obj.tSpan-obj.dataSet.times(it)));
            end
            numTimes = length(Jtime);

            % Map measurement species to observed species;
            Jspecies = [];
            for is = 1:size(obj.dataSet.linkedSpecies,1)
                Jspecies = [Jspecies,find(strcmp(obj.species,obj.dataSet.linkedSpecies{is,1}))];
            end
            numSpecies = length(Jspecies);

            % Extract SSA solutions at data times.
            if isempty(obj.pdoOptions.PDO)
                ssaTrajs = solutions.trajs(Jspecies,Jtime,:);
            else
                ssaTrajs = solutions.trajsDistorted(Jspecies,Jtime,:);
            end

            % Find 1D Histograms for Data and Model
            Hdata = cell(numSpecies,numTimes);
            Hmod = cell(numSpecies,numTimes);
            for is = 1:numSpecies
                sumOver = [1:is-1,is+1:numSpecies];
                if isempty(sumOver)
                    dataVecP = full(dataTensor);
                else
                    dataVecP = sum(full(dataTensor),sumOver);
                end
                for it = 1:numTimes
                    % Find CDF of current species and time from
                    % data.
                    dataVecPt = double(dataVecP(it,:));
                    H = cumsum(dataVecPt);
                    Hdata{is,it} = H/H(end);

                    % Find CDF of current species and time from
                    % model.
                    if enforceIndependence
                        npe = obj.ssaOptions.nSimsPerExpt;
                        modelVec = squeeze(ssaTrajs(is,it,(it-1)*npe+1:it*npe));
                    else
                        modelVec = squeeze(ssaTrajs(is,it,:));
                    end
                    H = cumsum(histcounts(modelVec,[0:max(max(modelVec),length(H))]))';
                    Hmod{is,it}=H/H(end);

                    % Pad the shorter of the two vectors.
                    if length(Hdata{is,it})>length(Hmod{is,it})
                        Hmod{is,it}(end+1:length(Hdata{is,it})) = 1;
                    elseif length(Hdata{is,it})<length(Hmod{is,it})
                        Hdata{is,it}(end+1:length(Hmod{is,it})) = 1;
                    end
                end
            end

            if isa(lossFun,'function_handle')
                lossFunction = 0;
                for is = 1:numSpecies
                    for it = 1:numTimes
                        lossFunction = lossFunction + lossFun(Hmod{is,it},Hdata{is,it});
                    end
                end
            else

                switch lower(lossFun)
                    case 'cdf_one_norm'
                        lossFunction = 0;
                        for is = 1:numSpecies
                            for it = 1:numTimes
                                lossFunction = lossFunction + sum(abs(Hmod{is,it}-Hdata{is,it}));
                            end
                        end
                    case 'maxks'
                        lossFunction = 0;
                        for is = 1:numSpecies
                            for it = 1:numTimes
                                lossFunction = max(lossFunction,max(abs(Hmod{is,it}-Hdata{is,it})));
                            end
                        end
                    case ''

                    otherwise
                        error(['Loss function ''',lossFun,''' not defined'])
                end
            end
        end

        function fitErrors = likelihoodSweep(obj,parIndices,scalingRange,makePlot)
            % likelihoodSweep - sweep over range of parameters and return
            % likelihood function values at all parameter combinations.
            arguments
                obj
                parIndices
                scalingRange = linspace(0.5,1.5,15);
                makePlot = false
            end
            obj.fittingOptions.modelVarsToFit = parIndices;  % Choose which parameters to vary.
            pars0 = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];

            fspSoln = obj.solve();
            stateSpace = fspSoln.stateSpace;

            Ngrid=length(scalingRange);
            fitErrors = zeros(Ngrid,Ngrid);

            likeFunction = @(pars)obj.computeLikelihood(pars,stateSpace);
            for i = 1:Ngrid
                parfor j = 1:Ngrid
                    pars = pars0.*scalingRange([i,j]);
                    fitErrors(i,j) = likeFunction(pars);
                end
            end
            if makePlot
                fg = figure;
                set(0,'CurrentFigure',fg);
                if length(parIndices)>2
                    disp('plots are only created for first two parameters')
                end

                % Set minimum contour at -300
                lkhMin = max(fitErrors,[],'all')-300;
                contourf(scalingRange*pars0(1),scalingRange*pars0(2),max(fitErrors',lkhMin),30)
                set(gca,'fontsize',15)
                xlabel(obj.parameters{obj.fittingOptions.modelVarsToFit(1)});
                ylabel(obj.parameters{obj.fittingOptions.modelVarsToFit(2)});
                colorbar
                hold on

                [tmp,I] = max(fitErrors);
                [~,Jtime] = max(tmp);
                plot(scalingRange([1,Ngrid])*pars0(1),pars0(2)*[1,1],'k--','linewidth',3)
                plot(pars0(1)*[1,1],scalingRange([1,Ngrid])*pars0(2),'k--','linewidth',3)
                plot(pars0(1)*scalingRange(I(Jtime)),pars0(2)*scalingRange(Jtime),'ro','MarkerSize',20,'MarkerFaceColor','r')
            end
        end
        % WARNING: returns height of posterior instead of likelihood if priors are specified
        function [pars,likelihood,otherResults,obj] = maximizeLikelihood(obj,parGuess,fitOptions,fitAlgorithm)
            arguments
                obj
                parGuess = [];
                fitOptions = optimset('Display','iter','MaxIter',2000);
                fitAlgorithm = 'fminsearch';
            end
            % Compute the maximum likelihood estimate (if priors are not
            % provided) or the maximum posterior estimate (if priors are
            % provided).  

            % parse fitting options
            allFitOptions.suppressFSPExpansion = true;
            fNames = fieldnames(fitOptions);
            for i=1:length(fNames)
                allFitOptions.(fNames{i}) = fitOptions.(fNames{i});
            end

            if isempty(obj.propensitiesGeneral)
                obj = formPropensitiesGeneral(obj);
            end

            if ischar(obj.fittingOptions.modelVarsToFit)&&strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = (1:size(obj.parameters,1));
            end
            if isempty(parGuess)
                parGuess = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}]';
            end

            if strcmpi(obj.solutionScheme,'fspsens')   % Set solution scheme to FSP.
                obj.solutionScheme='FSP';
            end

            if strcmpi(obj.solutionScheme,'FSP')   % Set solution scheme to FSP.
                [FSPsoln,~,obj] = obj.solve;  % Solve the FSP analysis
                % obj.fspOptions.bounds = bounds;% Save bound for faster analyses
                if allFitOptions.suppressFSPExpansion
                    tmpFSPtol = obj.fspOptions.fspTol;
                    obj.fspOptions.fspTol = inf;
                end
                objFun = @(x)-obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
            elseif strcmpi(obj.solutionScheme,'ode')  % Set solution scheme to ode.
                objFun = @(x)-obj.computeLikelihoodODE(exp(x));  % We want to MAXIMIZE the likelihood.
            end

            x0 = log(parGuess);

            switch lower(fitAlgorithm)
                case 'fminsearch'
                    [x0,likelihood,~,otherResults]  = fminsearch(objFun,x0,allFitOptions);

                case 'fminunc'
                    obj.fspOptions.fspTol = inf;
                    objFun = @obj.minusLogL;  % We want to MAXIMIZE the likelihood.
                    x0 = log(parGuess);
                    [x0,likelihood]  = fminunc(objFun,x0,allFitOptions,FSPsoln.stateSpace,true);

                case 'particleswarm'
                    obj.fspOptions.fspTol=inf;
                    rng('shuffle')
                    OBJps = @(x)objFun(x');
                    LB = -5*ones(size(x0'));
                    UB = 5*ones(size(x0'));
                    initSwarm = repmat(x0',fitOptions.SwarmSize-1,1);
                    initSwarm = [x0';initSwarm.*(1+0.1*randn(size(initSwarm)))];
                    fitOptions.InitialSwarmMatrix = initSwarm;
                    [x0,likelihood] = particleswarm(OBJps,length(x0),LB,UB,allFitOptions);

                case 'mlsearch'
                    % Not yet working efficiently.
                    defaultFitOptions.maxIter=1000;
                    defaultFitOptions.burnIn=30;
                    defaultFitOptions.updateRate=10;
                    defaultFitOptions.guessRate=1000;
                    defaultFitOptions.proposalDistribution=@(x)x+0.01*randn(size(x));
                    defaultFitOptions.useFIMforSearch = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.plotFunVals = false;
                    defaultFitOptions.proposalDistributionWide=@(x)x+randn(size(x));

                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if allFitOptions.logForm
                        objFun = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = log(parGuess);
                    else
                        objFun = @(x)obj.computeLikelihood(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        x0 = (parGuess);
                    end

                    [x0,likelihood]  = mlSearch(objFun,x0,allFitOptions);

                case 'metropolishastings'

                    defaultFitOptions.isPropDistSymmetric=true;
                    defaultFitOptions.thin=1;
                    defaultFitOptions.numberOfSamples=1000;
                    defaultFitOptions.burnIn=0;
                    defaultFitOptions.progress=true;
                    defaultFitOptions.proposalDistribution=@(x)x+0.1*randn(size(x));
                    defaultFitOptions.numChains = 1;
                    defaultFitOptions.useFIMforMetHast = false;
                    defaultFitOptions.CovFIMscale = 0.6;
                    defaultFitOptions.suppressFSPExpansion = true;
                    defaultFitOptions.logForm = true;
                    defaultFitOptions.obj = [];

                    j=1;
                    while exist(['TMPmh_',num2str(j),'.mat'],'file')
                        j=j+1;
                    end
                    defaultFitOptions.saveFile = ['TMPmh_',num2str(j),'.mat'];

                    fNames = fieldnames(defaultFitOptions);
                    for i=1:length(fNames)
                        if ~isfield(allFitOptions,fNames{i})
                            allFitOptions.(fNames{i}) = defaultFitOptions.(fNames{i});
                        end
                    end

                    if isempty(allFitOptions.obj)
                        if allFitOptions.logForm
                            OBJmh = @(x)obj.computeLikelihood(exp(x),FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        else
                            OBJmh = @(x)OBJfun(x,FSPsoln.stateSpace);  % We want to MAXIMIZE the likelihood.
                        end
                    else
                        if allFitOptions.logForm
                            OBJmh = @(x)allFitOptions.obj(exp(x));
                        else
                            OBJmh = @(x)allFitOptions.obj(x);
                        end
                    end

                    if allFitOptions.logForm
                        x0 = log(parGuess);
                    else
                        x0 = (parGuess);
                    end

                    if allFitOptions.useFIMforMetHast
                        TMP = obj;
                        TMP.solutionScheme = 'fspSens'; % Set solutions scheme to FSP Sensitivity
                        [sensSoln] = TMP.solve;  % Solve the sensitivity problem

                        if allFitOptions.logForm
                            fimResults = TMP.computeFIM(sensSoln.sens,'log');
                        else
                            fimResults = TMP.computeFIM(sensSoln.sens);
                        end

                        % Call function to assemble full FIM from cell
                        % counts and prior covariance information.
                        if allFitOptions.logForm
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.logPriorCovariance);
                        else
                            FIM = TMP.evaluateExperiment(fimResults,TMP.dataSet.nCells,obj.fittingOptions.priorCovariance);
                        end

                        FIMfree = FIM{1}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);

                        if allFitOptions.logForm&&min(eig(FIMfree))<1
                            disp('Warning -- FIM has one or more small eigenvalues.  Reducing proposal width to 10x in those directions. MH Convergence may be slow.')
                            FIMfree = FIMfree + 1*eye(length(FIMfree));
                        end

                        covFree = FIMfree^-1;
                        covFree = allFitOptions.CovFIMscale*(covFree+covFree')/2;
                        allFitOptions.proposalDistribution=@(x)mvnrnd(x,covFree);
                    end

                    if allFitOptions.suppressFSPExpansion
                        obj.fspOptions.fspTol = inf;
                    end

                    rng('shuffle')
                    if allFitOptions.numChains==1
                        [otherResults.mhSamples,otherResults.mhAcceptance,otherResults.mhValue,x0,likelihood] = ...
                            ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                            'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,...
                            'symmetric',allFitOptions.isPropDistSymmetric,...
                            'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                            'progress',allFitOptions.progress,...
                            'saveFileName',allFitOptions.saveFile);
                    else
                        try
                            parpool
                        catch
                        end
                        allFitOptions.progress=0;
                        clear tmpMH*
                        parfor iChain = 1:allFitOptions.numChains
                            [mhSamples, mhAcceptance, mhValue,xbest,fbest] = ...
                                ssit.parest.metropolisHastingsSample(x0',allFitOptions.numberOfSamples,...
                                'logpdf',OBJmh,'proprnd',allFitOptions.proposalDistribution,'symmetric',...
                                allFitOptions.isPropDistSymmetric,...
                                'thin',allFitOptions.thin,'nchain',1,'burnin',allFitOptions.burnIn,...
                                'progress',allFitOptions.progress);
                            tmpMHSamp(iChain) = {mhSamples};
                            tmpMHAcceptance(iChain) = {mhAcceptance};
                            tmpMHValue(iChain) = {mhValue};
                            tmpMHxbest(iChain) = {xbest};
                            tmpMHfbest(iChain) = fbest;
                        end
                        [~,jBest] = max(tmpMHfbest);
                        x0 = tmpMHxbest{jBest}';
                        otherResults.mhSamples = tmpMHSamp;
                        otherResults.mhAcceptance = tmpMHAcceptance;
                        otherResults.mhValue = tmpMHValue;
                        clear tmpMH*
                    end
                    % If fit was in linear space, need to convert to log
                    % space before returning parameters.
                    if ~allFitOptions.logForm
                        pars = log(x0);
                    end

            end

            pars = exp(x0);

            if strcmp(obj.solutionScheme,'FSP')&&allFitOptions.suppressFSPExpansion
                obj.fspOptions.fspTol = tmpFSPtol;
            end

            if nargout>=4
                % Update best parameters set in returned model.
                obj.parameters(obj.fittingOptions.modelVarsToFit,2) = num2cell(pars);
            end


        end

        function [pars,minimumLossFunction,Results,obj] = runABCsearch(obj,parGuess,lossFunction,logPriorLoss,fitOptions,enforceIndependence)
            % This function runs an MCMC for approximate bayesian computing
            % (ABC) to sample an approximate posterior distribution.  
            % Parameters:
            %    parGuess -- ([]) initial guess of parameters.  If empty,
            %                the fit will start wit the current set of
            %                parameters in the model.
            %    lossFunction -- ('cdf_one_norm') choice of loss function
            %                or functionHandle. Positive values are WORSE
            %                fits.
            %    logPriorLoss -- (@(x)0) functionHandle that computes the
            %                initial loss function for a parameter guess,
            %                used to create a prior on parameters. The
            %                default (@(x)0) results in no prior.
            %    fitOptions -- ([]) options to use for parameter fitting.
            %    enforceIndependence -- (TRUE) flag to determine if SSA
            %                runs should be downsampled to guarantee that
            %                all model data points are independent of one
            %                another. 
            arguments
                obj
                parGuess = [] 
                lossFunction = 'cdf_one_norm';
                logPriorLoss = @(x)0; % Loss function applied to prior (e.g., -logNormal)
                fitOptions = [];
                enforceIndependence = false % Should SSA model be downsampled to guarantee independence?
            end

            if isempty(lossFunction)
                lossFunction = 'cdf_one_norm';
            end
            if isempty(logPriorLoss)
                logPriorLoss = @(x)0; % Loss function applied to prior (e.g., -logNormal)
            end

            % Because the MCMC will seek to maximize the provided function,
            % we need to take its negative before sending to the MH.
            fitOptions.obj = @(pars)-obj.computeLossFunctionSSA(lossFunction,pars,enforceIndependence) - logPriorLoss(pars);
            [pars,minimumLossFunction,Results] = obj.maximizeLikelihood(parGuess,fitOptions,'MetropolisHastings');


        end
        %% Model Reduction Functions
        function [obj,fspSoln] = computeModelReductionTransformMatrices(obj,fspSoln,phi)
            % This function computes linear transformation matrices (PHI
            % and PHIinv) that can be used to switch between the reduced
            % and origional FSP bases.
            arguments
                obj
                fspSoln = []
                phi = []
            end

            numConstraints = length(obj.fspOptions.bounds);

            if ~isfield(fspSoln,'stateSpace')
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                    % [~,IA] = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
                    % stoich = obj.stoichiometry(IA,:);
                    % init = obj.initialCondition(IA,:);
                else
                    stoich = obj.stoichiometry;
                    init = obj.initialCondition;
                end
                fspSoln.stateSpace = ssit.FiniteStateSet(init, stoich);
                fspSoln.stateSpace = fspSoln.stateSpace.expand(obj.fspConstraints.f, obj.fspConstraints.b);

            end

            % Assemble for generator matrix for original FSP problem.
            if ~isfield(fspSoln,'A_total')
                fspSoln.Afsp = ssit.FspMatrix(obj.propensitiesGeneral, [obj.parameters{:,2}]', fspSoln.stateSpace, numConstraints);
                if obj.useHybrid
                    error('Model reduction not currently available for time varying or hybrid system. Let us know if this is something you would like.')
                else
                    fspSoln.A_total = fspSoln.Afsp.createSingleMatrix(obj.tSpan(1), [obj.parameters{:,2}]');
                end
            end

            % Remove FSP Sinks
            fspSoln.A_total = fspSoln.A_total(1:end-numConstraints,1:end-numConstraints);

            % Call function to compute transformation matrices.
            [obj.modelReductionOptions.phi,...
                obj.modelReductionOptions.phi_inv,...
                obj.modelReductionOptions.phiScale,...
                obj.modelReductionOptions.phiPlot,...
                obj.modelReductionOptions.redOutputs] = ...
                ssit.fsp_model_reduction.getTransformMatrices(...
                obj.modelReductionOptions,...
                fspSoln);

            fspSoln.tOut = obj.tSpan;
            obj.modelReductionOptions.fspSoln=fspSoln;

        end

        function redSolutions = solveReducedFSP(obj)
            arguments
                obj
            end

            numConstraints = length(obj.fspOptions.bounds);
            stateCount = obj.modelReductionOptions.fspSoln.stateSpace.getNumStates();
            % Use Approximate steady state as initial distribution if requested.
            if obj.fspOptions.initApproxSS
                jac = obj.modelReductionOptions.fspSoln.A_total;
                jac = jac(1:end-numConstraints,1:end-numConstraints);
                jac = jac+diag(sum(jac));
                try
                    warning('off')
                    [eigVec,~] = eigs(jac,1,'smallestabs');
                catch
                    try
                        [eigVec,~] = eigs(jac,0);
                    catch
                        try
                            eigVec = null(full(jac));
                        catch
                            disp('Could not find null space. Using uniform.')
                            eigVec = ones(size(jac,1),1);
                        end
                    end
                end
                obj.modelReductionOptions.fspSoln.P0 = [eigVec/sum(eigVec);zeros(numConstraints,1)];
            else % otherwise use user supplied IC.
                obj.modelReductionOptions.fspSoln.P0  = zeros(stateCount + numConstraints, 1);
                obj.modelReductionOptions.fspSoln.P0(1:size(obj.initialCondition,2)) = obj.initialProbs;
            end

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 sys = ss(fspSoln.A_total,fspSoln.P0,eye(nStates),[]);
                %                 sysred = balred(sys,n,redOutputs.info);
                %                 A_red = sysred.A;
                %                 q0 = sysred.B;
                %                 OutPutC = sysred.C;
            else
                q0 = obj.modelReductionOptions.phi_inv*obj.modelReductionOptions.fspSoln.P0;
                A_red = obj.modelReductionOptions.phi_inv*...
                    obj.modelReductionOptions.fspSoln.A_total*...
                    obj.modelReductionOptions.phi;
            end

            fspErrorCondition.tInit = obj.modelReductionOptions.fspSoln.tOut(1);
            [~, ~, ~, ~, solutionsNow] = ssit.fsp_ode_solvers.expv_modified(...
                obj.modelReductionOptions.fspSoln.tOut(end), A_red, q0,...
                1e-8, 30,...
                [],...
                obj.modelReductionOptions.fspSoln.tOut,...
                1e-3, [],...
                obj.modelReductionOptions.fspSoln.tOut(1),...
                fspErrorCondition);

            if strcmp(obj.modelReductionOptions.reductionType,'Balanced Model Truncation (HSV)')
                %                 redSolutionsNow = solutionsNow*OutPutC';
            else
                redSolutionsNow = solutionsNow*obj.modelReductionOptions.phi';
                redSolutionsNow = diag(1./sum(redSolutionsNow,2))*redSolutionsNow;
            end

            for j=size(redSolutionsNow,1):-1:1
                redSolutions.fsp{j} = struct(time=obj.modelReductionOptions.fspSoln.tOut(j),...
                    p=ssit.FspVector(obj.modelReductionOptions.fspSoln.stateSpace.states,...
                    redSolutionsNow(j,1:stateCount)),...
                    sinks=[]);
            end
            redSolutions.stateSpace = obj.modelReductionOptions.fspSoln.stateSpace.states;
        end

        %% Plotting/Visualization Functions
        function makePlot(obj,solution,plotType,indTimes,includePDO,figureNums,...
                lineProps,movieName,maxY,movieSpecies,senseVars,plotTitle)
            %% SSIT.makePlot - Tool to make plot of the FSP or SSA results.
            % Inputs:
            %    * solution - struct with SSIT solutions
            %    * plotType - string, chosen type of plot:
            %       ** FSP options:
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'marginals' - marginal distributions over time
            %            'joints' - joint distributions vs time
            %       ** sensFSP options:
            %            'marginals' - sensitivity of marginal
            %                          distributions for each parameter
            %                          and time point
            %       ** SSA options:
            %            'means' - mean versus time
            %            'meansAndDevs' - means +/- STD vs time
            %            'trajectories' - set of individual trajectories
            %                             vs time
            %    * indTimes -
            %    * includePDO - boolean, include calibrated PDO
            %            default: false
            %    * figureNums -
            %    * lineProps -
            %    * movieName -
            %    * maxY -
            %    * movieSpecies -
            %    * senseVars -
            %    * plotTitle - string, title for plot
            %
            % Examples:
            %   F = SSIT('ToggleSwitch')
            %   F.solutionScheme = 'FSP'
            %   [FSPsoln,bounds] = F.solve;  % Returns the solution and the
            %                                % bounds for the FSP projection
            %   F.makePlot(FSPsoln,'marginals')  % Make plot of FSP
            %                                    % marginal distributions
            %
            %   F.solutionScheme = 'fspSens'
            %   [sensSoln,bounds] = F.solve;  % Returns the sensitivity and the
            %                                   bounds for the FSP projection
            %   F.makePlot(sensSoln,'marginals') % Make plot of sensitivities
            %                                      of marginal distributions
            %                                      at final time
            arguments
                obj
                solution
                plotType = 'means';
                indTimes = [];
                includePDO = false;
                figureNums = [];
                lineProps = {'linewidth',2};
                movieName = 'defaultMovie.mp4'
                maxY = []
                movieSpecies = []
                senseVars = []
                plotTitle = ''
            end
            if isempty(figureNums)
                h =  findobj('type','figure');
                if isfield(h,'Number')
                    figureNums = max([h.Number])+(1:10);
                else
                    figureNums = (1:10);
                end
            end
            if obj.useHybrid
                specNames = setdiff(obj.species,obj.hybridOptions.upstreamODEs,'stable');
            else
                specNames = obj.species;
            end

            kfig = 1;
            switch obj.solutionScheme
                case 'FSP'
                    app.FspTabOutputs.solutions = solution.fsp;
                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(app.FspTabOutputs.solutions)
                                app.FspTabOutputs.solutions{i}.p = obj.pdoOptions.PDO.computeObservationDist(app.FspTabOutputs.solutions{i}.p);
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end
                    app.FspPrintTimesField.Value = mat2str(obj.tSpan);
                    solution = exportFSPResults(app);
                    Nd = length(solution.Marginals{end});
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    Nt = length(indTimes);
                    switch plotType
                        case 'means'
                            plot(solution.T_array(indTimes),solution.Means(indTimes,:),lineProps{:});
                        case 'meansAndDevs'
                            fg = figure(figureNums(kfig)); set(0,'CurrentFigure',fg);
                            kfig=kfig+1;
                            for i = 1:Nd
                                subplot(Nd,1,i); hold on
                                errorbar(solution.T_array(indTimes),solution.Means(indTimes,i),sqrt(solution.Var(indTimes,i)),lineProps{:});
                                ylabel(specNames{i})
                            end
                            xlabel('time')
                        case 'marginals'
                            for j = 1:Nd
                                f = figure(figureNums(kfig)); kfig=kfig+1;
                                set(0,'CurrentFigure',f);
                                f.Name = ['Marginal Distributions of ',specNames{j}];
                                Nr = ceil(sqrt(Nt));
                                Nc = ceil(Nt/Nr);
                                for i = 1:Nt
                                    i2 = indTimes(i);
                                    subplot(Nr,Nc,i); hold on
                                    stairs(solution.Marginals{i2}{j},lineProps{:});
                                    set(gca,'fontsize',15)
                                    title(['t = ',num2str(solution.T_array(i2),2)])
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;
                            set(f,'Position',[ 1000         980         528         258])

                            if isempty(maxY)
                                maxY = -inf*ones(1,Nd);
                                for j = 1:Nd
                                    for i = 1:Nt
                                        maxY = max(maxY,max(solution.Marginals{i}{j}));
                                    end
                                end
                            end

                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    subplot(1,length(movieSpecies),j);
                                    bar([0:length(solution.Marginals{i}{movieSpecies(j)})-1],...
                                        solution.Marginals{i}{movieSpecies(j)},lineProps{:});
                                    set(gca,'fontsize',15,'ylim',[0,maxY(movieSpecies(j))])
                                    if isempty(plotTitle)
                                        title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    else
                                        title(sprintf('%s; t = %.0f', plotTitle, solution.T_array(i)))
                                    end

                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);

                        case 'joints'
                            if Nd<2
                                error('Joint distributions only avaialble for 2 or more species.')
                            else
                                for j1 = 1:Nd
                                    for j2 = j1+1:Nd
                                        h = figure(figureNums(kfig)); set(0,'CurrentFigure',h); kfig=kfig+1;
                                        h.Name = ['Joint Distribution of ',specNames{j1},' and ',specNames{j2}];
                                        Nr = ceil(sqrt(Nt));
                                        Nc = ceil(Nt/Nr);
                                        for i = 1:Nt
                                            i2 = indTimes(i);
                                            subplot(Nr,Nc,i);
                                            contourf(log10(max(1e-16,solution.Joints{i2}{j1,j2})));
                                            colorbar
                                            title(['t = ',num2str(solution.T_array(i2),2)])
                                            %                                             if mod(i-1,Nc)==0;
                                            ylabel(['x',num2str(j1)]);
                                            %                                             end
                                            %                                             if (i+Nc)>Nt;
                                            xlabel(['x',num2str(j2)]);
                                            %                                             end
                                            set(gca,'FontSize',15)
                                        end
                                    end
                                end
                            end
                        case 'escapeTimes'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            subplot(2,1,1)
                            z = solution.EscapeCDF(indTimes,:);
                            t = solution.T_array(indTimes);
                            plot(t,z,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape CDF')

                            subplot(2,1,2)
                            zp = (z(2:end,:)-z(1:end-1,:))./(t(2:end)-t(1:end-1))';
                            tp = (t(2:end)+t(1:end-1))/2;
                            plot(tp',zp,'linewidth',3); hold on
                            set(gca,'fontsize',16)
                            ylabel('Escape PDF')
                            xlabel('time')
                    end
                case 'SSA'
                    Nd = size(solution.trajs,1);
                    if isempty(indTimes)
                        indTimes = 1:length(solution.T_array);
                    end
                    switch plotType
                        case 'trajectories'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            for i=1:Nd
                                subplot(Nd,1,i)
                                plot(solution.T_array(indTimes),squeeze(solution.trajs(i,indTimes,:)));
                            end
                        case 'means'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            plot(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),lineProps{:});
                        case 'meansAndDevs'
                            f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                            vars = var(solution.trajs(:,indTimes,:),[],3);
                            errorbar(solution.T_array(indTimes),squeeze(mean(solution.trajs(:,indTimes,:),3)),sqrt(vars));
                    end
                case 'fspSens'

                    if includePDO
                        if ~isempty(obj.pdoOptions.PDO)
                            for i=1:length(solution.sens.data)
                                for j=1:length(solution.sens.data{i}.S)

                                    % Make sure defined PDO has sufficient input range.
                                    % tensorSizeSens = size(solution.sens.data{i}.S(j).data);
                                    % for iSp = 1:length(specNames)
                                    %     if tensorSizeSens(iSp)>size(obj.pdoOptions.PDO.conditionalPmfs{iSp},2)
                                    %         obj.pdoOptions.PDO = obj.generatePDO(obj.pdoOptions,[],solution.sens.data,true);
                                    %     end
                                    % end

                                    solution.sens.data{i}.S(j) = obj.pdoOptions.PDO.computeObservationDist(solution.sens.data{i}.S(j));
                                end
                            end
                        else
                            warning('obj.pdoOptions.PDO has not been set')
                        end
                    end

                    app.SensFspTabOutputs.solutions = solution.sens;
                    app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    app.ReactionsTabOutputs.varNames = specNames;
                    solution.plotable = exportSensResults(app);

                    Np = size(solution.plotable.sensmdist,1);
                    Nd = size(solution.plotable.sensmdist,2);
                    if isempty(indTimes)
                        if strcmp(plotType,'margmovie')
                            indTimes = solution.plotable.T_array;
                        else
                            indTimes = length(solution.plotable.T_array);
                        end
                    end
                    Nt = length(indTimes);
                    Nr = ceil(sqrt(Np));
                    Nc = ceil(Np/Nr);
                    switch plotType
                        case 'marginals'
                            for it = 1:Nt
                                it2 = indTimes(it);
                                for id = 1:Nd
                                    f = figure(figureNums(kfig)); set(0,'CurrentFigure',f); kfig=kfig+1;
                                    f.Name = ['Marg. Dist. Sensitivities of x',num2str(id),' at t=',num2str(solution.plotable.T_array(it2))];
                                    for j = 1:Np
                                        subplot(Nr,Nc,j); hold on;
                                        stairs(solution.plotable.sensmdist{j,id,it2},lineProps{:});
                                        set(gca,'fontsize',15)
                                        title(obj.parameters{j,1})
                                        %                                         if mod(j-1,Nc)==0;
                                        ylabel(['sensitivity']);
                                        %                                         end
                                        %                                         if (j+Nc)>Np;
                                        xlabel(['x',num2str(id)]);
                                        %                                         end
                                    end
                                end
                            end
                        case 'margmovie'
                            f = figure(figureNums(1)); set(0,'CurrentFigure',f); clf;
                            set(f,'Position',[ 1000         985         419         253])

                            if isempty(maxY)
                                maxY = [inf*ones(1,Nd);-inf*ones(1,Nd)];
                                for j = 1:Nd
                                    for i = 1:Nt
                                        for k = 1:size(solution.plotable.sensmdist,2)
                                            maxY(1,j) = min(maxY(1,j),min(solution.plotable.sensmdist{k,j,i}));
                                            maxY(2,j) = max(maxY(2,j),max(solution.plotable.sensmdist{k,j,i}));
                                        end
                                    end
                                end
                            end

                            if isempty(senseVars)
                                senseVars = [1:size(obj.parameters,1)];
                            end

                            mov = VideoWriter(movieName,'MPEG-4');
                            open(mov);

                            if isempty(movieSpecies)
                                movieSpecies = [1:Nd];
                            end

                            for i = 1:Nt
                                for j = 1:length(movieSpecies)
                                    for k = 1:length(senseVars)
                                        jPlot = (k-1)*length(movieSpecies)+j;
                                        subplot(length(senseVars),length(movieSpecies),jPlot);
                                        bar([0:length(solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i})-1],...
                                            solution.plotable.sensmdist{senseVars(k),movieSpecies(j),i},lineProps{:});
                                        set(gca,'fontsize',15,'ylim',[maxY(1,movieSpecies(j)),maxY(2,movieSpecies(j))])
                                        % title([obj.species{movieSpecies(j)},'; t = ',num2str(solution.T_array(i),'%.0f')])
                                    end
                                end
                                writeVideo(mov,getframe(f))
                            end
                            close(mov)
                            disp(['Movie saved as ', movieName]);


                    end
            end
        end

        function plotODE(obj,speciesNames,timeVec,lineProps,opts)
            arguments
                obj
                speciesNames = []                  
                timeVec = []
                lineProps = {'linewidth',2};
                opts.Title (1,1) string = ""
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
                opts.Colors = []  
                % [] | n×3 RGB | cell of ColorSpec/RGB | colormap name string
            end
        
            X = obj.Solutions.ode;  % [nTime × nSpecies]
            [nTime, nSpecies] = size(X);
        
            % ----- timeVec -----
            if isempty(timeVec)
                timeVec = (1:nTime).';
            else
                if numel(timeVec) ~= nTime
                    error('timeVec length (%d) must match number of ODE time points (%d).', numel(timeVec), nTime);
                end
                timeVec = timeVec(:);
            end
        
            % ----- Species selection -----
            allNames = obj.species;
            if isstring(allNames), allNames = cellstr(allNames); end
        
            if isempty(speciesNames)
                selIdx = 1:nSpecies;
                selNames = allNames;
            elseif isnumeric(speciesNames)
                selIdx = speciesNames(:).';
                if any(selIdx < 1 | selIdx > nSpecies) || numel(unique(selIdx)) ~= numel(selIdx)
                    error('Invalid or duplicate species indices. Must be unique integers in [1,%d].', nSpecies);
                end
                selNames = allNames(selIdx);
            else
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    exampleList = strjoin(allNames, ', ');
                    error('Unknown species name(s): %s. Available: %s', strjoin(bad, ', '), exampleList);
                end
                selIdx = loc(:).';
                selNames = allNames(selIdx);
            end
        
            nPlot = numel(selIdx);
        
            % ----- Colors -----
            useCellColors = false;
            C = [];          % numeric nPlot×3
            cellColors = {}; % 1×nPlot cell for mixed ColorSpecs
        
            if isempty(opts.Colors)
                C = lines(nPlot);
            elseif ischar(opts.Colors) || (isstring(opts.Colors) && isscalar(opts.Colors))
                cmName = char(opts.Colors);
                try
                    % Sample the colormap to exactly nPlot colors
                    bigN = max(nPlot, 64);
                    cm = feval(cmName, bigN);
                    idx = round(linspace(1, bigN, nPlot));
                    C = cm(idx, :);
                catch
                    error('opts.Colors="%s" is not a valid colormap name.', cmName);
                end
            elseif isnumeric(opts.Colors)
                C = double(opts.Colors);
                if size(C,2) ~= 3 || size(C,1) < nPlot
                    error('opts.Colors numeric must be at least %d×3 RGB values.', nPlot);
                end
                if any(C(:) < 0 | C(:) > 1) || ~all(isfinite(C(:)))
                    error('opts.Colors numeric RGB values must be finite and in [0,1].');
                end
                C = C(1:nPlot, :);
            elseif iscell(opts.Colors)
                if numel(opts.Colors) < nPlot
                    error('opts.Colors cell must provide at least %d entries.', nPlot);
                end
                cellColors = cell(1,nPlot);
                for k = 1:nPlot
                    c = opts.Colors{k};
                    if ischar(c) || (isstring(c) && isscalar(c))
                        cellColors{k} = char(c);              
                    elseif isnumeric(c) && isequal(size(c), [1,3])
                        if any(c < 0 | c > 1) || ~all(isfinite(c))
                            error('opts.Colors{%d}: RGB must be finite in [0,1].', k);
                        end
                        cellColors{k} = double(c);
                    else
                        error('opts.Colors{%d} must be a ColorSpec char or a 1×3 RGB vector.', k);
                    end
                end
                useCellColors = true;
            else
                error('opts.Colors must be: [], an n×3 RGB matrix, a cell array of colors, or a colormap name string.');
            end
        
            % ----- Plot -----
            figure; hold on;
            for k = 1:nPlot
                s = selIdx(k);
                if useCellColors
                    thisColor = cellColors{k};
                else
                    thisColor = C(k, :);
                end
                plot(timeVec, X(:, s), lineProps{:}, 'Color', thisColor);
            end
        
            ax = gca;
            ax.FontSize = opts.TickLabelSize;
        
            if ~isempty(opts.XLim), xlim(opts.XLim); end
            if ~isempty(opts.YLim), ylim(opts.YLim); end
        
            xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
            ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
        
            if ~isempty(opts.Title)
                title(opts.Title,'FontSize',opts.TitleFontSize);
            else
                title('ODE Solution Trajectories','FontSize',opts.TitleFontSize);
            end
            grid on; box on;
        
            if ~strcmpi(opts.LegendLocation,"none")
                lgd = legend(selNames, 'Location', char(opts.LegendLocation));
                if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
            end
            hold off;
        end


        % plotSSA - Plots SSA trajectories and histograms from ssaSoln struct
        function plotSSA(obj,speciesIdx,numTraj,speciesNames,lineProps,opts)
            arguments
                obj
                speciesIdx = []                     
                numTraj = []                % [] -> min(10, numTotalTraj)
                speciesNames = []             
                lineProps = {'linewidth',2};        
                opts.Title (1,1) string = ""
                opts.MeanOnly (1,1) logical = false
                opts.HistTime double = 100  % histogram time (closest used)
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
                opts.Colors = []      
                % [] | species ×3 RGB | cell array | colormap name               
            end
        
            % ----- Extract SSA solution & sizes -----
            ssaSoln = obj.Solutions;
            numSpecies    = size(ssaSoln.trajs, 1);
            nTime         = size(ssaSoln.trajs, 2);
            numTotalTraj  = size(ssaSoln.trajs, 3);
        
            % ----- Number of trajectories to draw -----
            if isempty(numTraj)
                numTraj = min(10, numTotalTraj);
            else
                numTraj = min(numTraj, numTotalTraj);
            end
        
            % ----- Species master names -----
            allNames = obj.species;
            if isempty(allNames)
                allNames = arrayfun(@(s) sprintf('Species %d', s), 1:numSpecies, 'UniformOutput', false);
            end
            if isstring(allNames), allNames = cellstr(allNames); end
        
            % ----- Select species by names (priority) or indices -----
            if ~isempty(speciesNames)
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    error('Unknown species name(s): %s. Available: %s', strjoin(bad, ', '), strjoin(allNames, ', '));
                end
                spList = loc(:).';
                selNames = allNames(spList);
            else
                if ischar(speciesIdx) || (isstring(speciesIdx) && isscalar(speciesIdx))
                    if strcmpi(char(speciesIdx), 'all')
                        spList = 1:numSpecies;
                    else
                        error('speciesIdx string must be "all" or provide a numeric vector.');
                    end
                elseif isempty(speciesIdx)
                    spList = 1:numSpecies;
                elseif isnumeric(speciesIdx)
                    spList = unique(speciesIdx(:)).';
                    if any(spList < 1 | spList > numSpecies)
                        error('speciesIdx must be within 1..%d, or "all".', numSpecies);
                    end
                else
                    error('speciesIdx must be a numeric vector or "all".');
                end
                selNames = allNames(spList);
            end
            nSel = numel(spList);
        
            % ----- Time vector & valid window -----
            Tfull = ssaSoln.T_array(:);         % full time vector
            validIdx = Tfull >= 0;              % adjust as needed
            T = Tfull(validIdx);
        
            % Histogram time index (closest to opts.HistTime)
            if isempty(opts.HistTime) || ~isfinite(opts.HistTime)
                histTarget = 100;
            else
                histTarget = opts.HistTime;
            end
            [~, tHist_idx] = min(abs(Tfull - histTarget));
        
            % ----- Colors for selected species -----
            C = []; useCellColors = false; cellColors = {};
            if isempty(opts.Colors)
                C = lines(nSel);
            elseif ischar(opts.Colors) || (isstring(opts.Colors) && isscalar(opts.Colors))
                cmName = char(opts.Colors);
                bigN = max(nSel, 64);
                try
                    cm = feval(cmName, bigN);
                catch
                    error('opts.Colors="%s" is not a valid colormap name.', cmName);
                end
                idx = round(linspace(1, bigN, nSel));
                C = cm(idx, :);
            elseif isnumeric(opts.Colors)
                C = double(opts.Colors);
                if size(C,2) ~= 3 || size(C,1) < nSel
                    error('opts.Colors numeric must be at least %d×3 RGB.', nSel);
                end
                if any(~isfinite(C(:)) | C(:) < 0 | C(:) > 1)
                    error('opts.Colors RGB must be finite in [0,1].');
                end
                C = C(1:nSel, :);
            elseif iscell(opts.Colors)
                if numel(opts.Colors) < nSel
                    error('opts.Colors cell must provide at least %d entries.', nSel);
                end
                cellColors = cell(1,nSel);
                for k = 1:nSel
                    c = opts.Colors{k};
                    if ischar(c) || (isstring(c) && isscalar(c))
                        cellColors{k} = char(c);
                    elseif isnumeric(c) && isequal(size(c), [1,3]) && all(isfinite(c)) && all(c>=0 & c<=1)
                        cellColors{k} = double(c);
                    else
                        error('opts.Colors{%d} must be ColorSpec char or 1×3 RGB.', k);
                    end
                end
                useCellColors = true;
            else
                error('opts.Colors must be: [], colormap name, n×3 RGB, or cell array.');
            end
        
            % Helper: lighten color toward white (simulate transparency)
            function lc = lighten(baseRGB, alpha)
                lc = (1 - alpha)*[1 1 1] + alpha*baseRGB;
            end
        
            % ----- TRAJECTORY PLOT -----
            figure; hold on;
            legendEntries = cell(1, nSel);
            legendHandles = gobjects(1, nSel);
        
            randIdx = randperm(numTotalTraj, numTraj);
        
            for j = 1:nSel
                s = spList(j);
                        
                if useCellColors
                    baseColor = cellColors{j};
                else
                    baseColor = C(j, :);
                end
        
                if ~opts.MeanOnly
                    trajColor = baseColor;
                    if isnumeric(baseColor)
                        trajColor = lighten(baseColor, 0.25); % lighter lines for single trajectories
                    end
                    Xs = squeeze(ssaSoln.trajs(s, validIdx, :));
                    for i = 1:numTraj
                        plot(T, Xs(:, randIdx(i)), 'LineWidth', 0.75, 'Color', trajColor, ...
                             'HandleVisibility', 'off');
                    end
                end
        
                Xs_full = squeeze(ssaSoln.trajs(s, validIdx, :));
                h = plot(T, mean(Xs_full, 2), lineProps{:}, 'Color', baseColor);
                legendHandles(j) = h;
                legendEntries{j} = selNames{j};
            end
        
            % ----- Axes styling -----
            ax = gca; ax.FontSize = opts.TickLabelSize;
            xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
            ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
        
            % ----- Title -----
            if strlength(opts.Title) > 0
                title(string(opts.Title), 'FontSize', opts.TitleFontSize);
            else
                if nSel == numSpecies
                    title('SSA Trajectories (Starting at t = 0)', 'FontSize', opts.TitleFontSize);
                elseif nSel == 1
                    title(sprintf('SSA Trajectories for %s (Starting at t = 0)', selNames{1}), 'FontSize', opts.TitleFontSize);
                else
                    title('SSA Trajectories for Selected Species (Starting at t = 0)', 'FontSize', opts.TitleFontSize);
                end
            end
        
            % ----- Axes limits -----
            if ~isempty(opts.XLim), xlim(opts.XLim); end
            if ~isempty(opts.YLim), ylim(opts.YLim); end
        
            % ----- Legend -----
            if ~strcmpi(opts.LegendLocation, "none")
                lgd = legend(legendHandles, legendEntries, 'Location', char(opts.LegendLocation));
                if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
            end
            grid on; box on; hold off;
        
            % ----- HISTOGRAM PLOT(S) at t ≈ opts.HistTime -----
            figure;
            if nSel > 1
                numPanels = nSel;
                numRows = ceil(sqrt(numPanels));
                numCols = ceil(numPanels / numRows);
                for j = 1:nSel
                    s = spList(j);
                    subplot(numRows, numCols, j);
                    X_t = squeeze(ssaSoln.trajs(s, tHist_idx, :));
                    if useCellColors
                        fc = cellColors{j};
                        if ischar(fc), fc = C(j,:); end
                    else
                        fc = C(j, :);
                    end
                    histogram(X_t, 'FaceColor', fc, 'EdgeColor', 'k');
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(sprintf('Molecule Count (%s)', selNames{j}), 'FontSize', opts.AxisLabelSize);
                    ylabel('Frequency', 'FontSize', opts.AxisLabelSize);
                    title(sprintf('Distribution at t ≈ %.2f (%s)', Tfull(tHist_idx), selNames{j}), 'FontSize', opts.TitleFontSize);
                    grid on; box on;
                end
            else
                j = 1; s = spList(j);
                X_t = squeeze(ssaSoln.trajs(s, tHist_idx, :));
                if useCellColors
                    fc = cellColors{j};
                    if ischar(fc), fc = C(j,:); end
                else
                    fc = C(j, :);
                end
                histogram(X_t, 'FaceColor', fc, 'EdgeColor', 'k');
                ax = gca; ax.FontSize = opts.TickLabelSize;
                xlabel(sprintf('Molecule Count (%s)', selNames{j}), 'FontSize', opts.AxisLabelSize);
                ylabel('Frequency', 'FontSize', opts.AxisLabelSize);
                title(sprintf('Distribution at t ≈ %.2f (%s)', Tfull(tHist_idx), selNames{j}), 'FontSize', opts.TitleFontSize);
                grid on; box on;
            end
        end
            
         function plotFSP(obj, solution, speciesNames, plotType, indTimes, figureNums, lineProps, opts)
            % plotFSP — Plot FSP results like plotODE/plotSSA, with species subsetting
            arguments
                obj
                solution
                speciesNames = []
                plotType (1,1) string = "means"
                indTimes = []
                figureNums = []
                lineProps = {'linewidth',2}
                opts.SpeciesIdx = []
                opts.Colors = []
                opts.Title (1,1) string = ""
                opts.TitleFontSize (1,1) double {mustBePositive} = 18
                opts.AxisLabelSize (1,1) double {mustBePositive} = 18
                opts.TickLabelSize (1,1) double {mustBePositive} = 18
                opts.LegendFontSize (1,1) double {mustBePositive} = 18
                opts.LegendLocation (1,1) string = "best"
                opts.XLabel (1,1) string = "Time"
                opts.YLabel (1,1) string = "Molecule Count / Concentration"
                opts.XLim double = []
                opts.YLim double = []
            end
        
            % ----- Species selection -----
            nSpecies = numel(obj.species);
            allNames = obj.species;
            if isstring(allNames), allNames = cellstr(allNames); end
        
            if isempty(speciesNames) && isempty(opts.SpeciesIdx)
                selIdx = 1:nSpecies;
                selNames = allNames;
            elseif ~isempty(opts.SpeciesIdx)
                selIdx = unique(opts.SpeciesIdx(:).');
                if any(selIdx < 1 | selIdx > nSpecies)
                    error('opts.SpeciesIdx must be in 1..%d', nSpecies);
                end
                selNames = allNames(selIdx);
            elseif isnumeric(speciesNames)
                selIdx = unique(speciesNames(:).');
                if any(selIdx < 1 | selIdx > nSpecies)
                    error('speciesNames (indices) must be in 1..%d', nSpecies);
                end
                selNames = allNames(selIdx);
            else
                if isstring(speciesNames), speciesNames = cellstr(speciesNames); end
                [tf, loc] = ismember(speciesNames, allNames);
                if any(~tf)
                    bad = speciesNames(~tf);
                    error('Unknown species name(s): %s. Available: %s', ...
                          strjoin(bad, ', '), strjoin(allNames, ', '));
                end
                selIdx = loc(:).';
                selNames = allNames(selIdx);
            end
            nSel = numel(selIdx);
        
            % ----- Export FSP to plottable struct -----
            rawSol = solution;   % <- copy to compute escape CDF if needed
            app.FspTabOutputs.solutions = solution.fsp;
            app.FspPrintTimesField.Value = mat2str(obj.tSpan);
            solution = exportFSPResults(app);
        
            % Time selection
            if isempty(indTimes), indTimes = 1:length(solution.T_array); end
            Nt = numel(indTimes);
        
            % ----- Figure numbers -----
            if isempty(figureNums)
                h = findobj('type','figure');
                if ~isempty(h)
                    figureNums = max([h.Number])+(1:10);
                else
                    figureNums = (1:10);
                end
            end
            kfig = 1;
        
            % ----- Colors for selected series -----
            C = resolveColors(opts.Colors, nSel);  % nSel×3 or cell of nSel entries
        
            switch plotType
                case 'means'
                    figure(figureNums(kfig)); clf; kfig=kfig+1; hold on
                    hMean = gobjects(1, nSel);
                    tt = solution.T_array(indTimes);
                    for j = 1:nSel
                        s = selIdx(j);
                        col = getC(C, j);
                        hMean(j) = plot(tt, solution.Means(indTimes, s), ...
                                        lineProps{:}, 'Color', col, ...
                                        'DisplayName', selNames{j});
                    end
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hMean, selNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title)>0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('FSP Means', 'FontSize', opts.TitleFontSize);
                    end
                    grid on; box on; hold off;
        
                case 'meansAndDevs'
                    figure(figureNums(kfig)); clf; kfig=kfig+1; hold on
                    hMean = gobjects(1, nSel);                 % handles for legend
                
                    tt = solution.T_array(indTimes);
                    for j = 1:nSel
                        s  = selIdx(j);
                        mu = solution.Means(indTimes, s);
                        sd = sqrt(max(0, solution.Var(indTimes, s)));
                        col = getC(C, j);
                
                        % mean line (legend handle)
                        hMean(j) = plot(tt, mu, lineProps{:}, 'Color', col, ...
                                         'DisplayName', selNames{j});
                
                        % std bars (keep out of legend)
                        eb = errorbar(tt, mu, sd, 'LineStyle','none');
                        eb.Color = col;
                        eb.HandleVisibility = 'off';
                    end
                
                    % axes + labels
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel(opts.YLabel, 'FontSize', opts.AxisLabelSize);
                
                    % legend with mean lines only (one entry per species)
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hMean, selNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title)>0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('FSP Means ± SD', 'FontSize', opts.TitleFontSize);
                    end
                    grid on; box on; hold off;
        
                case 'marginals'
                    for jj = 1:nSel
                        s = selIdx(jj);
                        f = figure(figureNums(kfig)); clf; kfig=kfig+1;
                        f.Name = ['Marginal Distributions of ', selNames{jj}];
                        Nr = ceil(sqrt(Nt)); Nc = ceil(Nt/Nr);
                
                        for ii = 1:Nt
                            i2 = indTimes(ii);
                            pmf = solution.Marginals{i2}{s}(:);
                            x = 0:numel(pmf)-1;
                
                            % Optional crop to XLim (for performance and cleaner view)
                            if ~isempty(opts.XLim)
                                mask = (x >= opts.XLim(1)) & (x <= opts.XLim(2));
                                xPlot = x(mask);
                                yPlot = pmf(mask);
                            else
                                xPlot = x;
                                yPlot = pmf;
                            end
                
                            subplot(Nr, Nc, ii); hold on
                            stairs(xPlot, yPlot, lineProps{:}, 'Color', getC(C,jj));
                            set(gca,'FontSize',opts.TickLabelSize)
                            title(sprintf('t = %.3g', solution.T_array(i2)), ...
                                  'FontSize', max(opts.TitleFontSize-2,8))
                            xlabel(sprintf('%s count', selNames{jj}), 'FontSize', opts.AxisLabelSize-2);
                            ylabel('Probability', 'FontSize', opts.AxisLabelSize-2);
                
                            % Apply limits if provided
                            if ~isempty(opts.XLim), xlim(opts.XLim); end
                            if ~isempty(opts.YLim), ylim(opts.YLim); end
                
                            grid on; box on;
                        end
                
                        sgtitle(sprintf('Marginal Distributions — %s', selNames{jj}), ...
                                'FontSize', opts.TitleFontSize);
                    end
        
                case 'joints'
                    if nSel < 2
                        error('Joint distributions only available when 2 or more species are selected.');
                    end
                    for a = 1:nSel
                        for b = a+1:nSel
                            s1 = selIdx(a); s2 = selIdx(b);
                            h = figure(figureNums(kfig)); clf; kfig=kfig+1;
                            h.Name = sprintf('Joint Distribution of %s and %s', selNames{a}, selNames{b});
                            Nr = ceil(sqrt(Nt)); Nc = ceil(Nt/Nr);
                            for ii = 1:Nt
                                i2 = indTimes(ii);
                                subplot(Nr,Nc,ii);
                                contourf(log10(max(1e-16, solution.Joints{i2}{s1,s2})));
                                colorbar
                                title(sprintf('t = %.3g', solution.T_array(i2)), 'FontSize', max(opts.TitleFontSize-2,8))
                                ylabel(selNames{a}); xlabel(selNames{b});
                                set(gca,'FontSize',opts.TickLabelSize)
                            end
                        end
                    end

                case 'escapeTimes'
                    % ---- Gather times ----
                    tt = solution.T_array(:);
                    if isempty(indTimes), indTimes = 1:numel(tt); end
                    t  = tt(indTimes);
                
                    % ---- Get names for sinks (legend labels) ----
                    sinkNames = {};
                    try
                        sinkNames = obj.fspOptions.escapeSinks.f;
                        if isstring(sinkNames), sinkNames = cellstr(sinkNames); end
                        if ~iscell(sinkNames), sinkNames = {}; end
                    catch
                        sinkNames = {};
                    end
                
                    % ---- Get Escape CDF matrix [Nt x nSinks] ----
                    if isfield(solution, 'EscapeCDF') && ~isempty(solution.EscapeCDF)
                        Z_all = solution.EscapeCDF;                 % Nt x nSinks
                        if isvector(Z_all), Z_all = Z_all(:); end   % ensure 2D
                        Z = Z_all(indTimes, :);
                    else
                        % Build per-sink CDF from raw FSP (supports multiple sinks)
                        [t_raw, Z_raw] = computeEscapeCDFFromRawMulti(rawSol);   % Nt x nSinks
                        % align to exported times if needed
                        if numel(t_raw) ~= numel(tt)
                            Z = interp1(t_raw, Z_raw, tt, 'previous', 'extrap');
                        else
                            Z = Z_raw;
                        end
                        Z = Z(indTimes, :);
                    end
                
                    % ---- Clean & clamp ----
                    Z(~isfinite(Z)) = 0;
                    Z = max(0, min(1, Z));       % keep in [0,1]
                    nSinks = size(Z,2);
                    if isempty(sinkNames) || numel(sinkNames) ~= nSinks
                        sinkNames = arrayfun(@(k) sprintf('Sink %d', k), 1:nSinks, 'UniformOutput', false);
                    end
                
                    % ---- Colors: one per sink ----
                    C = resolveColors(opts.Colors, nSinks);
                
                    % ---- Compute PDFs per sink via finite differences ----
                    if numel(t) >= 2
                        dt  = max(eps, t(2:end) - t(1:end-1));
                        tp  = (t(2:end) + t(1:end-1))/2;
                        dZ  = Z(2:end, :) - Z(1:end-1, :);
                        Zp  = dZ ./ dt;             % [Nt-1 x nSinks]
                    else
                        tp = t; Zp = zeros(numel(t), nSinks);
                    end
                
                    % ---- Plot: CDF (top) ----
                    figure(figureNums(kfig)); clf; kfig = kfig+1;
                    subplot(2,1,1); hold on
                    hC = gobjects(1, nSinks);
                    for k = 1:nSinks
                        col = getC(C, k);
                        hC(k) = plot(t, Z(:,k), lineProps{:}, 'Color', col, 'DisplayName', sinkNames{k});
                    end
                    grid on; box on;
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel('Escape CDF', 'FontSize', opts.AxisLabelSize);
                    if ~strcmpi(opts.LegendLocation, "none")
                        lgd = legend(hC, sinkNames, 'Location', char(opts.LegendLocation));
                        if ~isempty(lgd), lgd.FontSize = opts.LegendFontSize; end
                    end
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end
                    if strlength(opts.Title) > 0
                        title(string(opts.Title), 'FontSize', opts.TitleFontSize);
                    else
                        title('Escape / First-Passage CDF', 'FontSize', opts.TitleFontSize);
                    end
                
                    % ---- Plot: PDF (bottom) ----
                    subplot(2,1,2); hold on
                    for k = 1:nSinks
                        col = getC(C, k);
                        plot(tp, Zp(:,k), lineProps{:}, 'Color', col);
                    end
                    grid on; box on;
                    ax = gca; ax.FontSize = opts.TickLabelSize;
                    xlabel(opts.XLabel, 'FontSize', opts.AxisLabelSize);
                    ylabel('Escape PDF', 'FontSize', opts.AxisLabelSize);
                    if ~isempty(opts.XLim), xlim(opts.XLim); end
                    if ~isempty(opts.YLim), ylim(opts.YLim); end

                case 'fspSens'
                    % ----- Build plottable sensitivity results (same as before) -----
                    app.SensFspTabOutputs.solutions = solution.sens;
                    app.SensPrintTimesEditField.Value = mat2str(obj.tSpan);
                    if ~isempty(obj.parameters)
                        app.ReactionsTabOutputs.parameters = obj.parameters(:,1);
                    else
                        app.ReactionsTabOutputs.parameters = [];
                    end
                    % Use the same species names you already computed (selIdx/selNames)
                    app.ReactionsTabOutputs.varNames = obj.species;  % exporter expects all; we subset below
                    solution.plotable = exportSensResults(app);
                
                    % Dimensions
                    Np = size(solution.plotable.sensmdist,1);      % # parameters
                    Nd_all = size(solution.plotable.sensmdist,2);  % # species in export
                
                    % Time selection
                    if isempty(indTimes)
                        indTimes = 1:length(solution.plotable.T_array);
                    end
                    Nt = numel(indTimes);
                
                    % Figure numbering
                    if isempty(figureNums)
                        h = findobj('type','figure');
                        if ~isempty(h)
                            figureNums = max([h.Number])+(1:10);
                        else
                            figureNums = (1:10);
                        end
                    end
                    kfig = 1;
                
                    % Colors: one per selected species (like 'marginals')
                    C = resolveColors(opts.Colors, numel(selIdx));
                
                    % Grid layout over parameters
                    Nr = ceil(sqrt(Np));
                    Nc = ceil(Np/Nr);
                
                    % ----- Plot: for each selected species and selected time -----
                    for jj = 1:numel(selIdx)
                        s = selIdx(jj);                            % species index in exported arrays
                        spName = selNames{jj};
                        col = getC(C, jj);
                
                        for ii = 1:Nt
                            it2 = indTimes(ii);
                            f = figure(figureNums(kfig)); clf; kfig = kfig+1;
                            f.Name = sprintf('Sensitivity of Marginals — %s @ t=%.3g', spName, solution.plotable.T_array(it2));
                
                            for j = 1:Np
                                subplot(Nr, Nc, j); hold on;
                
                                % Sensitivity vector for parameter j, species s, time it2
                                sv = solution.plotable.sensmdist{j, s, it2};
                                if isempty(sv), sv = 0; end
                                sv = sv(:);
                                x = 0:numel(sv)-1;
                
                                % Optional crop to XLim (like 'marginals')
                                if ~isempty(opts.XLim)
                                    mask = (x >= opts.XLim(1)) & (x <= opts.XLim(2));
                                    xPlot = x(mask);
                                    yPlot = sv(mask);
                                else
                                    xPlot = x;
                                    yPlot = sv;
                                end
                
                                stairs(xPlot, yPlot, lineProps{:}, 'Color', col);
                
                                % Axes styling
                                ax = gca; ax.FontSize = opts.TickLabelSize;
                                if ~isempty(opts.XLim), xlim(opts.XLim); end
                                if ~isempty(opts.YLim), ylim(opts.YLim); end
                                grid on; box on;
                
                                % Subplot title: parameter name
                                try
                                    pName = obj.parameters{j,1};
                                    if isstring(pName), pName = char(pName); end
                                catch
                                    pName = sprintf('Param %d', j);
                                end
                                title(pName, 'FontSize', max(opts.TitleFontSize-4, 8));
                
                                % Axis labels per subplot (smaller fonts like 'marginals')
                                xlabel(sprintf('%s count', spName), 'FontSize', max(opts.AxisLabelSize-2, 8));
                                ylabel('Sensitivity', 'FontSize', max(opts.AxisLabelSize-2, 8));
                            end
                
                            % Figure-level title (like sgtitle in 'marginals')
                            if strlength(opts.Title) > 0
                                sgtitle(string(opts.Title), 'FontSize', opts.TitleFontSize);
                            else
                                sgtitle(sprintf('Marginal Sensitivities — %s (t = %.3g)', spName, solution.plotable.T_array(it2)), ...
                                        'FontSize', opts.TitleFontSize);
                            end
                        end
                    end

                otherwise
                    error('Unknown plotType "%s". Use: "means", "meansAndDevs", "marginals", or "joints".', plotType);
            end
        
            % ---------- helpers ----------
            function C = resolveColors(userC, n)
                if isempty(userC)
                    C = lines(n); 
                    return
                end
            
                % Colormap name
                if ischar(userC) || (isstring(userC) && isscalar(userC))
                    cm = feval(char(userC), max(n,64));
                    C  = cm(round(linspace(1,size(cm,1),n)),:);
                    return
                end
            
                % Numeric: RGB row(s)
                if isnumeric(userC)
                    userC = double(userC);
                    if isvector(userC) && numel(userC)==3
                        C = repmat(userC(:).', n, 1);       % replicate single RGB to n rows
                        return
                    end
                    % userC is k×3
                    assert(size(userC,2)==3, 'opts.Colors numeric must be 1x3 or kx3.');
                    k = size(userC,1);
                    if k >= n
                        C = userC(1:n,:);                   % take first n
                    else
                        idx = round(linspace(1, k, n));     % resample to n rows
                        C = userC(idx, :);
                    end
                    return
                end
            
                % Cell array of colors (char ColorSpec or 1x3 RGB)
                if iscell(userC)
                    k = numel(userC);
                    if k < n
                        % repeat entries to reach n
                        userC = userC(1+mod(0:n-1, max(1,k)));
                    else
                        userC = userC(1:n);
                    end
                    C = userC;
                    return
                end
            
                error('opts.Colors must be: [], colormap name, 1x3 or kx3 RGB, or cell array.');
            end
            
            function c = getC(Cin, j)
                % Returns either 1x3 RGB or a char ColorSpec ('r','red', etc.)
                if iscell(Cin), c = Cin{j}; else, c = Cin(j,:); end
                if isstring(c), c = char(c); end
            end
            
            function styleAxesAndLegend(names, o)
                ax = gca; ax.FontSize = o.TickLabelSize;
                xlabel(o.XLabel, 'FontSize', o.AxisLabelSize);
                ylabel(o.YLabel, 'FontSize', o.AxisLabelSize);
                if ~strcmpi(o.LegendLocation, "none")
                    lgd = legend(names, 'Location', char(o.LegendLocation));
                    if ~isempty(lgd), lgd.FontSize = o.LegendFontSize; end
                end
            end
            
            function applyLimits(o)
                if ~isempty(o.XLim), xlim(o.XLim); end
                if ~isempty(o.YLim), ylim(o.YLim); end
            end
            
            function applyTitle(o, defaultTitle)
                if strlength(o.Title) > 0
                    title(string(o.Title), 'FontSize', o.TitleFontSize);
                else
                    title(defaultTitle, 'FontSize', o.TitleFontSize);
                end
            end

            function [t_out, z_cum] = computeEscapeCDFFromRaw(rawSol)
                Nt = numel(rawSol.fsp);
                t_out = zeros(Nt,1);
                flux  = zeros(Nt,1);
                for i = 1:Nt
                    S = rawSol.fsp{i};
                    if isfield(S,'time'), t_out(i) = S.time;
                    elseif isfield(S,'T'), t_out(i) = S.T;
                    elseif isfield(S,'t'), t_out(i) = S.t;
                    else, t_out(i) = i;
                    end
                    if isfield(S,'escapeProbs') && ~isempty(S.escapeProbs)
                        v = S.escapeProbs(:);
                    elseif isfield(S,'sinks') && ~isempty(S.sinks)
                        v = S.sinks(:);
                    else
                        v = 0;
                    end
                    flux(i) = nansum(v);
                end
                tol = 1e-12;
                looksCum = all(diff(max(0,min(1,flux))) >= -tol) && flux(end) <= 1+1e-6;
                if looksCum, z_cum = max(0,min(1,flux));
                else,        z_cum = max(0,min(1,cumsum(max(0,flux))));
                end
            end
            
            function col = resolveOneColor(userC)
                if isempty(userC), col = lines(1); return; end
                if ischar(userC) || (isstring(userC) && isscalar(userC))
                    cm = feval(char(userC), 64); col = cm(1,:); return
                end
                if isnumeric(userC)
                    if isvector(userC) && numel(userC)==3, col = double(userC(:)).';
                    else, col = double(userC(1,:)); end
                    return
                end
                if iscell(userC)
                    c = userC{1}; if isstring(c), c = char(c); end
                    if isnumeric(c) && numel(c)==3, col = double(c(:)).'; else, col = c; end
                    return
                end
                col = lines(1);
            end

            function [t_out, Z_cum] = computeEscapeCDFFromRawMulti(rawSol)
                % Returns:
                %   t_out : Nt x 1 time vector
                %   Z_cum : Nt x nSinks cumulative probabilities, one column per sink
                Nt = numel(rawSol.fsp);
                t_out = zeros(Nt,1);
            
                % Determine number of sinks from first timestep
                S1 = rawSol.fsp{1};
                if isfield(S1, 'escapeProbs') && ~isempty(S1.escapeProbs)
                    nSinks = numel(S1.escapeProbs);
                    modeField = 'escapeProbs';
                elseif isfield(S1, 'sinks') && ~isempty(S1.sinks)
                    nSinks = numel(S1.sinks);
                    modeField = 'sinks';
                else
                    nSinks = 1; modeField = '';   % degenerate
                end
            
                flux = zeros(Nt, nSinks);    % per-step flux into each sink
                for i = 1:Nt
                    Si = rawSol.fsp{i};
                    % time
                    if isfield(Si,'time'), t_out(i) = Si.time;
                    elseif isfield(Si,'T'), t_out(i) = Si.T;
                    elseif isfield(Si,'t'), t_out(i) = Si.t;
                    else, t_out(i) = i;
                    end
                    % per-sink increments
                    v = zeros(1, nSinks);
                    if ~isempty(modeField)
                        vv = Si.(modeField);
                        if ~isempty(vv), v = vv(:).'; end
                    end
                    % store
                    flux(i, :) = v(1, 1:nSinks);
                end
            
                % Heuristic: if looks cumulative already, use as-is; else cumsum
                Z_cum = zeros(Nt, nSinks);
                for k = 1:nSinks
                    col = flux(:,k);
                    col(~isfinite(col)) = 0;
                    col = max(0, min(1, col));
                    looksCum = all(diff(col) >= -1e-12) && col(end) <= 1 + 1e-6;
                    if looksCum
                        Z_cum(:,k) = col;
                    else
                        Z_cum(:,k) = max(0, min(1, cumsum(max(0,col))));
                    end
                end
            end
            
         end


        function figHandles = makeFitPlot(obj,fitSolution,smoothWindow,fignums,usePanels, ...
                varianceType,IQRrange,suppressFigures)
            % Produces plots to compare model to experimental data.
            arguments
                obj
                fitSolution =[];
                smoothWindow = 1;
                fignums = [];
                usePanels=true;
                varianceType = 'STD';  % Plot type standard deviation ('STD') or interquartile range ('IQR'). {'STD', 'IQR'}
                IQRrange = 0.25        % Interquartile range for plotting (will draw lines at [IQRrange,1-IQRrange]).
                suppressFigures = false % Hide figures.  Will need to manually make them visible again for viewing.
            end
            if isempty(fitSolution)
                [~,~,fitSolution] = obj.computeLikelihood;
            end
            figHandles = makeSeparatePlotOfData(fitSolution,smoothWindow,fignums,usePanels, ...
                varianceType,IQRrange,suppressFigures);
        end

        function makeMleFimPlot(obj,MLE,FIM,indPars,CI,figNum,par0)
            arguments
                obj
                MLE = []
                FIM = []
                indPars = [1,2];
                CI = 0.95
                figNum=[]
                par0 = []
            end
            if isempty(figNum)
                f = gcf; set(0,'CurrentFigure',f);
            else
                f = figure(figNum); set(0,'CurrentFigure',f);
            end

            CIp = round(CI*100);

            legs = {};

            if ~isempty(MLE)
                scatter(MLE(indPars(1),:),MLE(indPars(2),:),100*ones(size(MLE(indPars(1),:))),'filled');
                covMLE = cov(MLE');
                muMLE = mean(MLE,2);
                hold on
                ssit.parest.ellipse(muMLE(indPars),icdf('chi2',CI,2)*covMLE(indPars,indPars),'linewidth',3)
                legs(end+1:end+2) = {['MLE, N=',num2str(length(MLE))],[num2str(CIp),'% CI (MLE)']};
                if isempty(par0)
                    par0 = muMLE;
                end
            end

            if ~isempty(FIM)
                covFIM = FIM^(-1);
                ssit.parest.ellipse(par0(indPars),icdf('chi2',CI,2)*covFIM(indPars,indPars),'--','linewidth',3)
                legs(end+1) = {[num2str(CIp),'% CI (FIM)']};
            end
            set(gca,'fontsize',15)
            legend(legs)

        end

        function plotMHResults(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true
            end

            obj.plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig)
        end
    end
    methods (Static)
        function plotMHResultsStatic(obj,mhResults,FIM,fimScale,mhPlotScale,scatterFig,showConvergence,plotColors)
            arguments
                obj
                mhResults = [];
                FIM =[];
                fimScale = 'lin';
                mhPlotScale = 'log10';
                scatterFig = [];
                showConvergence = true;
                plotColors = struct() % Optional: fields like scatter, ellipseFIM, ellipseMH, etc.
            end

            if isfield(plotColors, 'scatter')
                scatterColor = plotColors.scatter;
            else
                scatterColor = [];
            end

            if isfield(plotColors, 'ellipseFIM')
                ellipseFIMColor = plotColors.ellipseFIM;
            else
                ellipseFIMColor = [];
            end

            if isfield(plotColors, 'ellipseMH')
                ellipseMHColor = plotColors.ellipseMH;
            else
                ellipseMHColor = 'm--';
            end

            if isfield(plotColors, 'marker')
                markerColor = plotColors.marker;
            else
                markerColor = 'k';
            end

            if isempty(obj)
                obj.fittingOptions.modelVarsToFit = 'all';
                obj.parameters(:,2) = num2cell(mean(exp(mhResults.mhSamples)));
            end

            if strcmp(obj.fittingOptions.modelVarsToFit,'all')
                obj.fittingOptions.modelVarsToFit = ones(1,size(obj.parameters,1),'logical');
            end
            parNames = obj.parameters(obj.fittingOptions.modelVarsToFit,1);
            Np = length(parNames);

            if ~isempty(FIM)
                pars = [obj.parameters{obj.fittingOptions.modelVarsToFit,2}];

                if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                    parsScaled = log10(pars);
                elseif strcmp(mhPlotScale,'log')
                    parsScaled = log(pars);
                elseif strcmp(mhPlotScale,'lin')
                    parsScaled = pars;
                end

                if ~iscell(FIM)
                    FIM = {FIM};
                end
                %     FIM = diag(pars)*...
                %         FIM(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                %         diag(pars);
                %     covFIM{1} = FIM^(-1)/log(10)^2;
                % else
                for i=1:length(FIM)
                    if isempty(fimScale)||strcmp(fimScale,'lin')
                        FIMi = diag(pars)*...
                            FIM{i}(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit)*...
                            diag(pars);
                    else
                        FIMi = FIM{i};
                    end
                    FIMi = FIMi(obj.fittingOptions.modelVarsToFit,obj.fittingOptions.modelVarsToFit);
                    if isempty(mhPlotScale)||strcmp(mhPlotScale,'log10')
                        covFIM{i} = FIMi^(-1)/log(10)^2;
                    else
                        covFIM{i} = FIMi^(-1);
                    end
                end
                % end
            end

            if ~isempty(mhResults)
                % Make figures for MH convergence
                if showConvergence
                    fg = figure; set(0,'CurrentFigure',fg)
                    plot(mhResults.mhValue);
                    xlabel('Iteration number');
                    ylabel('log-likelihood')
                    title('MH Convergence')

                    fg = figure; set(0,'CurrentFigure',fg)
                    ac = xcorr(mhResults.mhValue-mean(mhResults.mhValue),'normalized');
                    ac = ac(size(mhResults.mhValue,1):end);
                    plot(ac,'LineWidth',3); hold on
                    N = size(mhResults.mhValue,1);
                    tau = 1+2*sum((ac(2:N/100)));
                    Neff = N/tau;
                    xlabel('Lag');
                    ylabel('Auto-correlation')
                    title('MH Convergence')
                end

                if isempty(scatterFig)
                    fg = figure; set(0,'CurrentFigure',fg);
                else
                    fg = figure(scatterFig); set(0,'CurrentFigure',fg)
                end


                % Select second half of MH chain.
                mhResultsSecondHalf = mhResults;
                mhResultsSecondHalf.mhValue = mhResultsSecondHalf.mhValue(floor(end/2):end);
                mhResultsSecondHalf.mhSamples = mhResultsSecondHalf.mhSamples(floor(end/2):end,:);
                [valDoneSorted,J] = sort(mhResultsSecondHalf.mhValue);
                smplDone = mhResultsSecondHalf.mhSamples(J,:);

                % Compute and display parameter means and standard deviations
                mhMeans = mean(smplDone) / log(10);   % log10 scale
                mhStds  = std(smplDone) / log(10);

                fprintf('\nMH sample means and standard deviations (log10 scale):\n');
                for p = 1:Np
                    fprintf('%15s: mean = % .4f, std = %.4f\n', parNames{p}, mhMeans(p), mhStds(p));
                end

            end

            fimCols = {'k','c','b','g','r'};

            for i=1:Np-1
                for j = i+1:Np
                    subplot(Np-1,Np-1,(i-1)*(Np-1)+j-1);

                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        scatter(smplDone(:,j)/log(10),smplDone(:,i)/log(10),20,valDoneSorted,'filled'); hold on;
                        par0 = mean(smplDone(:,[j,i])/log(10));
                        cov12 = cov(smplDone(:,j)/log(10),smplDone(:,i)/log(10));
                    end
                    if ~isempty(FIM)
                        for iFIM = 1:length(covFIM)
                            ssit.parest.ellipse(parsScaled([j,i]),icdf('chi2',0.9,2)*covFIM{iFIM}([j,i],[j,i]),fimCols{mod(iFIM,5)+1},'linewidth',2); hold on;
                            plot(parsScaled(j),parsScaled(i),'ks','MarkerSize',15)
                            % plot(smplDone(end,j)/log(10),smplDone(end,i)/log(10),'cs','MarkerSize',15)
                        end
                    end
                    if exist('mhResultsSecondHalf','var')&&~isempty(mhResultsSecondHalf)
                        ssit.parest.ellipse(par0,icdf('chi2',0.9,2)*cov12,'m--','linewidth',2);  hold on;
                        % Draw crosshairs at MH mean ± std
                        % plot([mhMeans(j)-mhStds(j), mhMeans(j)+mhStds(j)], [mhMeans(i), mhMeans(i)], 'm-', 'LineWidth', 1.5);
                        % plot([mhMeans(j), mhMeans(j)], [mhMeans(i)-mhStds(i), mhMeans(i)+mhStds(i)], 'm-', 'LineWidth', 1.5);
                        %
                        % % Annotate mean location
                        % text(mhMeans(j), mhMeans(i), sprintf('\\leftarrow Mean'), 'Color', 'm', 'FontSize', 8, 'HorizontalAlignment', 'left');

                    end
                    xlabel(['log_{10}(',parNames{j},')']);
                    ylabel(['log_{10}(',parNames{i},')']);
                end
            end
        end
        function FIM = totalFim(fims,Nc,covPrior)
            arguments
                fims
                Nc
                covPrior = [];
            end
            if isempty(covPrior)
                fimPrior = zeros(size(fims{1}));
            else
                fimPrior = inv(covPrior);
            end
            Nt = size(fims,1);
            Ns = size(fims,2);
            FIM = cell(1,Ns);
            for is = 1:Ns
                FIM{is} = fimPrior;
                for it = 1:Nt
                    FIM{is} = FIM{is}+Nc(it)*fims{it,is};
                end
            end
        end
        function k = findBestMove(fims,Ncp,met,NcMax,statistic,covPrior,incrementAdd)
            arguments
                fims
                Ncp
                met
                NcMax = []
                statistic='mean'
                covPrior=[]
                incrementAdd=1
            end
            if isempty(statistic)
                statistic='mean';
            end
            Nt = size(fims,1);
            if isempty(NcMax)
                NcMax = inf*ones(1,Nt);
            end
            Ns = size(fims,2);
            objFun = zeros(Nt,Ns);
            FIM0 = SSIT.totalFim(fims,Ncp,covPrior);
            for is = 1:Ns
                for it = 1:Nt
                    if Ncp(it)+incrementAdd<=NcMax(it)
                        % If one can do that experiment.
                        FIM = FIM0{is}+incrementAdd*fims{it,is};
                    else
                        % If there are no more cells avalable for that time
                        % point.
                        FIM = FIM0{is};
                    end
                    objFun(it,is) = met(FIM);
                end
            end
            switch statistic
                case 'median'
                    [~,k] = min(median(objFun,2));
                case 'mean'
                    [~,k] = min(mean(objFun,2));
                otherwise
                    [~,k] = min(median(objFun,2));
            end
        end
        function propensities = parameterizePropensities(GenProps,Parset)
            propensities = GenProps;
            for i=1:length(GenProps)
                if ~isempty(propensities{i}.stateDependentFactor)
                    propensities{i}.stateDependentFactor = @(x)GenProps{i}.stateDependentFactor(x,Parset);
                end
                if ~isempty(propensities{i}.hybridFactor)
                    propensities{i}.hybridFactor = @(t,v)GenProps{i}.hybridFactor(t,Parset,v');
                end
                if ~isempty(propensities{i}.hybridFactorVector)
                    propensities{i}.hybridFactorVector = @(t,v)GenProps{i}.hybridFactorVector(t,Parset,v');
                end
                if ~isempty(propensities{i}.timeDependentFactor)
                    propensities{i}.timeDependentFactor = @(t)GenProps{i}.timeDependentFactor(t,Parset);
                end
                if ~isempty(propensities{i}.hybridJointFactor)
                    propensities{i}.hybridJointFactor = @(t,x,v)GenProps{i}.hybridJointFactor(t,x,Parset,v');
                end
            end
        end
        function str = replaceSpeciesNames(str,species)
            % Check if species are named 'x1','x2', etc, and if not, find
            % order of species names longest to shortest.
            namedXi = true;
            Len = NaN*ones(length(species));
            for i = 1:length(species)
                Len(i) = length(species{i});
                if ~strcmp(species{i},['x',num2str(i)])
                    namedXi = false;
                end
            end
            if namedXi % No need to change string.
                return
            end

            [~,order] = sort(Len,'descend');
            for i = 1:length(order)
                % str = strrep(str,species{order(i)},['x',num2str(i)]);
                str = regexprep(str,['\<',species{order(i)},'\>'],['x',num2str(i)]);
            end

        end
        function cmd = generateCommandLinePipeline(saveFileIn,modelName,dummy, ...
                Pipeline,pipelineArgs,saveFileOut,logFile,runNow,runOnCluster,clusterPrefix)
            arguments
                saveFileIn
                modelName
                dummy
                Pipeline
                pipelineArgs
                saveFileOut
                logFile
                runNow = false
                runOnCluster = false
                clusterPrefix = 'sbatch --cpus-per-task=1 --output=#LOG --error=#ERR --wrap="module load matlab-2022b; srun matlab -nodisplay -nosplash -nodesktop -r'
            end

            % TODO - code currently works only for Mac and linux.  Need to
            % use 'batch' for Windows.

            % Parse inputs into format needed for command line call.
            str1 = append('(''',saveFileIn,''',''',modelName,''',[],''',Pipeline,''',');
            str2 = 'struct(';
            fieldNames = fields(pipelineArgs);
            for iField = 1:length(fieldNames)
                field = fieldNames{iField};
                if isnumeric(pipelineArgs.(field))||islogical(pipelineArgs.(field))
                    value = num2str(pipelineArgs.(field));
                else
                    value = append('''',pipelineArgs.(field),'''');
                end
                str2 = append(str2,'''',field,''',',value,',');
            end
            str2 = append(str1,str2(1:end-1),'),''',saveFileOut,'''');

            % Add path to SSIT.
            pth = which('SSIT');
            pth = append('addpath(genpath(''',pth(1:end-19),'''));addpath(''tmpPropensityFunctions'');');

            % Add path to matlab executable
            matlabpath = fullfile(matlabroot, 'bin', 'matlab');

            % Build command
            if ~runOnCluster
                cmd = append(matlabpath,' -nodisplay -nosplash -nodesktop -r "',pth,'SSIT',str2,')',...
                    '; exit;" > ',logFile,' 2>&1 < /dev/null &');
            else
                % clusterPrefix = strrep(clusterPrefix,'#LOG',logFile);
                % clusterPrefix = strrep(clusterPrefix,'#ERR',append('err_',logFile));
                clusterPrefix = regexprep(clusterPrefix,'\<#LOG\>',logFile);
                clusterPrefix = regexprep(clusterPrefix,'\<#ERR\>',append('err_',logFile));

                % pth = strrep(pth,"'","''");
                % str2 = strrep(str2,"'","''");

                cmd = append(clusterPrefix,' \"',pth,'SSIT',str2,')',...
                    '; exit;\""');
            end

            % Run command if requested.
            if runNow
                system(cmd);
            end

        end
        function runCrossValidation(Model,DataFileName, ...
                LinkedSpecies,ConditionsGlobal,ConditionsReplicas, ...
                modelLibrary, pipeline, pipelineArgs, stateSpace, useCluster)
            % This method will create and launch background jobs (or
            % cluster jobs) to conduct fits (or other specified pipelines)
            % of the same model but on different data sets as specified in
            % 'ConditionsReplicas.
            arguments
                Model
                DataFileName
                LinkedSpecies
                ConditionsGlobal
                ConditionsReplicas
                modelLibrary
                pipeline = 'fittingPipelineExample';
                pipelineArgs = struct('maxIter',1000,'display','iter','makePlot',0);
                stateSpace  = [];
                useCluster = false;
            end

            nPars = size(Model.parameters,1);
            SMM = SSITMultiModel.createCrossValMultiModel(Model,DataFileName, ...
                LinkedSpecies,ConditionsGlobal,ConditionsReplicas, ...
                zeros(1,nPars), stateSpace);

            nRepSets = length(ConditionsReplicas);

            % Split Up and Save Models
            for i = 1:nRepSets
                eval(['Model_',num2str(i),'=SMM.SSITModels{i};'])
            end
            save(modelLibrary,'Model_*');

            % Launch background jobs to fit each model.
            for i = 1:nRepSets
                modelName = ['Model_',num2str(i)];
                saveFile2 = [modelLibrary,'_',num2str(i)];
                logfile = ['logFile',num2str(i),'.txt'];
                SSIT.generateCommandLinePipeline(modelLibrary,modelName,[],pipeline,pipelineArgs,saveFile2,logfile,1,useCluster);
            end
        end
    end
end
